diff -Naurdp -x .gitignore -x '*~' -x '*.orig' -x '*.rej' ipipe-2.6.15-arm-at91/arch/arm/mach-at91rm9200/Kconfig ipipe-2.6.15-arm-at91-ipipe_at91/arch/arm/mach-at91rm9200/Kconfig
--- ipipe-2.6.15-arm-at91/arch/arm/mach-at91rm9200/Kconfig	2007-03-02 01:43:13.000000000 +0100
+++ ipipe-2.6.15-arm-at91-ipipe_at91/arch/arm/mach-at91rm9200/Kconfig	2007-03-10 13:03:52.000000000 +0100
@@ -55,6 +55,24 @@ config AT91_PROGRAMMABLE_CLOCKS
 	  Select this if you need to program one or more of the PCK0..PCK3
 	  programmable clock outputs.
 
+config IPIPE_AT91_TC
+	depends on IPIPE
+	int "AT91 TC used as time base"
+	default 0
+	help
+	When Adeos interrupt pipeline is enabled, TC0 is used by default
+	as time base, but you can use TC1 or TC2 by setting this variable to 1
+	or 2. This should only be needed to avoid conflicts with other drivers.
+
+config IPIPE_AT91_MCK
+	depends on IPIPE
+	int "AT91 Master clock Frequency"
+	default 46080000
+	help
+	When Adeos interrupt pipeline is enabled, AT91 timer is based on
+	the AT91 master clock, whose frequency need hence to be known at
+	compilation time.
+
 endmenu
 
 endif
diff -Naurdp -x .gitignore -x '*~' -x '*.orig' -x '*.rej' ipipe-2.6.15-arm-at91/arch/arm/mach-at91rm9200/clock.c ipipe-2.6.15-arm-at91-ipipe_at91/arch/arm/mach-at91rm9200/clock.c
--- ipipe-2.6.15-arm-at91/arch/arm/mach-at91rm9200/clock.c	2007-03-10 13:25:02.000000000 +0100
+++ ipipe-2.6.15-arm-at91-ipipe_at91/arch/arm/mach-at91rm9200/clock.c	2007-03-10 13:24:48.000000000 +0100
@@ -202,6 +202,29 @@ static struct clk ohci_clk = {
 	.mode		= pmc_periph_mode,
 };
 
+#ifdef CONFIG_IPIPE
+static struct clk tc0 = {
+	.name		= "tc0",
+	.parent         = &mck,
+	.pmc_mask       = 1 << AT91_ID_TC0,
+	.mode           = pmc_periph_mode,
+};
+
+static struct clk tc1 = {
+	.name		= "tc1",
+	.parent         = &mck,
+	.pmc_mask       = 1 << AT91_ID_TC1,
+	.mode           = pmc_periph_mode,
+};
+
+static struct clk tc2 = {
+	.name		= "tc2",
+	.parent         = &mck,
+	.pmc_mask       = 1 << AT91_ID_TC2,
+	.mode           = pmc_periph_mode,
+};
+#endif /* CONFIG_IPIPE */
+
 static struct clk *const clock_list[] = {
 	/* four primary clocks -- MUST BE FIRST! */
 	&clk32k,
@@ -230,6 +253,11 @@ static struct clk *const clock_list[] = 
 	// spi
 	// ssc0..ssc2
 	// tc0..tc5
+#ifdef CONFIG_IPIPE
+	&tc0,
+	&tc1,
+	&tc2,
+#endif /* CONFIG_IPIPE */
 	&ohci_clk,
 	// ether
 };
diff -Naurdp -x .gitignore -x '*~' -x '*.orig' -x '*.rej' ipipe-2.6.15-arm-at91/arch/arm/mach-at91rm9200/gpio.c ipipe-2.6.15-arm-at91-ipipe_at91/arch/arm/mach-at91rm9200/gpio.c
--- ipipe-2.6.15-arm-at91/arch/arm/mach-at91rm9200/gpio.c	2007-03-02 01:43:13.000000000 +0100
+++ ipipe-2.6.15-arm-at91-ipipe_at91/arch/arm/mach-at91rm9200/gpio.c	2007-03-10 13:32:54.000000000 +0100
@@ -18,6 +18,11 @@
 #include <asm/mach/irq.h>
 #include <asm/arch/hardware.h>
 #include <asm/arch/gpio.h>
+#ifdef CONFIG_IPIPE
+#include <asm/irq.h>
+
+unsigned __ipipe_at91_gpio_banks = 0;
+#endif /* CONFIG_IPIPE */
 
 static const u32 pio_controller_offset[4] = {
 	AT91_PIOA,
@@ -232,6 +237,9 @@ static int gpio_irq_type(unsigned pin, u
 }
 
 static struct irqchip gpio_irqchip = {
+#ifdef CONFIG_IPIPE
+	.ack            = gpio_irq_mask,
+#endif
 	.mask		= gpio_irq_mask,
 	.unmask		= gpio_irq_unmask,
 	.set_type	= gpio_irq_type,
@@ -268,6 +276,50 @@ static void gpio_irq_handler(unsigned ir
 	/* now it may re-trigger */
 }
 
+#ifdef CONFIG_IPIPE
+void __ipipe_mach_demux_irq(unsigned irq, struct pt_regs *regs)
+{
+	struct irqdesc *desc = irq_desc + irq;
+	unsigned	pin;
+	struct irqdesc	*gpio;
+	void __iomem	*pio;
+	u32		isr;
+
+	pio = (void __force __iomem *) desc->chipdata;
+
+	/* temporarily mask (level sensitive) parent IRQ */
+	desc->chip->ack(irq);
+	for (;;) {
+		isr = __raw_readl(pio + PIO_ISR) & __raw_readl(pio + PIO_IMR);
+		if (!isr)
+			break;
+
+		pin = (unsigned) desc->data;
+		gpio = &irq_desc[pin];
+
+		while (isr) {
+			if (isr & 1) {
+				if (unlikely(gpio->disable_depth)) {
+					/*
+					 * The core ARM interrupt handler lazily disables IRQs so
+					 * another IRQ must be generated before it actually gets
+					 * here to be disabled on the GPIO controller.
+					 */
+					gpio->chip->mask(pin);
+				}
+				else
+					__ipipe_handle_irq(pin, regs);
+			}
+			pin++;
+			gpio++;
+			isr >>= 1;
+		}
+	}
+	desc->chip->unmask(irq);
+	/* now it may re-trigger */
+}
+#endif /* CONFIG_IPIPE */
+
 /* call this from board-specific init_irq */
 void __init at91_gpio_irq_setup(unsigned banks)
 {
@@ -299,4 +351,7 @@ void __init at91_gpio_irq_setup(unsigned
 		at91_sys_write(AT91_PMC_PCER, 1 << id);
 	}
 	pr_info("AT91: %d gpio irqs in %d banks\n", pin - PIN_BASE, banks);
+#ifdef CONFIG_IPIPE
+	__ipipe_at91_gpio_banks = banks;
+#endif /* CONFIG_IPIPE */
 }
diff -Naurdp -x .gitignore -x '*~' -x '*.orig' -x '*.rej' ipipe-2.6.15-arm-at91/arch/arm/mach-at91rm9200/irq.c ipipe-2.6.15-arm-at91-ipipe_at91/arch/arm/mach-at91rm9200/irq.c
--- ipipe-2.6.15-arm-at91/arch/arm/mach-at91rm9200/irq.c	2007-03-20 20:43:02.000000000 +0100
+++ ipipe-2.6.15-arm-at91-ipipe_at91/arch/arm/mach-at91rm9200/irq.c	2007-03-20 20:42:35.000000000 +0100
@@ -41,6 +41,7 @@
  * The default interrupt priority levels (0 = lowest, 7 = highest).
  */
 static unsigned int at91rm9200_default_irq_priority[NR_AIC_IRQS] __initdata = {
+#ifndef CONFIG_IPIPE
 	7,	/* Advanced Interrupt Controller */
 	7,	/* System Peripheral */
 	0,	/* Parallel IO Controller A */
@@ -73,6 +74,42 @@ static unsigned int at91rm9200_default_i
 	0,	/* Advanced Interrupt Controller */
 	0,	/* Advanced Interrupt Controller */
 	0	/* Advanced Interrupt Controller */
+#else /* CONFIG_IPIPE */
+/* Give the highest priority to TC, since they are used as timer interrupt by
+   I-pipe. */
+	7,	/* Advanced Interrupt Controller */
+	6,	/* System Peripheral */
+	0,	/* Parallel IO Controller A */
+	0,	/* Parallel IO Controller B */
+	0,	/* Parallel IO Controller C */
+	0,	/* Parallel IO Controller D */
+	5,	/* USART 0 */
+	5,	/* USART 1 */
+	5,	/* USART 2 */
+	5,	/* USART 3 */
+	0,	/* Multimedia Card Interface */
+	3,	/* USB Device Port */
+	0,	/* Two-Wire Interface */
+	5,	/* Serial Peripheral Interface */
+	4,	/* Serial Synchronous Controller */
+	4,	/* Serial Synchronous Controller */
+	4,	/* Serial Synchronous Controller */
+	7,	/* Timer Counter 0 */
+	7,	/* Timer Counter 1 */
+	7,	/* Timer Counter 2 */
+	0,	/* Timer Counter 3 */
+	0,	/* Timer Counter 4 */
+	0,	/* Timer Counter 5 */
+	2,	/* USB Host port */
+	2,	/* Ethernet MAC */
+	0,	/* Advanced Interrupt Controller */
+	0,	/* Advanced Interrupt Controller */
+	0,	/* Advanced Interrupt Controller */
+	0,	/* Advanced Interrupt Controller */
+	0,	/* Advanced Interrupt Controller */
+	0,	/* Advanced Interrupt Controller */
+	0	/* Advanced Interrupt Controller */
+#endif /*CONFIG_IPIPE */
 };
 
 
diff -Naurdp -x .gitignore -x '*~' -x '*.orig' -x '*.rej' ipipe-2.6.15-arm-at91/arch/arm/mach-at91rm9200/time.c ipipe-2.6.15-arm-at91-ipipe_at91/arch/arm/mach-at91rm9200/time.c
--- ipipe-2.6.15-arm-at91/arch/arm/mach-at91rm9200/time.c	2007-03-02 01:43:13.000000000 +0100
+++ ipipe-2.6.15-arm-at91-ipipe_at91/arch/arm/mach-at91rm9200/time.c	2007-03-10 13:26:45.000000000 +0100
@@ -31,6 +31,62 @@
 #include <asm/irq.h>
 #include <asm/mach/time.h>
 
+#ifdef CONFIG_IPIPE
+#include <asm/hardware/clock.h>
+#include <linux/console.h>
+#include <linux/module.h>
+#include <asm/arch/at91rm9200_tc.h>
+
+#ifdef CONFIG_NO_IDLE_HZ
+#error "dynamic tick timer not yet supported with IPIPE"
+#endif /* CONFIG_NO_IDLE_HZ */
+
+#define TCNXCNS(timer,v) ((v) << ((timer)<<1))
+#define AT91_TC_REG_MASK (0xffff)
+
+#if (CONFIG_IPIPE_AT91_TC==0)
+#   define KERNEL_TIMER_IRQ_NUM AT91_ID_TC0
+#elif (CONFIG_IPIPE_AT91_TC==1)
+#   define KERNEL_TIMER_IRQ_NUM AT91_ID_TC1
+#elif (CONFIG_IPIPE_AT91_TC==2)
+#   define KERNEL_TIMER_IRQ_NUM AT91_ID_TC2
+#else
+#error IPIPE_AT91_TC must be 0, 1 or 2.
+#endif
+
+static inline unsigned int at91_tc_read(unsigned int reg_offset)
+{
+	unsigned long addr =
+		(AT91_VA_BASE_TCB0 + 0x40 * CONFIG_IPIPE_AT91_TC);
+
+	return readl((void __iomem *)(addr + reg_offset));
+}
+
+static inline void at91_tc_write(unsigned int reg_offset, unsigned long value)
+{
+	unsigned long addr =
+		(AT91_VA_BASE_TCB0 + 0x40 * CONFIG_IPIPE_AT91_TC);
+
+	writel(value, (void __iomem *)(addr + reg_offset));
+}
+
+#define read_CV() at91_tc_read(AT91_TC_CV)
+#define read_RC() at91_tc_read(AT91_TC_RC)
+#define write_RC(value) at91_tc_write(AT91_TC_RC, value)
+
+int __ipipe_mach_timerint = KERNEL_TIMER_IRQ_NUM;
+EXPORT_SYMBOL(__ipipe_mach_timerint);
+
+int __ipipe_mach_timerstolen = 0;
+EXPORT_SYMBOL(__ipipe_mach_timerstolen);
+
+unsigned int __ipipe_mach_ticks_per_jiffy = LATCH;
+EXPORT_SYMBOL(__ipipe_mach_ticks_per_jiffy);
+
+static int at91_timer_initialized;
+static unsigned long last_jiffy_time;
+#endif /* CONFIG_IPIPE */
+
 /*
  * The ST_CRTR is updated asynchronously to the master clock.  It is therefore
  *  necessary to read it twice (with the same value) to ensure accuracy.
@@ -38,14 +94,16 @@
 static inline unsigned long read_CRTR(void) {
 	unsigned long x1, x2;
 
+	x2 = at91_sys_read(AT91_ST_CRTR);
 	do {
-		x1 = at91_sys_read(AT91_ST_CRTR);
+		x1 = x2;
 		x2 = at91_sys_read(AT91_ST_CRTR);
 	} while (x1 != x2);
 
 	return x1;
 }
 
+#ifndef CONFIG_IPIPE
 /*
  * Returns number of microseconds since last timer interrupt.  Note that interrupts
  * will have been disabled by do_gettimeofday()
@@ -125,3 +183,199 @@ struct sys_timer at91rm9200_timer = {
 	.init		= at91rm9200_timer_init,
 	.offset		= at91rm9200_gettimeoffset,
 };
+
+#else /* CONFIG_IPIPE */
+
+/*
+ * Returns number of microseconds since last timer interrupt.  Note that interrupts
+ * will have been disabled by do_gettimeofday()
+ *  'LATCH' is hwclock ticks (see CLOCK_TICK_RATE in timex.h) per jiffy.
+ *  'tick' is usecs per jiffy (linux/timex.h).
+ */
+static unsigned long at91rm9200_gettimeoffset(void)
+{
+	unsigned long elapsed;
+
+	elapsed = (read_CV() - last_jiffy_time) & AT91_TC_REG_MASK;
+
+	return (unsigned long) (elapsed * (tick_nsec / 1000)) / LATCH;
+}
+
+void __ipipe_mach_acktimer(void)
+{
+	at91_tc_read(AT91_TC_SR);
+}
+
+/*
+ * IRQ handler for the timer.
+ */
+static irqreturn_t at91rm9200_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	/*
+	 * - if Linux is running under ipipe, but it still has the control over
+	 *   the timer (no Xenomai for example), then reprogram the timer (ipipe
+	 *   has already acked it)
+	 * - if some other domain has taken over the timer, then do nothing
+	 *   (ipipe has acked it, and the other domain has reprogramed it)
+	 */
+
+	write_seqlock(&xtime_lock);
+
+	if (__ipipe_mach_timerstolen) {
+		timer_tick(regs);
+		last_jiffy_time = (last_jiffy_time + LATCH) & AT91_TC_REG_MASK;
+	} else {
+		while (((read_CV() - last_jiffy_time) & AT91_TC_REG_MASK) >= LATCH) {
+			timer_tick(regs);
+			last_jiffy_time = (last_jiffy_time + LATCH) & AT91_TC_REG_MASK;
+		}
+		write_RC((last_jiffy_time + LATCH) & AT91_TC_REG_MASK);
+	}
+
+	write_sequnlock(&xtime_lock);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t at91rm9200_bad_freq(int irq, void *dev_id, struct pt_regs *regs)
+{
+	static int ticks = 0;
+
+	if (++ticks != HZ * 120) {
+		if (!console_drivers || try_acquire_console_sem())
+			return at91rm9200_timer_interrupt(irq, dev_id, regs);
+	
+		release_console_sem();
+	}
+
+	panic("AT91 clock rate incorrectly set.\n"
+	      "Please recompile with IPIPE_AT91_MCK set to %lu Hz.",
+	      clk_get_rate(clk_get(NULL, "mck")));
+}
+
+notrace unsigned long long __ipipe_mach_get_tsc(void)
+{
+	if (likely(at91_timer_initialized)) {
+		static union {
+#ifdef __BIG_ENDIAN
+			struct {
+				unsigned long high;
+				unsigned short mid;
+				unsigned short low;
+			};
+#else /* __LITTLE_ENDIAN */
+			struct {
+				unsigned short low;
+				unsigned short mid;
+				unsigned long high;
+			};
+#endif /* __LITTLE_ENDIAN */
+			unsigned long long full;
+		} tsc[NR_CPUS], *local_tsc;
+		unsigned long long result;
+		unsigned short stamp;
+		unsigned long flags;
+
+		local_irq_save_hw(flags);
+		local_tsc = &tsc[ipipe_processor_id()];
+		stamp = read_CV();
+		if (unlikely(stamp < local_tsc->low)) {
+			if (unlikely(!++local_tsc->mid))
+				/* 32 bit counter wrapped, increment high word. */
+				local_tsc->high++;
+		}
+		local_tsc->low = stamp;
+		result = local_tsc->full;
+		local_irq_restore_hw(flags);
+
+		return result;
+	}
+	
+        return 0;
+}
+EXPORT_SYMBOL(__ipipe_mach_get_tsc);
+
+/*
+ * Reprogram the timer
+ */
+
+void __ipipe_mach_set_dec(unsigned long delay)
+{
+	unsigned long flags;
+
+	if (delay > 2) {
+		local_irq_save_hw(flags);
+		write_RC((read_CV() + delay) & AT91_TC_REG_MASK);
+		local_irq_restore_hw(flags);
+	} else
+		ipipe_trigger_irq(KERNEL_TIMER_IRQ_NUM);
+}
+EXPORT_SYMBOL(__ipipe_mach_set_dec);
+
+void __ipipe_mach_release_timer(void)
+{
+       __ipipe_mach_set_dec(__ipipe_mach_ticks_per_jiffy);
+}
+EXPORT_SYMBOL(__ipipe_mach_release_timer);
+
+unsigned long __ipipe_mach_get_dec(void)
+{
+	return (read_RC() - read_CV()) & AT91_TC_REG_MASK;
+}
+
+static struct irqaction at91rm9200_timer_irq = {
+	.name		= "at91_tick",
+	.flags		= SA_INTERRUPT,
+	.handler	= &at91rm9200_timer_interrupt
+};
+
+void __init at91rm9200_timer_init(void)
+{
+	char clk_name[] = "tc%";
+	unsigned long v;
+	
+	if (clk_get_rate(clk_get(NULL, "mck")) != CONFIG_IPIPE_AT91_MCK)
+		at91rm9200_timer_irq.handler = &at91rm9200_bad_freq;
+
+	snprintf(clk_name, sizeof(clk_name), "tc%d", CONFIG_IPIPE_AT91_TC);
+	clk_enable(clk_get(NULL, clk_name));
+	
+	/* No Sync. */
+	at91_tc_write(AT91_TC_BCR, 0);
+
+	/* program NO signal on XCN */
+	v = readl((void __iomem *) (AT91_VA_BASE_TCB0 + AT91_TC_BMR));
+	v &= ~TCNXCNS(CONFIG_IPIPE_AT91_TC, 3);
+	v |= TCNXCNS(CONFIG_IPIPE_AT91_TC, 1); /* AT91_TC_TCNXCNS_NONE */
+	writel(v, (void __iomem *) (AT91_VA_BASE_TCB0 + AT91_TC_BMR));
+
+	/* Disable the channel */
+	at91_tc_write(AT91_TC_CCR, AT91_TC_CLKDIS);
+
+	/* Select TIMER_CLOCK3 (MCLK/32) as input frequency for TC. */
+	at91_tc_write(AT91_TC_CMR, AT91_TC_TIMER_CLOCK3);
+
+	/* Disable all interrupts. */
+	at91_tc_write(AT91_TC_IDR, ~0ul);
+
+	/* Load the TC register C. */
+	last_jiffy_time = 0;
+	write_RC(LATCH);
+
+	/* Enable CPCS interrupt. */
+	at91_tc_write(AT91_TC_IER, AT91_TC_CPCS);
+
+	/* Set up the interrupt. */
+	setup_irq(KERNEL_TIMER_IRQ_NUM, &at91rm9200_timer_irq);
+
+	/* Enable the channel. */
+	at91_tc_write(AT91_TC_CCR, AT91_TC_CLKEN | AT91_TC_SWTRG);
+
+	at91_timer_initialized = 1;
+}
+
+struct sys_timer at91rm9200_timer = {
+	.init		= at91rm9200_timer_init,
+	.offset		= at91rm9200_gettimeoffset,
+};
+#endif /* CONFIG_IPIPE */
diff -Naurdp -x .gitignore -x '*~' -x '*.orig' -x '*.rej' ipipe-2.6.15-arm-at91/include/asm-arm/arch-at91rm9200/irqs.h ipipe-2.6.15-arm-at91-ipipe_at91/include/asm-arm/arch-at91rm9200/irqs.h
--- ipipe-2.6.15-arm-at91/include/asm-arm/arch-at91rm9200/irqs.h	2007-03-02 01:43:14.000000000 +0100
+++ ipipe-2.6.15-arm-at91-ipipe_at91/include/asm-arm/arch-at91rm9200/irqs.h	2007-03-10 13:01:17.000000000 +0100
@@ -49,4 +49,12 @@
 extern void at91rm9200_init_irq(unsigned int priority[]);
 #endif
 
+#if defined(CONFIG_IPIPE) && !defined(__ASSEMBLY__)
+extern unsigned __ipipe_at91_gpio_banks;
+
+#define __ipipe_mach_irq_mux_p(irq) \
+	((unsigned) (irq - AT91_ID_PIOA) < __ipipe_at91_gpio_banks)
+
+#endif /* CONFIG_IPIPE && !__ASSEMBLY__ */
+
 #endif
diff -Naurdp -x .gitignore -x '*~' -x '*.orig' -x '*.rej' ipipe-2.6.15-arm-at91/include/asm-arm/arch-at91rm9200/timex.h ipipe-2.6.15-arm-at91-ipipe_at91/include/asm-arm/arch-at91rm9200/timex.h
--- ipipe-2.6.15-arm-at91/include/asm-arm/arch-at91rm9200/timex.h	2007-03-02 01:43:14.000000000 +0100
+++ ipipe-2.6.15-arm-at91-ipipe_at91/include/asm-arm/arch-at91rm9200/timex.h	2007-03-10 12:48:10.000000000 +0100
@@ -23,6 +23,10 @@
 
 #include <asm/arch/hardware.h>
 
+#ifndef CONFIG_IPIPE
 #define CLOCK_TICK_RATE		(AT91_SLOW_CLOCK)
+#else /* !CONFIG_IPIPE */
+#define CLOCK_TICK_RATE         (CONFIG_IPIPE_AT91_MCK / 32)
+#endif /* !CONFIG_IPIPE */
 
 #endif
