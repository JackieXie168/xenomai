diff -NaurbB linux-2.6.14_original/arch/arm/boot/compressed/head-csb535.S linux-2.6.14_imx21/arch/arm/boot/compressed/head-csb535.S
--- linux-2.6.14_original/arch/arm/boot/compressed/head-csb535.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/arch/arm/boot/compressed/head-csb535.S	2006-04-11 10:29:12.000000000 +0200
@@ -0,0 +1,31 @@
+/* 
+ * linux/arch/arm/boot/compressed/head-csb535.S
+ * 
+ * Copyright (C) 2005 Jay Monkman <jtm@lopingdog.com>
+ * 
+ * Some code borrowed from Nicolas Pitre's 'head-sa1100.S' file. This
+ * is merged with head.S by the linker.
+ */
+
+#include <linux/config.h>
+#include <asm/mach-types.h>
+
+#ifndef CONFIG_MACH_CSB535
+#error What am I doing here...
+#endif
+
+	.section        ".start", "ax"
+
+__CSB535_start:
+	b	4f
+1:	.word	MACH_TYPE_CSB535  /* Machine type */
+2:	.word   0x10027000        /* PLL regs phys addr */
+3:	.word   0x2e000000        /* Value for PCCR1 - enable GPT clocks */
+
+4:
+	ldr	r1, 2b
+	ldr	r2, 3b
+	str	r2, [r1, #36]    /* Write to PCCR1 */
+
+	ldr	r7, 1b           /* Set machine type */
+
diff -NaurbB linux-2.6.14_original/arch/arm/boot/compressed/head.S linux-2.6.14_imx21/arch/arm/boot/compressed/head.S
--- linux-2.6.14_original/arch/arm/boot/compressed/head.S	2005-10-28 02:02:08.000000000 +0200
+++ linux-2.6.14_imx21/arch/arm/boot/compressed/head.S	2006-04-11 11:07:44.000000000 +0200
@@ -6,6 +6,12 @@
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
+ *
+ * March 2006 :
+ * Adapted to ARM9 i.MX21/CSB535FS board by S.Gerber, G.Boutillier and D.Rossier
+ * University of Applied Sciences Western Switzerland
+ * Reconfigurable & Embedded Digital Systems, REDS Institute
+ *
  */
 #include <linux/config.h>
 #include <linux/linkage.h>
@@ -92,9 +98,9 @@
 		kputc	#'\n'
 		kphex	r5, 8		/* decompressed kernel start */
 		kputc	#'-'
-		kphex	r8, 8		/* decompressed kernel end  */
-		kputc	#'>'
-		kphex	r4, 8		/* kernel execution address */
+
+		kphex	r9, 8		/* decompressed kernel end  */
+		
 		kputc	#'\n'
 #endif
 		.endm
@@ -124,7 +130,11 @@
 		.word	start			@ absolute load/run zImage address
 		.word	_edata			@ zImage end address
 1:		mov	r7, r1			@ save architecture ID
-		mov	r8, #0			@ save r0
+
+		mov	r8, r2			@ save atags pointer
+#if defined (CONFIG_UMON_SHIM)
+		mov	r10, r0			@ save the uMON command line
+#endif
 
 #ifndef __ARM_ARCH_2__
 		/*
@@ -152,11 +162,92 @@
 
 		/*
 		 * some architecture specific code can be inserted
-		 * by the linker here, but it should preserve r7 and r8.
+                 * by the linker here, but it should preserve r7,r8 and r9.
 		 */
 
 		.text
-		adr	r0, LC0
+
+#if defined(CONFIG_UMON_SHIM)
+
+                /* this "shim" builds an ATAG list in a safe memory */
+		/* area from the uMON command line */
+                /* uMON's call (no -a) command points r0
+		/* to the text of the command line */
+		/* TODO: newer uMON's have a "linux call" cmd */
+
+#if defined(CONFIG_MACH_CSB535)
+#warning TODO:	 get rid of this magic number
+		ldr	r2, =0xc0000000	/* put the tags at the bottom of SDRAM */
+#else
+#error	uMON shim is not implemented for this machine.
+#endif
+		mov	r8, r2		/* save the correct atags pointer */
+	
+		ldr	r1, =5
+		stmia	r2!, {r1}
+		ldr	r1, =0x54410001	/* ATAG_CORE */
+		stmia	r2!, {r1}
+
+		ldr	r1, =0		/* flags */
+		stmia	r2!, {r1}
+		ldr	r1, =4096	/* pagesize */
+		stmia	r2!, {r1}
+		ldr	r1, =0		/* rootdev (usually overridden on cmdline) */
+		stmia	r2!, {r1}
+	
+		ldr	r1, =4
+		stmia	r2!, {r1}
+		ldr	r1, =0x54410002	/* ATAG_MEM */
+		stmia	r2!, {r1}
+
+#if defined(CONFIG_MACH_CSB535)
+#warning TODO: get rid of these magic numbers
+		ldr	r1, =0x2000000	/* size */
+		ldr	r3, =0xc000000	/* start */
+#endif
+
+		stmia	r2!, {r1}
+		stmia	r2!, {r3}
+
+		/* save some room for cmdline length */
+		mov	r4, r2
+		add	r2, r2, #4
+	
+		ldr	r1, =0x54410009	/* ATAG_CMDLINE */
+		stmia	r2!, {r1}
+
+		/* copy over the command line */
+		/* (if one wasn't provided, we'll likely crash here) */
+
+1:		ldmia	r10!, {r1}
+		stmia	r2!, {r1}
+		
+		/* look for the null terminator */
+		ands	r5, r1, #0x000000ff
+		beq	1f	
+		ands	r5, r1, #0x0000ff00
+		beq	1f	
+		ands	r5, r1, #0x00ff0000
+		beq	1f	
+		ands	r5, r1, #0xff000000
+		beq	1f
+
+		b	1b
+	
+		/* put the word count into the ATAG_CMDLINE */
+1:		sub	r5, r2, r4
+		mov	r5, r5, lsr #2
+		stmia	r4, {r5}
+
+		/* terminate */
+		ldr	r1, =0 /* ATAG_NONE */
+		stmia	r2!, {r1}
+		stmia	r2!, {r1}
+
+#endif /* CONFIG_UMON_SHIM */
+
+9:		adr	r0, LC0
+
 		ldmia	r0, {r1, r2, r3, r4, r5, r6, ip, sp}
 		subs	r0, r0, r1		@ calculate the delta offset
 
@@ -257,16 +348,19 @@
  * r5     = decompressed kernel start
  * r6     = processor ID
  * r7     = architecture ID
- * r8-r14 = unused
+ * r8     = atags pointer
+ * r9-r14 = corrupted
  */
 		add	r1, r5, r0		@ end of decompressed kernel
 		adr	r2, reloc_start
 		ldr	r3, LC1
 		add	r3, r2, r3
-1:		ldmia	r2!, {r8 - r13}		@ copy relocation code
-		stmia	r1!, {r8 - r13}
-		ldmia	r2!, {r8 - r13}
-		stmia	r1!, {r8 - r13}
+
+1:		ldmia	r2!, {r9 - r14}		@ copy relocation code
+		stmia	r1!, {r9 - r14}
+		ldmia	r2!, {r9 - r14}
+		stmia	r1!, {r9 - r14}
+
 		cmp	r2, r3
 		blo	1b
 
@@ -318,9 +412,9 @@
  *  r7 = architecture number
  *  r8 = run-time address of "start"
  * On exit,
- *  r1, r2, r3, r8, r9, r12 corrupted
+ *  r1, r2, r3, r9, r10, r12 corrupted
  * This routine must preserve:
- *  r4, r5, r6, r7
+ *  r4, r5, r6, r7, r8
  */
 		.align	5
 cache_on:	mov	r3, #8			@ cache_on function
@@ -333,16 +427,30 @@
  * Initialise the page tables, turning on the cacheable and bufferable
  * bits for the RAM area only.
  */
+
 		mov	r0, r3
-		mov	r8, r0, lsr #18
-		mov	r8, r8, lsl #18		@ start of RAM
-		add	r9, r8, #0x10000000	@ a reasonable RAM size
+		mov	r9, r0, lsr #18
+		mov	r9, r9, lsl #18		@ start of RAM
+#if !defined(CONFIG_ARCH_IMX)
+ 		add	r10, r9, #0x10000000	@ a reasonable RAM size
+#else
+		add	r10, r9, #0x08000000	@ Max for imx is 128MB
+#endif
+
+/*
+*Fin modification
+*/
+		
 		mov	r1, #0x12
 		orr	r1, r1, #3 << 10
 		add	r2, r3, #16384
-1:		cmp	r1, r8			@ if virt > start of RAM
+
+1:		cmp	r1, r9			@ if virt > start of RAM
+	
 		orrhs	r1, r1, #0x0c		@ set cacheable, bufferable
-		cmp	r1, r9			@ if virt > end of RAM
+
+		cmp	r1, r10			@ if virt > end of RAM
+
 		bichs	r1, r1, #0x0c		@ clear cacheable, bufferable
 		str	r1, [r0], #4		@ 1:1 mapping
 		add	r1, r1, #1048576
@@ -411,19 +519,25 @@
  * r5     = decompressed kernel start
  * r6     = processor ID
  * r7     = architecture ID
- * r8-r14 = unused
+ * r8     = atags pointer
+ * r9-r14 = corrupted
  */
 		.align	5
-reloc_start:	add	r8, r5, r0
+
+reloc_start:	add	r9, r5, r0
+
 		debug_reloc_start
 		mov	r1, r4
 1:
 		.rept	4
-		ldmia	r5!, {r0, r2, r3, r9 - r13}	@ relocate kernel
-		stmia	r1!, {r0, r2, r3, r9 - r13}
+		
+		ldmia	r5!, {r0, r2, r3, r10 - r14}	@ relocate kernel
+		stmia	r1!, {r0, r2, r3, r10 - r14}
+		
 		.endr
 
-		cmp	r5, r8
+		cmp	r5, r9
+
 		blo	1b
 		debug_reloc_end
 
@@ -431,6 +545,9 @@
 		bl	cache_off
 		mov	r0, #0
 		mov	r1, r7			@ restore architecture number
+
+		mov	r2, r8			@ restore atags pointer
+
 		mov	pc, r4			@ call kernel
 
 /*
diff -NaurbB linux-2.6.14_original/arch/arm/boot/compressed/Makefile linux-2.6.14_imx21/arch/arm/boot/compressed/Makefile
--- linux-2.6.14_original/arch/arm/boot/compressed/Makefile	2005-10-28 02:02:08.000000000 +0200
+++ linux-2.6.14_imx21/arch/arm/boot/compressed/Makefile	2006-04-11 10:57:32.000000000 +0200
@@ -3,6 +3,12 @@
 #
 # create a compressed vmlinuz image from the original vmlinux
 #
+# March 2006 :
+# Adapted to ARM9 i.MX21/CSB535FS board by S.Gerber, G.Boutillier and D.Rossier
+# University of Applied Sciences Western Switzerland
+# Reconfigurable & Embedded Digital Systems, REDS Institute
+#
+#
 
 HEAD	= head.o
 OBJS	= misc.o
@@ -50,6 +56,19 @@
 OBJS		+= head-sharpsl.o
 endif
 
+ifeq ($(CONFIG_ARCH_AT91RM9200),y)
+OBJS		+= head-at91rm9200.o
+endif
+
+ifeq ($(CONFIG_MACH_CSB536),y)
+OBJS		+= head-csb536.o
+endif
+
+# Support for Cogent csb535 board
+ifeq ($(CONFIG_MACH_CSB535),y)
+OBJS		+= head-csb535.o
+endif
+
 ifeq ($(CONFIG_DEBUG_ICEDCC),y)
 OBJS            += ice-dcc.o
 endif
diff -NaurbB linux-2.6.14_original/arch/arm/boot/compressed/misc.c linux-2.6.14_imx21/arch/arm/boot/compressed/misc.c
--- linux-2.6.14_original/arch/arm/boot/compressed/misc.c	2005-10-28 02:02:08.000000000 +0200
+++ linux-2.6.14_imx21/arch/arm/boot/compressed/misc.c	2006-04-11 11:10:05.000000000 +0200
@@ -14,7 +14,13 @@
  *  only.  This way all non constant variables will end up in the bss segment,
  *  which should point to addresses in RAM and cleared to 0 on start.
  *  This allows for a much quicker boot time.
- */
+ *
+ * March 2006 :
+ * Adapted to ARM9 i.MX21/CSB535FS board by S.Gerber, G.Boutillier and D.Rossier
+ * University of Applied Sciences Western Switzerland
+ * Reconfigurable & Embedded Digital Systems, REDS Institute
+ *
+*/
 
 unsigned int __machine_arch_type;
 
@@ -292,6 +298,58 @@
 	while(1);	/* Halt */
 }
 
+#ifdef CONFIG_ARCH_IMX21
+#include <asm/setup.h>
+
+static struct tag *params; /* used to point at the current tag */
+
+static void
+setup_core_tag(void * address,long pagesize)
+{
+    params = (struct tag *)address;         /* Initialise parameters to start at given address */
+
+    params->hdr.tag = ATAG_CORE;            /* start with the core tag */
+    params->hdr.size = tag_size(tag_core); /* size the tag */
+
+    params->u.core.flags = 1;               /* ensure read-only */
+    params->u.core.pagesize = pagesize;     /* systems pagesize (4k) */
+    params->u.core.rootdev = 0;             /* zero root device (typicaly overidden from commandline )*/
+
+    params = tag_next(params);              /* move pointer to next tag */
+}
+
+static void
+setup_mem_tag(unsigned int start, unsigned int len)
+{
+    params->hdr.tag = ATAG_MEM;             /* Memory tag */
+    params->hdr.size = tag_size(tag_mem32);  /* size tag */
+
+    params->u.mem.start = start;            /* Start of memory area (physical address) */
+    params->u.mem.size = len;               /* Length of area */
+
+    params = tag_next(params);              /* move pointer to next tag */
+}
+
+static void
+setup_end_tag(void)
+{
+    params->hdr.tag = ATAG_NONE;            /* Empty tag ends list */
+    params->hdr.size = 0;                   /* zero length */
+}
+
+
+static void
+setup_tags(void)
+{
+    putstr("Creating MX21 tags...");
+    setup_core_tag((int *)0xc0000100, 4096);  /* standard core tag 4k pagesize */
+    setup_mem_tag(0xc0000000, 0x4000000);     /* 64MB @0xc0000000 */
+    setup_end_tag();                          /* end of tags */
+    putstr("Done.\n");
+}
+
+#endif /* CONFIG_ARCH_IMX21 */
+
 #ifndef STANDALONE_DEBUG
 
 ulg
@@ -305,10 +363,22 @@
 
 	arch_decomp_setup();
 
+	putstr("ArchID=");
+	puthex(arch_id);
+	putstr("\n");
+	putstr("output_data: ");
+	puthex((int)output_data);
+	putstr("\n");
+
 	makecrc();
 	putstr("Uncompressing Linux...");
 	gunzip();
-	putstr(" done, booting the kernel.\n");
+	putstr(" done vu Guillaume, booting the kernel.\n");
+
+#if defined(CONFIG_ARCH_IMX21) && !defined(CONFIG_MACH_CSB535)
+	setup_tags();
+#endif /* CONFIG_ARCH_IMX21 */
+	
 	return output_ptr;
 }
 #else
diff -NaurbB linux-2.6.14_original/arch/arm/Kconfig linux-2.6.14_imx21/arch/arm/Kconfig
--- linux-2.6.14_original/arch/arm/Kconfig	2005-10-28 02:02:08.000000000 +0200
+++ linux-2.6.14_imx21/arch/arm/Kconfig	2006-04-11 10:54:38.000000000 +0200
@@ -2,6 +2,11 @@
 # For a description of the syntax of this configuration file,
 # see Documentation/kbuild/kconfig-language.txt.
 #
+# March 2006 :
+# Adapted to ARM9 i.MX21/CSB535FS board by S.Gerber, G.Boutillier and D.Rossier
+# University of Applied Sciences Western Switzerland
+# Reconfigurable & Embedded Digital Systems, REDS Institute
+#
 
 mainmenu "Linux Kernel Configuration"
 
@@ -197,6 +202,9 @@
 config ARCH_IMX
 	bool "IMX"
 
+config FAMILY_IMX21
+	bool "IMX21"
+
 config ARCH_H720X
 	bool "Hynix-HMS720x-based"
 	help
@@ -237,6 +245,8 @@
 
 source "arch/arm/mach-imx/Kconfig"
 
+source "arch/arm/mach-imx21/Kconfig"
+
 source "arch/arm/mach-h720x/Kconfig"
 
 source "arch/arm/mach-versatile/Kconfig"
diff -NaurbB linux-2.6.14_original/arch/arm/kernel/head.S linux-2.6.14_imx21/arch/arm/kernel/head.S
--- linux-2.6.14_original/arch/arm/kernel/head.S	2005-10-28 02:02:08.000000000 +0200
+++ linux-2.6.14_imx21/arch/arm/kernel/head.S	2006-04-11 11:16:59.000000000 +0200
@@ -10,6 +10,12 @@
  * published by the Free Software Foundation.
  *
  *  Kernel startup code for all 32-bit CPUs
+ *
+ * March 2006 :
+ * Adapted to ARM9 i.MX21/CSB535FS board by S.Gerber, G.Boutillier and D.Rossier
+ * University of Applied Sciences Western Switzerland
+ * Reconfigurable & Embedded Digital Systems, REDS Institute
+ *
  */
 #include <linux/config.h>
 #include <linux/linkage.h>
@@ -33,6 +39,10 @@
 #define MACHINFO_PGOFFIO	12
 #define MACHINFO_NAME		16
 
+
+#define ATAG_CORE		0x54410001
+#define ATAG_CORE_SIZE		((2*4 + 3*4) >> 2)
+
 #ifndef CONFIG_XIP_KERNEL
 /*
  * We place the page tables 16K below TEXTADDR.  Therefore, we must make sure
@@ -88,6 +98,7 @@
  * This is normally called from the decompressor code.  The requirements
  * are: MMU = off, D-cache = off, I-cache = dont care, r0 = 0,
  * r1 = machine nr.
+ * r2 = atags pointer
  *
  * This code is mostly position independent, so if you link the kernel at
  * 0xc0008000, you call this at __pa(0xc0008000).
@@ -110,6 +121,9 @@
 	bl	__lookup_machine_type		@ r5=machinfo
 	movs	r8, r5				@ invalid machine (r5=0)?
 	beq	__error_a			@ yes, error 'a'
+	
+	bl	__vet_atags			@ determine validity of r2
+
 	bl	__create_page_tables
 
 	/*
@@ -133,7 +147,10 @@
 	.long	_end				@ r7
 	.long	processor_id			@ r4
 	.long	__machine_arch_type		@ r5
-	.long	cr_alignment			@ r6
+	.long	__atags_pointer			@ r6
+
+	.long	cr_alignment			@ r7	
+
 	.long	init_thread_union + THREAD_START_SP @ sp
 
 /*
@@ -142,12 +159,14 @@
  *
  *  r0  = cp#15 control register
  *  r1  = machine ID
+ *  r2  = atags pointer
  *  r9  = processor ID
  */
 	.type	__mmap_switched, %function
 __mmap_switched:
 	adr	r3, __switch_data + 4
 
+	
 	ldmia	r3!, {r4, r5, r6, r7}
 	cmp	r4, r5				@ Copy data segment if needed
 1:	cmpne	r5, r6
@@ -160,11 +179,17 @@
 	strcc	fp, [r6],#4
 	bcc	1b
 
-	ldmia	r3, {r4, r5, r6, sp}
+	ldmia	r3, {r4, r5, r6, r7, sp}
+	
 	str	r9, [r4]			@ Save processor ID
 	str	r1, [r5]			@ Save machine type
+
+	str	r2, [r6]			@ Save atags pointer
+
 	bic	r4, r0, #CR_A			@ Clear 'A' bit
-	stmia	r6, {r0, r4}			@ Save control register values
+
+	stmia	r7, {r0, r4}			@ Save control register values
+		
 	b	start_kernel
 
 #if defined(CONFIG_SMP)
@@ -262,6 +287,45 @@
 	mov	pc, r13
 
 
+/* Determine validity of the r2 atags pointer.  The heuristic requires
+ * that the pointer be aligned, in the first 16k of physical RAM and
+ * that the ATAG_CORE marker is first and present.  Future revisions
+ * of this function may be more lenient with the physical address and
+ * may also be able to move the ATAGS block if necessary.
+ *
+ * r8  = machinfo
+ *
+ * Returns:
+ *  r2 either valid atags pointer, or zero
+ *  r5, r6 corrupted
+ */
+
+	.type	__vet_atags, %function
+__vet_atags:
+
+	tst	r2, #0x3			@ aligned?
+	bne	1f
+
+	ldr	r5, [r8, #MACHINFO_PHYSRAM]	@ constrain r2 to first 16KiB
+	cmp	r2, r5
+	blo	1f
+	add	r5, r5, #0x4000
+	cmp	r2, r5
+	bhs	1f
+
+	ldr	r5, [r2, #0]			@ is first tag ATAG_CORE?
+	subs	r5, r5, #ATAG_CORE_SIZE
+	bne	1f
+	ldr	r5, [r2, #4]
+	ldr	r6, =ATAG_CORE
+	cmp	r5, r6
+	bne	1f
+
+	mov	pc, lr				@ atag pointer is ok
+
+1:	mov	r2, #0
+	mov	pc, lr
+
 
 /*
  * Setup the initial page tables.  We only setup the barest
diff -NaurbB linux-2.6.14_original/arch/arm/kernel/setup.c linux-2.6.14_imx21/arch/arm/kernel/setup.c
--- linux-2.6.14_original/arch/arm/kernel/setup.c	2005-10-28 02:02:08.000000000 +0200
+++ linux-2.6.14_imx21/arch/arm/kernel/setup.c	2006-04-11 11:13:12.000000000 +0200
@@ -6,6 +6,12 @@
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
+ *
+ * March 2006 :
+ * Adapted to ARM9 i.MX21/CSB535FS board by S.Gerber, G.Boutillier and D.Rossier
+ * University of Applied Sciences Western Switzerland
+ * Reconfigurable & Embedded Digital Systems, REDS Institute
+ *
  */
 #include <linux/config.h>
 #include <linux/module.h>
@@ -66,6 +72,8 @@
 unsigned int __machine_arch_type;
 EXPORT_SYMBOL(__machine_arch_type);
 
+unsigned int __atags_pointer __initdata;
+
 unsigned int system_rev;
 EXPORT_SYMBOL(system_rev);
 
@@ -737,7 +745,12 @@
 	if (mdesc->soft_reboot)
 		reboot_setup("s");
 
-	if (mdesc->boot_params)
+	if (__atags_pointer) {
+	  tags = phys_to_virt (__atags_pointer);
+	  if (ATAG_CORE == tags->hdr.tag)
+	    printk ("ATAGS found at 0x%x\n", __atags_pointer);
+	}
+	else if (mdesc->boot_params)
 		tags = phys_to_virt(mdesc->boot_params);
 
 	/*
diff -NaurbB linux-2.6.14_original/arch/arm/mach-imx21/csb535.c linux-2.6.14_imx21/arch/arm/mach-imx21/csb535.c
--- linux-2.6.14_original/arch/arm/mach-imx21/csb535.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/arch/arm/mach-imx21/csb535.c	2006-04-11 13:24:51.000000000 +0200
@@ -0,0 +1,208 @@
+/*
+ * arch/arm/mach-imx21/csb535.c
+ *
+ * Initially based on:
+ *	linux-2.6.7-imx/arch/arm/ mach-imx /scb9328.c
+ *	Copyright (c) 2004 Sascha Hauer <sascha@saschahauer.de>
+ *
+ * 2004 (c) MontaVista Software, Inc.
+ *
+ * Modified By: Ron Melvin (ron.melvin@timesys.com)
+ * Copyright (c) 2005 TimeSys Corporation 
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ *
+ * March 2006 :
+ * Adapted to ARM9 i.MX21/CSB535FS board by S.Gerber, G.Boutillier and D.Rossier
+ * University of Applied Sciences Western Switzerland
+ * Reconfigurable & Embedded Digital Systems, REDS Institute
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/init.h>
+#include <asm/system.h>
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+
+#include <asm/mach/map.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <linux/interrupt.h>
+#include "generic.h"
+#include <asm/serial.h>
+#include <asm/arch/imx21fb.h>
+
+#if defined(CONFIG_CIRRUS)
+static struct resource cs8900_resources[] = {
+    [0] = {
+        .start  = CSB535_ETH_PHYS,
+        .end    = CSB535_ETH_PHYS + CSB535_ETH_SIZE - 1,
+        .flags  = IORESOURCE_MEM,
+    },
+    [1] = {
+        .start  = CSB535_ETH_IRQ,
+        .end    = CSB535_ETH_IRQ,
+        .flags  = IORESOURCE_IRQ,
+    },
+};
+
+static struct platform_device cs8900_device = {
+    .name            = "cs8900",
+    .id              = 0,
+    .num_resources   = ARRAY_SIZE(cs8900_resources),
+    .resource        = cs8900_resources,
+};
+#endif /* defined(CONFIG_CIRRUS) */
+
+/* TODO, figure out correct IRQ */
+static struct resource cpuvers_resources[] = {
+	[0] = {
+		.start	= IMX21_CS1_VIRT+0x400000,
+		.end	= IMX21_CS1_VIRT+0x400000 + 2,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+	    .start	= 0,
+		.end	= 0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device cpuvers_device = {
+	.name		= "imx21-cpuvers",
+	.num_resources	= ARRAY_SIZE(cpuvers_resources),
+	.resource	= cpuvers_resources,
+};
+
+/* TODO, figure out correct IRQ */
+static struct resource mx21cfg_resources[] = {
+	[0] = {
+		.start	= IMX21_CS1_VIRT+0x800000,
+		.end	= IMX21_CS1_VIRT+0x800000 + 2,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+	    .start	= 0,
+		.end	= 0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mx21cfg_device = {
+	.name		= "imx21-mx21cfg",
+	.num_resources	= ARRAY_SIZE(mx21cfg_resources),
+	.resource	= mx21cfg_resources,
+};
+
+static struct platform_device *devices[] __initdata = {
+#if defined(CONFIG_CIRRUS)
+	&cs8900_device,
+#endif
+	&cpuvers_device,
+	&mx21cfg_device,
+};
+
+static void __init
+fixup_mx21(struct machine_desc *desc, struct tag *tags,
+	   char **cmdline, struct meminfo *mi)
+
+{
+}
+
+static void csb535_lcd_power(int on)
+{
+	if(on)
+		MMIO_REG |= MMIO_LCDON;
+	else
+		MMIO_REG &= ~MMIO_LCDON;
+}
+
+// #define EXPERIMENTAL
+#ifdef EXPERIMENTAL
+
+/* LCD settings for Microtips MTG-F24160BFWNSEB-01 */
+static struct imxfb_mach_info csb535_fb_info __initdata = {
+	.pixclock	= 0, 		.bpp		= 1,
+	.xres		= 240,		.yres		= 160,
+
+	.hsync_len	= 0,		.vsync_len	= 0,
+	.left_margin	= 0,		.upper_margin	= 0,
+	.right_margin	= 0,		.lower_margin	= 0,
+
+	.lpcr	= LPCR_PBSIZ(LPCR_PBSIZ_PANEL_BUS_WIDTH_4) | LPCR_BPIX(LPCR_BPIX_BITS_PER_PIXEL_1) | PCR_SCLKSEL | PCR_PCD(7),
+	.lpccr	= 0,
+	.lscr	= 0, 
+
+	.lcd_power = csb535_lcd_power,
+};
+#else
+
+/* LCD settings for Sharp LCD LQ035Q7DB02 */
+static struct imxfb_mach_info csb535_fb_info __initdata = {
+	.pixclock	= 0, 		.bpp		= 16,
+	.xres		= 240,		.yres		= 320,
+
+	.hsync_len	= 1,		.vsync_len	= 1,
+	.left_margin	= 15,		.upper_margin	= 9,
+	.right_margin	= 6,		.lower_margin	= 7,
+
+	.lpcr	= LPCR_TFT | LPCR_COLOR | LPCR_PBSIZ(LPCR_PBSIZ_PANEL_BUS_WIDTH_8) | LPCR_BPIX(LPCR_BPIX_BITS_PER_PIXEL_16) | LPCR_PIXPOL | LPCR_OEPOL | LPCR_SCLKSEL | LPCR_SHARP | LPCR_PCD(3),
+	.lpccr	= LPCCR_CLS_HI_WIDTH(169) | LPCCR_SCR(LPCCR_SCR_PIXEL_CLOCK) | LPCCR_CC_EN | LPCCR_PW(0xff),
+	.lscr	= LSCR_PS_RISE_DELAY(0) | LSCR_CLS_RISE_DELAY(18) | LSCR_REV_TOGGLE_DELAY(3) | LSCR_GRAY2(0) | LSCR_GRAY1(0), 
+
+	.lcd_power = csb535_lcd_power,
+
+
+};
+#endif
+
+static void __init
+csb535_init(void)
+{
+	/* Configure the system clocks */
+	imx21_system_clk_init();	
+	
+	/* Set LCD display platform_data information*/
+	set_imx_fb_info(&csb535_fb_info);
+		
+	/* Enable the LCD display */
+	csb535_lcd_power(1);
+
+#if defined(CONFIG_CIRRUS)
+        imx21_gpio_mode(GPIO_PORTD | 31 | GPIO_IN);
+#endif
+	
+	platform_add_devices(devices, ARRAY_SIZE(devices));
+}
+
+static struct map_desc csb535_io_desc[] __initdata = {
+	/* virtual     physical    length      type */
+	{IMX21_CS0_VIRT, IMX21_CS0_PHYS, IMX21_CS0_SIZE, MT_DEVICE},
+	{IMX21_CS1_VIRT, IMX21_CS1_PHYS, IMX21_CS1_SIZE, MT_DEVICE},
+};
+
+static void __init
+csb535_map_io(void)
+{
+	imx21_map_io();
+	iotable_init(csb535_io_desc, ARRAY_SIZE(csb535_io_desc));
+}
+
+MACHINE_START(CSB535, "Cogent CSB535")
+	/* Maintainer: Jay Monkman <jtm@lopingdog.com> */
+	.phys_ram	= 0xc0000000,
+	.phys_io	= 0xc8000000,
+	.io_pg_offst	= ((0xe0200000) >> 18) & 0xfffc,
+	.boot_params	= 0xc0000100,
+	.fixup          = fixup_mx21,
+	.map_io		= csb535_map_io,
+	.init_irq	= imx21_init_irq,
+	.timer		= &imx21_timer,
+	.init_machine	= csb535_init,
+MACHINE_END
diff -NaurbB linux-2.6.14_original/arch/arm/mach-imx21/dma.c linux-2.6.14_imx21/arch/arm/mach-imx21/dma.c
--- linux-2.6.14_original/arch/arm/mach-imx21/dma.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/arch/arm/mach-imx21/dma.c	2006-04-11 10:29:12.000000000 +0200
@@ -0,0 +1,218 @@
+/*
+ *  linux/arch/arm/mach-imx21/dma.c
+ *
+ *  imx DMA registration and IRQ dispatching
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  03/03/2004 Sascha Hauer <sascha@saschahauer.de>
+ *             initial version heavily inspired by
+ *             linux/arch/arm/mach-pxa/dma.c
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+
+#include <asm/system.h>
+#include <asm/irq.h>
+#include <asm/hardware.h>
+#include <asm/dma.h>
+
+static struct dma_channel {
+	char *name;
+	void (*irq_handler) (int, void *, struct pt_regs *);
+	void (*err_handler) (int, void *, struct pt_regs *);
+	void *data;
+} dma_channels[11];
+
+/* set err_handler to NULL to have the standard info-only error handler */
+int
+imx_request_dma(char *name, imx_dma_prio prio,
+		void (*irq_handler) (int, void *, struct pt_regs *),
+		void (*err_handler) (int, void *, struct pt_regs *), void *data)
+{
+#if 0
+    unsigned long flags;
+	int i, found = 0;
+
+	/* basic sanity checks */
+	if (!name || !irq_handler)
+		return -EINVAL;
+
+	local_irq_save(flags);
+
+	/* try grabbing a DMA channel with the requested priority */
+	for (i = prio; i < prio + (prio == DMA_PRIO_LOW) ? 8 : 4; i++) {
+		if (!dma_channels[i].name) {
+			found = 1;
+			break;
+		}
+	}
+
+	if (!found) {
+		/* requested prio group is full, try hier priorities */
+		for (i = prio - 1; i >= 0; i--) {
+			if (!dma_channels[i].name) {
+				found = 1;
+				break;
+			}
+		}
+	}
+
+	if (found) {
+		DIMR &= ~(1 << i);
+		dma_channels[i].name = name;
+		dma_channels[i].irq_handler = irq_handler;
+		dma_channels[i].err_handler = err_handler;
+		dma_channels[i].data = data;
+	} else {
+		printk(KERN_WARNING "No more available DMA channels for %s\n",
+		       name);
+		i = -ENODEV;
+	}
+
+	local_irq_restore(flags);
+	return i;
+#else
+	return 0;
+	
+#endif
+}
+
+void
+imx_free_dma(int dma_ch)
+{
+#if 0
+        unsigned long flags;
+
+	if (!dma_channels[dma_ch].name) {
+		printk(KERN_CRIT
+		       "%s: trying to free channel %d which is already freed\n",
+		       __FUNCTION__, dma_ch);
+		return;
+	}
+
+	local_irq_save(flags);
+	DIMR &= ~(1 << dma_ch);
+	dma_channels[dma_ch].name = NULL;
+	local_irq_restore(flags);
+#endif
+}
+
+static irqreturn_t
+dma_err_handler(int irq, void *dev_id, struct pt_regs *regs)
+{
+#if 0
+	int i;
+	struct dma_channel *channel;
+	unsigned int err_mask = DBTOSR | DRTOSR | DSESR | DBOSR;
+
+	for (i = 0; i < 11; i++) {
+		channel = &dma_channels[i];
+
+		if ( (err_mask & 1<<i) && channel->name && channel->err_handler) {
+			channel->err_handler(i, channel->data, regs);
+			continue;
+		}
+
+		if (DBTOSR & (1 << i)) {
+			printk(KERN_WARNING
+			       "Burst timeout on channel %d (%s)\n",
+			       i, channel->name);
+			DBTOSR |= (1 << i);
+		}
+		if (DRTOSR & (1 << i)) {
+			printk(KERN_WARNING
+			       "Request timeout on channel %d (%s)\n",
+			       i, channel->name);
+			DRTOSR |= (1 << i);
+		}
+		if (DSESR & (1 << i)) {
+			printk(KERN_WARNING
+			       "Transfer timeout on channel %d (%s)\n",
+			       i, channel->name);
+			DSESR |= (1 << i);
+		}
+		if (DBOSR & (1 << i)) {
+			printk(KERN_WARNING
+			       "Buffer overflow timeout on channel %d (%s)\n",
+			       i, channel->name);
+			DBOSR |= (1 << i);
+		}
+		DISR = (1 << i);
+	}
+#endif	
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t
+dma_irq_handler(int irq, void *dev_id, struct pt_regs *regs)
+{
+#if 0
+	int i, disr = DISR;
+
+	for (i = 0; i < 11; i++) {
+		if (disr & (1 << i)) {
+			struct dma_channel *channel = &dma_channels[i];
+			if (channel->name && channel->irq_handler) {
+				channel->irq_handler(i, channel->data, regs);
+			} else {
+				/*
+				 * IRQ for an unregistered DMA channel:
+				 * let's clear the interrupts and disable it.
+				 */
+				printk(KERN_WARNING
+				       "spurious IRQ for DMA channel %d\n", i);
+			}
+		}
+	}
+	DISR = disr;
+#endif
+	return IRQ_HANDLED;
+}
+
+static int __init
+imx_dma_init(void)
+{
+#if 0
+	int ret;
+
+	/* reset DMA module */
+	DCR = DCR_DRST;
+
+	ret = request_irq(DMA_INT, dma_irq_handler, 0, "DMA", NULL);
+	if (ret) {
+		printk(KERN_CRIT "Wow!  Can't register IRQ for DMA\n");
+		return ret;
+	}
+
+	ret = request_irq(DMA_ERR, dma_err_handler, 0, "DMA", NULL);
+	if (ret) {
+		printk(KERN_CRIT "Wow!  Can't register ERRIRQ for DMA\n");
+		free_irq(DMA_INT, NULL);
+	}
+
+	/* enable DMA module */
+	DCR = DCR_DEN;
+
+	/* clear all interrupts */
+	DISR = 0x3ff;
+
+	/* enable interrupts */
+	DIMR = 0;
+
+	return ret;
+#else
+	return 0;
+#endif
+}
+
+arch_initcall(imx_dma_init);
+
+EXPORT_SYMBOL(imx_request_dma);
+EXPORT_SYMBOL(imx_free_dma);
diff -NaurbB linux-2.6.14_original/arch/arm/mach-imx21/generic.c linux-2.6.14_imx21/arch/arm/mach-imx21/generic.c
--- linux-2.6.14_original/arch/arm/mach-imx21/generic.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/arch/arm/mach-imx21/generic.c	2006-04-11 10:29:12.000000000 +0200
@@ -0,0 +1,459 @@
+/*
+ *  arch/arm/mach-imx21/generic.c
+ *
+ *  author: Sascha Hauer
+ *  Created: april 20th, 2004
+ *  Copyright: Synertronixx GmbH
+ *
+ * Modified By: Ron Melvin (ron.melvin@timesys.com)
+ * Copyright (C) 2005 TimeSys Corporation 
+ *
+ * Modified By: Stephen Donecker (sdonecker@sbcglobal.net)
+ *
+ * Common code for i.MX machines
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <asm/hardware.h>
+
+#include <asm/mach/map.h>
+
+#include <asm-arm/arch-imx21/imx21fb.h>
+
+/* List current CRM register contents */
+#define DEBUG_CRM 1
+
+void imx21_gpio_mode(int gpio_mode);
+void imx_set_enet_irq(void);
+void imx_clear_enet_irq(void);
+void imx21_system_clk_init(void);
+
+void imx21_gpio_mode(int gpio_mode)
+{
+	unsigned int pin = gpio_mode & GPIO_PIN_MASK;
+	unsigned int port = (gpio_mode & GPIO_PORT_MASK) >> GPIO_PORT_POS;
+	unsigned int ocr = (gpio_mode & GPIO_OCR_MASK) >> GPIO_OCR_POS;
+	unsigned int tmp;
+
+	/* Pullup enable */
+	if(gpio_mode & GPIO_PU_MASK)
+		PUEN(port) |= (1<<pin);
+	else
+		PUEN(port) &= ~(1<<pin);
+
+	/* Data direction */
+	if(gpio_mode & GPIO_DIR_MASK)
+		DDIR(port) |= (1<<pin);
+	else
+		DDIR(port) &= ~(1<<pin);
+
+	/* Primary function, alternate function, or GPIO */
+        switch(gpio_mode & GPIO_FUNC_MASK)
+	{
+		case GPIO_PF:
+			GIUS(port) &= ~(1<<pin);
+			GPR(port) &= ~(1<<pin);
+			break;
+		case GPIO_AF:
+			GIUS(port) &= ~(1<<pin);
+			GPR(port) |= (1<<pin);
+			break;
+		case GPIO_GP:
+			GIUS(port) |= (1<<pin);
+			/* GPR register: don't care when GIUS set to GPIO */
+			break;
+		default:
+			GIUS(port) &= ~(1<<pin);
+			GPR(port) &= ~(1<<pin);
+	}
+	
+	if(pin<16) {
+		tmp = OCR1(port);
+		tmp &= ~( 3<<(pin*2));
+		tmp |= (ocr << (pin*2));
+		OCR1(port) = tmp;
+
+		if( gpio_mode &	GPIO_AOUT )
+			ICONFA1(port) &= ~( 3<<(pin*2));
+		if( gpio_mode &	GPIO_BOUT )
+			ICONFB1(port) &= ~( 3<<(pin*2));
+	} else {
+		tmp = OCR2(port);
+		tmp &= ~( 3<<((pin-16)*2));
+		tmp |= (ocr << ((pin-16)*2));
+		OCR2(port) = tmp;
+
+		if( gpio_mode &	GPIO_AOUT )
+			ICONFA2(port) &= ~( 3<<((pin-16)*2));
+		if( gpio_mode &	GPIO_BOUT )
+			ICONFB2(port) &= ~( 3<<((pin-16)*2));
+	}
+}
+EXPORT_SYMBOL(imx21_gpio_mode);
+
+void imx_set_enet_irq()
+{
+    IMR(GPIO_E) |= NET_IRQ_BIT;
+    DDIR(GPIO_E) &= ~NET_IRQ_BIT;
+}
+
+void imx_clr_enet_irq()
+{
+    ISR(GPIO_E) = NET_IRQ_BIT;
+}
+
+EXPORT_SYMBOL(imx_clr_enet_irq);
+
+void imx21_system_clk_init()
+{
+	/*
+	 * System clock initialization
+	 *
+	 * The following register settings are similar to the ones currently
+	 * configured in the Freescale distributions of Redboot and Grub. 
+	 * All common clock settings should go here and specific settings should
+	 * go in their respective drivers. 
+	 */
+	
+	printk("Initializing system clocks\n");
+#if 1 
+	/* Enable the frequency premultiplier (FPM) to multiply by 512 */
+	CRM_CSCR |= CSCR_FPM_EN;
+	
+	/* Select the FPM output as the input to the MPLL and the SPLL */
+	CRM_CSCR &= ~(CSCR_MCU_SEL | CSCR_SP_SEL);
+	
+	/* Enable the MPLL and the SPLL */
+	CRM_CSCR |= (CSCR_MPEN | CSCR_SPEN);
+
+	/*
+	 * Set the MPLL so the output frequency is 266MHz by setting 
+	 * PD=0, MFD=123, MFI=7, and MFN=115 when fref=32.768kHz
+	 */
+#warning "Changed by JTM"
+//	CRM_MPCTL0 = (MPCTL0_PD(0) | MPCTL0_MFD(123) | MPCTL0_MFI(7) | MPCTL0_MFN(115));
+
+	/* Set the prescaler (PRESC) to divide by 1 */
+	CRM_CSCR &= ~CSCR_PRESC_MASK;
+	CRM_CSCR |= CSCR_PRESC(0);	
+
+	/* Enable the peripheral clock divider (IPDIV) to divide by 2 */
+	CRM_CSCR |= CSCR_IPDIV; 
+
+	/* Set the system bus clock divider (BCLKDIV) to divide by 2 */
+//	CRM_CSCR &= ~CSCR_BCLKDIV_MASK;
+	CRM_CSCR |= CSCR_BCLKDIV(1);
+
+#warning "Changed by JTM"
+	/* Set the peripheral clock divider 1 (PERDIV1) to divide by 6 */
+//	CRM_PCDR1 &= ~PCDR1_PERDIV1_MASK;
+//	CRM_PCDR1 |= PCDR1_PERDIV1(5); 
+
+	/* Enable HCLK input to the BROM module */
+	CRM_PCCR0 |= PCCR0_HCLK_BROM_EN;
+
+	/* Restart the MPLL and wait for the CSCR_MPLL_RESTART bit to clear */
+	CRM_CSCR |= CSCR_MPLL_RESTART;
+	while (CRM_CSCR & CSCR_MPLL_RESTART)
+	    ;
+	
+	/* 
+	 * Set the SPLL so the output frequency is 288MHz by setting
+	 * PD=0, MFD=626, MFI=8, and MFN=365 when fref=32.768kHz
+	 */
+	CRM_SPCTL0 = (SPCTL0_PD(0) | SPCTL0_MFD(626) | SPCTL0_MFI(8) | SPCTL0_MFN(365)); 
+	
+	/* Restart the SPLL and wait for the CSCR_SPLL_RESTART bit to clear */
+	CRM_CSCR |= CSCR_SPLL_RESTART;
+	while (CRM_CSCR & CSCR_SPLL_RESTART)
+	    ;
+	
+	/* Set the peripheral clock divider 3 (PERDIV3) to divide by 6 */
+	CRM_PCDR1 &= ~PCDR1_PERDIV3_MASK;
+	CRM_PCDR1 |= PCDR1_PERDIV3(5);
+#endif
+#if DEBUG_CRM
+	/* Let's take a look at the current CRM register settings */
+	printk("CRM_CSCR: 0x%08x\n",CRM_CSCR);
+	printk("CRM_MPCTL0: 0x%08x\n",CRM_MPCTL0);
+	printk("CRM_MPCTL1: 0x%08x\n",CRM_MPCTL1);
+	printk("CRM_SPCTL0: 0x%08x\n",CRM_SPCTL0);
+	printk("CRM_SPCTL1: 0x%08x\n",CRM_SPCTL1);
+	printk("CRM_OSC26MCTL: 0x%08x\n",CRM_OSC26MCTL);
+	printk("CRM_PCDR0: 0x%08x\n",CRM_PCDR0);
+	printk("CRM_PCDR1: 0x%08x\n",CRM_PCDR1);
+	printk("CRM_PCCR0: 0x%08x\n",CRM_PCCR0);
+	printk("CRM_PCCR1: 0x%08x\n",CRM_PCCR1);
+	printk("CRM_CCSR: 0x%08x\n",CRM_CCSR);
+	printk("CRM_WKGDCTL: 0x%08x\n",CRM_WKGDCTL);
+#endif
+	
+}
+
+/*
+ *  get the system pll clock in Hz
+ *
+ *                  mfi + mfn / (mfd +1)
+ *  f = 2 * f_ref * --------------------
+ *                        pd + 1
+ */
+
+/* TODO: Remove hardcoded values and write routines to retrieve all clk info. */
+static unsigned int imx_decode_pll(unsigned int pll)
+{
+	u32 mfi = (pll >> 10) & 0xf;
+	u32 mfn = pll & 0x3ff;
+	u32 mfd = (pll >> 16) & 0x3ff;
+	u32 pd =  (pll >> 26) & 0xf;
+	u32 f_ref = (CRM_CSCR & CSCR_MCU_SEL) ? 26000000 : (CLK32 * 512);
+
+	mfi = mfi <= 5 ? 5 : mfi;
+
+	return (2 * (f_ref>>10) * ( (mfi<<10) + (mfn<<10) / (mfd+1) )) / (pd+1);
+}
+
+unsigned int imx_get_system_clk(void)
+{
+	return imx_decode_pll(CRM_SPCTL0);
+}
+EXPORT_SYMBOL(imx_get_system_clk);
+
+unsigned int imx_get_mcu_clk(void)
+{
+	return imx_decode_pll(CRM_MPCTL0);
+}
+EXPORT_SYMBOL(imx_get_mcu_clk);
+
+/*
+ *  get peripheral clock 1 ( UART[12], Timer[12], PWM )
+ */
+unsigned int imx_get_perclk1(void)
+{
+	return imx_get_system_clk() / (((CRM_PCDR1 & PCDR1_PERDIV1_MASK) >> PCDR1_PERDIV1_POS)+1);
+}
+EXPORT_SYMBOL(imx_get_perclk1);
+
+/*
+ *  get peripheral clock 2 ( SDHC, CSPI )
+ */
+unsigned int imx_get_perclk2(void)
+{
+	return imx_get_system_clk() / (((CRM_PCDR1 & PCDR1_PERDIV2_MASK) >> PCDR1_PERDIV2_POS)+1);
+}
+EXPORT_SYMBOL(imx_get_perclk2);
+
+/*
+ *  get peripheral clock 3 ( LCDC )
+ */
+unsigned int imx_get_perclk3(void)
+{
+	return imx_get_system_clk() / (((CRM_PCDR1 & PCDR1_PERDIV3_MASK) >> PCDR1_PERDIV3_POS)+1);
+}
+EXPORT_SYMBOL(imx_get_perclk3);
+
+/*
+ *  get peripheral clock 4 (CSI)
+ */
+unsigned int imx_get_perclk4(void)
+{
+	return imx_get_system_clk() / (((CRM_PCDR1 & PCDR1_PERDIV4_MASK) >> PCDR1_PERDIV4_POS)+1);
+}
+
+EXPORT_SYMBOL(imx_get_perclk4);
+
+/*
+ *  get hclk ( SDRAM, CSI, Memory Stick, I2C, DMA )
+ */
+#if 0
+unsigned int imx_get_hclk(void)
+{
+	return imx_get_system_clk() / (((CSCR>>10) & 0xf)+1);
+}
+EXPORT_SYMBOL(imx_get_hclk);
+
+#endif
+
+#if 0
+static struct resource imx_mmc_resources[] = {
+	[0] = {
+		.start	= 0x10013000,
+		.end	= 0x100130FF,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= (SDHC_INT),
+		.end	= (SDHC_INT),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device imx_mmc_device = {
+	.name		= "imx-mmc",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(imx_mmc_resources),
+	.resource	= imx_mmc_resources,
+};
+
+#endif
+
+static struct resource imx21_uart1_resources[] = {
+	[0] = {
+		.start	= 0x1000A000,
+		.end	= 0x1000A0FF,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= (INT_UART1),
+		.end	= (INT_UART1),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device imx21_uart1_device = {
+	.name		= "imx21-uart",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(imx21_uart1_resources),
+	.resource	= imx21_uart1_resources,
+};
+
+static struct resource imx21_uart2_resources[] = {
+	[0] = {
+		.start	= 0x1000B000,
+		.end	= 0x1000B0FF,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= (INT_UART2),
+		.end	= (INT_UART2),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device imx21_uart2_device = {
+	.name		= "imx21-uart",
+	.id		= 1,
+	.num_resources	= ARRAY_SIZE(imx21_uart2_resources),
+	.resource	= imx21_uart2_resources,
+};
+
+
+static struct resource imx21_uart3_resources[] = {
+	[0] = {
+		.start	= 0x1000C000,
+		.end	= 0x1000C0FF,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= (INT_UART3),
+		.end	= (INT_UART3),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device imx21_uart3_device = {
+	.name		= "imx21-uart",
+	.id		= 2,
+	.num_resources	= ARRAY_SIZE(imx21_uart3_resources),
+	.resource	= imx21_uart3_resources,
+};
+
+static struct resource imx21_uart4_resources[] = {
+	[0] = {
+		.start	= 0x1000a000,
+		.end	= 0x1000a0FF,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= (INT_UART4),
+		.end	= (INT_UART4),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device imx21_uart4_device = {
+	.name		= "imx21-uart",
+	.id		= 3,
+	.num_resources	= ARRAY_SIZE(imx21_uart4_resources),
+	.resource	= imx21_uart4_resources,
+};
+
+static struct imxfb_mach_info imx_fb_info;
+
+void __init set_imx_fb_info(struct imxfb_mach_info *hard_imx_fb_info)
+{
+	memcpy(&imx_fb_info,hard_imx_fb_info,sizeof(struct imxfb_mach_info));
+}
+EXPORT_SYMBOL(set_imx_fb_info);
+
+static struct resource imxfb_resources[] = {
+	[0] = {
+		.start	= 0x10021000,
+		.end	= 0x100210ff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= INT_LCDC,
+		.end	= INT_LCDC,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static u64 fb_dma_mask = ~(u64)0;
+
+static struct platform_device imxfb_device = {
+	.name		= "imx-fb",
+	.id		= 0,
+	.dev		= {
+ 		.platform_data	= &imx_fb_info,
+		.dma_mask	= &fb_dma_mask,
+		.coherent_dma_mask = 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(imxfb_resources),
+	.resource	= imxfb_resources,
+};
+
+static struct platform_device *devices[] __initdata = {
+    /* 	&imx_mmc_device, */
+	&imxfb_device,
+	&imx21_uart1_device,
+	&imx21_uart2_device,
+	// add these later
+	//	&imx21_uart3_device,
+	//	&imx21_uart4_device,
+};
+
+static struct map_desc imx21_io_desc[] __initdata = {
+	/* virtual     physical    length      type */
+    {IMX21_IO_BASE, IMX21_IO_PHYS, IMX21_IO_SIZE, MT_DEVICE},
+    //    {IMX21_EMI_VIRT, IMX21_EMI_PHYS, IMX21_EMI_SIZE, MT_DEVICE},
+};
+
+void __init
+imx21_map_io(void)
+{
+	iotable_init(imx21_io_desc, ARRAY_SIZE(imx21_io_desc));
+}
+
+static int __init imx21_init(void)
+{
+    return platform_add_devices(devices, ARRAY_SIZE(devices));
+}
+
+subsys_initcall(imx21_init);
diff -NaurbB linux-2.6.14_original/arch/arm/mach-imx21/generic.h linux-2.6.14_imx21/arch/arm/mach-imx21/generic.h
--- linux-2.6.14_original/arch/arm/mach-imx21/generic.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/arch/arm/mach-imx21/generic.h	2006-04-11 10:29:12.000000000 +0200
@@ -0,0 +1,19 @@
+/*
+ *  linux/arch/arm/mach-imx21/generic.h
+ *
+ * Author:	Sascha Hauer <sascha@saschahauer.de>
+ * Copyright:	Synertronixx GmbH
+ *
+ * Modified By: Ron Melvin (ron.melvin@timesys.com)
+ * Copyright (C) 2005 TimeSys Corporation 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+extern void __init imx21_map_io(void);
+extern void __init imx21_init_irq(void);
+
+struct sys_timer;
+extern struct sys_timer imx21_timer;
diff -NaurbB linux-2.6.14_original/arch/arm/mach-imx21/irq.c linux-2.6.14_imx21/arch/arm/mach-imx21/irq.c
--- linux-2.6.14_original/arch/arm/mach-imx21/irq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/arch/arm/mach-imx21/irq.c	2006-04-11 10:29:12.000000000 +0200
@@ -0,0 +1,228 @@
+/*
+ *  linux/arch/arm/mach-imx21/irq.c
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *  Copyright (C) 2002 Shane Nay (shane@minirl.com)
+ *  Modified By: Ron Melvin (ron.melvin@timesys.com)
+ *  Copyright (C) 2005, TimeSys Corporation 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *  03/03/2004   Sascha Hauer <sascha@saschahauer.de>
+ *               Copied from the motorola bsp package and added gpio demux
+ *               interrupt handler
+  */
+#include <linux/init.h>
+extern int x1;
+#include <linux/list.h>
+extern int x2;
+#include <linux/timer.h>
+extern int x3;
+
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+
+#include <asm/mach/irq.h>
+
+/*
+ *
+ * We simply use the ENABLE DISABLE registers inside of the IMX21
+ * to turn on/off specific interrupts.  FIXME- We should
+ * also add support for the accelerated interrupt controller
+ * by putting offets to irq jump code in the appropriate
+ * places.
+ *
+ */
+
+#define INTENNUM_OFF              0x8
+#define INTDISNUM_OFF             0xC
+
+#define VA_AITC_BASE              IO_ADDRESS(MX2ADS_AITC_BASE)
+#define IMX21_AITC_INTDISNUM       (VA_AITC_BASE + INTDISNUM_OFF)
+#define IMX21_AITC_INTENNUM        (VA_AITC_BASE + INTENNUM_OFF)
+
+#if 0
+#define DEBUG_IRQ(fmt...)	printk(fmt)
+#else
+#define DEBUG_IRQ(fmt...)	do { } while (0)
+#endif
+
+static void
+imx21_mask_irq(unsigned int irq)
+{
+	__raw_writel(irq, IMX21_AITC_INTDISNUM);
+}
+
+static void
+imx21_unmask_irq(unsigned int irq)
+{
+	__raw_writel(irq, IMX21_AITC_INTENNUM);
+}
+
+static int
+imx21_gpio_irq_type(unsigned int _irq, unsigned int type)
+{
+	unsigned int irq_type = 0, irq, reg, bit;
+
+	irq = _irq - IRQ_GPIOA(0);
+	reg = irq >> 5;
+	bit = 1 << (irq % 32);
+
+	if (type == IRQT_PROBE) {
+		/* Don't mess with enabled GPIOs using preconfigured edges or
+		   GPIOs set to alternate function during probe */
+		/* TODO: support probe */
+//              if ((GPIO_IRQ_rising_edge[idx] | GPIO_IRQ_falling_edge[idx]) &
+//                  GPIO_bit(gpio))
+//                      return 0;
+//              if (GAFR(gpio) & (0x3 << (((gpio) & 0xf)*2)))
+//                      return 0;
+//              type = __IRQT_RISEDGE | __IRQT_FALEDGE;
+	}
+
+	GIUS(reg) |= bit;
+	DDIR(reg) &= ~(bit);
+
+	DEBUG_IRQ("setting type of irq %d to ", _irq);
+
+	if (type & __IRQT_RISEDGE) {
+		DEBUG_IRQ("rising edges\n");
+		irq_type = 0x0;
+	}
+	if (type & __IRQT_FALEDGE) {
+		DEBUG_IRQ("falling edges\n");
+		irq_type = 0x1;
+	}
+	if (type & __IRQT_LOWLVL) {
+		DEBUG_IRQ("low level\n");
+		irq_type = 0x3;
+	}
+	if (type & __IRQT_HIGHLVL) {
+		DEBUG_IRQ("high level\n");
+		irq_type = 0x2;
+	}
+
+	if (irq % 32 < 16) {
+		ICR1(reg) = (ICR1(reg) & ~(0x3 << ((irq % 16) * 2))) |
+		    (irq_type << ((irq % 16) * 2));
+	} else {
+		ICR2(reg) = (ICR2(reg) & ~(0x3 << ((irq % 16) * 2))) |
+		    (irq_type << ((irq % 16) * 2));
+	}
+
+	return 0;
+
+}
+
+static void
+imx21_gpio_ack_irq(unsigned int irq)
+{
+	DEBUG_IRQ("%s: irq %d  isr %d\n", __FUNCTION__, irq,
+                  IRQ_TO_REG(irq));
+	ISR(IRQ_TO_REG(irq)) |= 1 << ((irq - IRQ_GPIOA(0)) % 32);
+}
+
+static void
+imx21_gpio_mask_irq(unsigned int irq)
+{
+	DEBUG_IRQ("%s: irq %d\n", __FUNCTION__, irq);
+	IMR(IRQ_TO_REG(irq)) &= ~( 1 << ((irq - IRQ_GPIOA(0)) % 32));
+}
+
+static void
+imx21_gpio_unmask_irq(unsigned int irq)
+{
+	DEBUG_IRQ("%s: irq %d\n", __FUNCTION__, irq);
+	IMR(IRQ_TO_REG(irq)) |= 1 << ((irq - IRQ_GPIOA(0)) % 32);
+        PMASK = PMASK | (1 << IRQ_TO_REG(irq));
+}
+
+static void
+imx21_gpio_handler(unsigned int irq_unused, struct irqdesc *desc,
+                   struct pt_regs *regs)
+{
+    unsigned int mask;
+    unsigned int port;
+    unsigned int irq_base;
+    unsigned int irq = 0;
+
+    for (port = 0; port < 6; port++) {
+        if (ISR(port) & IMR(port)) {
+            break;
+        }
+    }
+
+    mask = ISR(port);
+    irq_base = IRQ_GPIOA(0) + (port * 32);
+
+    desc = irq_desc + irq_base;
+    while (mask) {
+        if (mask & 1) {
+            DEBUG_IRQ("handling irq %d (port %d)\n", irq, port);
+            desc_handle_irq(irq + irq_base, desc, regs);
+            ISR(port) = (1 << irq);
+        }
+        irq++;
+        desc++;
+        mask >>= 1;
+    }
+}
+
+static struct irqchip imx21_gpio_chip = {
+	.ack = imx21_gpio_ack_irq,
+	.mask = imx21_gpio_mask_irq,
+	.unmask = imx21_gpio_unmask_irq,
+	.set_type = imx21_gpio_irq_type,
+};
+
+static struct irqchip imx21_internal_chip = {
+	.ack = imx21_mask_irq,
+	.mask = imx21_mask_irq,
+	.unmask = imx21_unmask_irq,
+};
+
+void __init
+imx21_init_irq(void)
+{
+	unsigned int irq;
+
+	DEBUG_IRQ("Initializing imx21 interrupts\n");
+
+	/* Mask all interrupts initially */
+	IMR(0) = 0;
+	IMR(1) = 0;
+	IMR(2) = 0;
+	IMR(3) = 0;
+	IMR(4) = 0;
+	IMR(5) = 0;
+
+	for (irq = 0; irq < IMX21_IRQS; irq++) {
+		set_irq_chip(irq, &imx21_internal_chip);
+		set_irq_handler(irq, do_level_IRQ);
+		set_irq_flags(irq, IRQF_VALID);
+	}
+
+	for (irq = IRQ_GPIOA(0); irq < IRQ_GPIOF(32); irq++) {
+		set_irq_chip(irq, &imx21_gpio_chip);
+		set_irq_handler(irq, do_edge_IRQ);
+		set_irq_flags(irq, IRQF_VALID);
+	}
+
+	set_irq_chained_handler(INT_GPIO, imx21_gpio_handler);
+
+	/* Disable all interrupts initially. */
+	/* In IMX21 this is done in the bootloader. */
+}
diff -NaurbB linux-2.6.14_original/arch/arm/mach-imx21/Kconfig linux-2.6.14_imx21/arch/arm/mach-imx21/Kconfig
--- linux-2.6.14_original/arch/arm/mach-imx21/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/arch/arm/mach-imx21/Kconfig	2006-04-11 10:29:12.000000000 +0200
@@ -0,0 +1,37 @@
+menu "IMX Implementations"
+	depends on FAMILY_IMX21
+
+choice
+	prompt "Select IMX21-based board"
+	default ARCH_MX2ADS
+
+config MACH_CSB535
+	bool "CSB535"
+	depends on FAMILY_IMX21
+	select ARCH_IMX21
+	help
+	  Say Y here if you are using the Cogent CSB535 board.
+
+config ARCH_MX2ADS
+	bool "mx2ads"
+	depends on FAMILY_IMX21
+	select ARCH_IMX21
+	help
+	  Say Y here if you are using the Freescale MX21ADS board
+ 
+endchoice
+
+config UMON_SHIM
+	bool "Shim uMON's call command"
+	depends on MACH_CSB535
+	default n
+	help
+		Select Y to add an assembly language "shim" to the bootloader
+		that maps the parameters as they are passed by older versions
+		of uMON to the ATAGS parameter passing convention supported by
+		the latest arm-linux kernels.  If in doubt, select yes.
+
+endmenu
+
+config ARCH_IMX21
+	bool
diff -NaurbB linux-2.6.14_original/arch/arm/mach-imx21/leds.c linux-2.6.14_imx21/arch/arm/mach-imx21/leds.c
--- linux-2.6.14_original/arch/arm/mach-imx21/leds.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/arch/arm/mach-imx21/leds.c	2006-04-11 10:29:12.000000000 +0200
@@ -0,0 +1,31 @@
+/*
+ * linux/arch/arm/mach-imx21/leds.h
+ *
+ * Copyright (C) 2004 Sascha Hauer <sascha@saschahauer.de>
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <asm/leds.h>
+#include <asm/mach-types.h>
+
+#include "leds.h"
+
+static int __init
+leds_init(void)
+{
+	if (machine_is_mx1ads()) {
+		leds_event = mx1ads_leds_event;
+	}
+
+	return 0;
+}
+
+__initcall(leds_init);
diff -NaurbB linux-2.6.14_original/arch/arm/mach-imx21/leds.h linux-2.6.14_imx21/arch/arm/mach-imx21/leds.h
--- linux-2.6.14_original/arch/arm/mach-imx21/leds.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/arch/arm/mach-imx21/leds.h	2006-04-11 10:29:12.000000000 +0200
@@ -0,0 +1,9 @@
+/*
+ * include/asm-arm/arch-imx21/leds.h
+ *
+ * Copyright (c) 2004 Sascha Hauer <sascha@saschahauer.de>
+ *
+ * blinky lights for IMX-based systems
+ *
+ */
+extern void mx1ads_leds_event(led_event_t evt);
diff -NaurbB linux-2.6.14_original/arch/arm/mach-imx21/leds-mx2ads.c linux-2.6.14_imx21/arch/arm/mach-imx21/leds-mx2ads.c
--- linux-2.6.14_original/arch/arm/mach-imx21/leds-mx2ads.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/arch/arm/mach-imx21/leds-mx2ads.c	2006-04-11 10:29:12.000000000 +0200
@@ -0,0 +1,54 @@
+/*
+ * linux/arch/arm/mach-imx21/leds-mx2ads.c
+ *
+ * Copyright (c) 2004 Sascha Hauer <sascha@saschahauer.de>
+ *
+ * Original (leds-footbridge.c) by Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/hardware.h>
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/leds.h>
+#include <asm/mach-types.h>
+#include "leds.h"
+
+/*
+ * The MX1ADS Board has only one usable LED,
+ * so select only the timer led or the
+ * cpu usage led
+ */
+void
+mx1ads_leds_event(led_event_t ledevt)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	switch (ledevt) {
+#ifdef CONFIG_LEDS_CPU
+	case led_idle_start:
+		DR(0) &= ~(1<<2);
+		break;
+
+	case led_idle_end:
+		DR(0) |= 1<<2;
+		break;
+#endif
+
+#ifdef CONFIG_LEDS_TIMER
+	case led_timer:
+		DR(0) ^= 1<<2;
+#endif
+	default:
+		break;
+	}
+	local_irq_restore(flags);
+}
diff -NaurbB linux-2.6.14_original/arch/arm/mach-imx21/Makefile linux-2.6.14_imx21/arch/arm/mach-imx21/Makefile
--- linux-2.6.14_original/arch/arm/mach-imx21/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/arch/arm/mach-imx21/Makefile	2006-04-11 10:29:12.000000000 +0200
@@ -0,0 +1,20 @@
+#
+# Makefile for the linux kernel.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+
+# Object file lists.
+
+obj-y			+= irq.o time.o dma.o generic.o
+
+# Specific board support
+obj-$(CONFIG_ARCH_MX2ADS) += mx2ads.o
+obj-$(CONFIG_MACH_CSB535) += csb535.o
+
+# Support for blinky lights
+led-y := leds.o
+
+obj-$(CONFIG_LEDS)	+=  $(led-y)
+led-$(CONFIG_ARCH_MX2ADS) += leds-mx2ads.o
diff -NaurbB linux-2.6.14_original/arch/arm/mach-imx21/Makefile.boot linux-2.6.14_imx21/arch/arm/mach-imx21/Makefile.boot
--- linux-2.6.14_original/arch/arm/mach-imx21/Makefile.boot	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/arch/arm/mach-imx21/Makefile.boot	2006-04-11 10:29:12.000000000 +0200
@@ -0,0 +1,3 @@
+    zreladdr-$(CONFIG_ARCH_MX2ADS)	:= 0xc0008000
+    zreladdr-$(CONFIG_MACH_CSB535)	:= 0xc0008000
+
diff -NaurbB linux-2.6.14_original/arch/arm/mach-imx21/mx2ads.c linux-2.6.14_imx21/arch/arm/mach-imx21/mx2ads.c
--- linux-2.6.14_original/arch/arm/mach-imx21/mx2ads.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/arch/arm/mach-imx21/mx2ads.c	2006-04-11 10:29:12.000000000 +0200
@@ -0,0 +1,210 @@
+/*
+ * arch/arm/mach-imx21/mx2ads.c
+ *
+ * Initially based on:
+ *	linux-2.6.7-imx/arch/arm/ mach-imx /scb9328.c
+ *	Copyright (c) 2004 Sascha Hauer <sascha@saschahauer.de>
+ *
+ * 2004 (c) MontaVista Software, Inc.
+ *
+ * Modified By: Ron Melvin (ron.melvin@timesys.com)
+ * Copyright (c) 2005 TimeSys Corporation 
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/device.h>
+#include <linux/init.h>
+#include <asm/system.h>
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+
+#include <asm/mach/map.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <linux/interrupt.h>
+#include "generic.h"
+#include <asm/serial.h>
+#include <asm/arch/imx21fb.h>
+
+static struct resource enet_resources[] = {
+	[0] = {
+		.start	= IMX21_CS1_VIRT,
+		.end	= IMX21_CS1_VIRT + 16,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+	        .start	= INT_UART3,
+		.end	= INT_UART3,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device enet_device = {
+	.name		= "imx21-ethernet",
+	.num_resources	= ARRAY_SIZE(enet_resources),
+	.resource	= enet_resources,
+};
+
+/* TODO, figure out correct IRQ */
+static struct resource extuart_resources[] = {
+	[0] = {
+		.start	= IMX21_CS1_VIRT+0x200000,
+		.end	= IMX21_CS1_VIRT+0x200000 + 16,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+	    .start	= 0,
+		.end	= 0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device extuart_device = {
+	.name		= "imx21-ext-uart",
+	.num_resources	= ARRAY_SIZE(extuart_resources),
+	.resource	= extuart_resources,
+};
+
+/* TODO, figure out correct IRQ */
+static struct resource cpuvers_resources[] = {
+	[0] = {
+		.start	= IMX21_CS1_VIRT+0x400000,
+		.end	= IMX21_CS1_VIRT+0x400000 + 2,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+	    .start	= 0,
+		.end	= 0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device cpuvers_device = {
+	.name		= "imx21-cpuvers",
+	.num_resources	= ARRAY_SIZE(cpuvers_resources),
+	.resource	= cpuvers_resources,
+};
+
+/* TODO, figure out correct IRQ */
+static struct resource mx21cfg_resources[] = {
+	[0] = {
+		.start	= IMX21_CS1_VIRT+0x800000,
+		.end	= IMX21_CS1_VIRT+0x800000 + 2,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+	    .start	= 0,
+		.end	= 0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mx21cfg_device = {
+	.name		= "imx21-mx21cfg",
+	.num_resources	= ARRAY_SIZE(mx21cfg_resources),
+	.resource	= mx21cfg_resources,
+};
+
+static struct platform_device *devices[] __initdata = {
+	&enet_device,
+	&extuart_device,
+	&cpuvers_device,
+	&mx21cfg_device,
+};
+
+static void __init
+fixup_mx21(struct machine_desc *desc, struct tag *tags,
+	   char **cmdline, struct meminfo *mi)
+
+{
+}
+
+static void mx2ads_lcd_power(int on)
+{
+	if(on)
+		MMIO_REG |= MMIO_LCDON;
+	else
+		MMIO_REG &= ~MMIO_LCDON;
+}
+
+// #define EXPERIMENTAL
+#ifdef EXPERIMENTAL
+
+/* LCD settings for Microtips MTG-F24160BFWNSEB-01 */
+static struct imxfb_mach_info mx2ads_fb_info __initdata = {
+	.pixclock	= 0, 		.bpp		= 1,
+	.xres		= 240,		.yres		= 160,
+
+	.hsync_len	= 0,		.vsync_len	= 0,
+	.left_margin	= 0,		.upper_margin	= 0,
+	.right_margin	= 0,		.lower_margin	= 0,
+
+	.lpcr	= LPCR_PBSIZ(LPCR_PBSIZ_PANEL_BUS_WIDTH_4) | LPCR_BPIX(LPCR_BPIX_BITS_PER_PIXEL_1) | PCR_SCLKSEL | PCR_PCD(7),
+	.lpccr	= 0,
+	.lscr	= 0, 
+
+	.lcd_power = mx2ads_lcd_power,
+};
+#else
+
+/* LCD settings for Sharp LCD LQ035Q7DB02 */
+static struct imxfb_mach_info mx2ads_fb_info __initdata = {
+	.pixclock	= 0, 		.bpp		= 16,
+	.xres		= 240,		.yres		= 320,
+
+	.hsync_len	= 1,		.vsync_len	= 1,
+	.left_margin	= 15,		.upper_margin	= 9,
+	.right_margin	= 6,		.lower_margin	= 7,
+
+	.lpcr	= LPCR_TFT | LPCR_COLOR | LPCR_PBSIZ(LPCR_PBSIZ_PANEL_BUS_WIDTH_8) | LPCR_BPIX(LPCR_BPIX_BITS_PER_PIXEL_16) | LPCR_PIXPOL | LPCR_OEPOL | LPCR_SCLKSEL | LPCR_SHARP | LPCR_PCD(7),
+	.lpccr	= LPCCR_CLS_HI_WIDTH(169) | LPCCR_SCR(LPCCR_SCR_PIXEL_CLOCK) | LPCCR_CC_EN | LPCCR_PW(0xff),
+	.lscr	= LSCR_PS_RISE_DELAY(0) | LSCR_CLS_RISE_DELAY(18) | LSCR_REV_TOGGLE_DELAY(3) | LSCR_GRAY2(0) | LSCR_GRAY1(0), 
+
+	.lcd_power = mx2ads_lcd_power,
+};
+#endif
+
+static void __init
+mx2ads_init(void)
+{
+	/* Configure the system clocks */
+	imx21_system_clk_init();	
+	
+	/* Set LCD display platform_data information*/
+	set_imx_fb_info(&mx2ads_fb_info);
+		
+	/* Enable the LCD display */
+	mx2ads_lcd_power(1);
+	
+	platform_add_devices(devices, ARRAY_SIZE(devices));
+}
+
+static struct map_desc mx2ads_io_desc[] __initdata = {
+	/* virtual     physical    length      type */
+	{IMX21_CS0_VIRT, IMX21_CS0_PHYS, IMX21_CS0_SIZE, MT_DEVICE},
+	{IMX21_CS1_VIRT, IMX21_CS1_PHYS, IMX21_CS1_SIZE, MT_DEVICE},
+};
+
+static void __init
+mx2ads_map_io(void)
+{
+	imx21_map_io();
+	iotable_init(mx2ads_io_desc, ARRAY_SIZE(mx2ads_io_desc));
+}
+
+MACHINE_START(MX2ADS, "Motorola MX2ADS")
+	MAINTAINER("Timesys Inc.")
+	BOOT_MEM(0xc0000000, 0xc8000000, 0xe0200000)
+	BOOT_PARAMS(0xc0000100)
+        FIXUP(fixup_mx21)
+	MAPIO(mx2ads_map_io)
+	INITIRQ(imx21_init_irq)
+	.timer		= &imx21_timer,
+	INIT_MACHINE(mx2ads_init)
+MACHINE_END
diff -NaurbB linux-2.6.14_original/arch/arm/mach-imx21/time.c linux-2.6.14_imx21/arch/arm/mach-imx21/time.c
--- linux-2.6.14_original/arch/arm/mach-imx21/time.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/arch/arm/mach-imx21/time.c	2006-04-11 10:29:12.000000000 +0200
@@ -0,0 +1,102 @@
+/*
+ *  linux/arch/arm/mach-imx21/time.c
+ *
+ *  Copyright (C) 2000-2001 Deep Blue Solutions
+ *  Copyright (C) 2002 Shane Nay (shane@minirl.com)
+ *
+ *  Modified By: Ron Melvin (ron.melvin@timesys.com)
+ *  Copyright (C) 2005 TimeSys Corporation *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/time.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/leds.h>
+#include <asm/irq.h>
+#include <asm/mach/time.h>
+
+/*
+ * Returns number of us since last clock interrupt.  Note that interrupts
+ * will have been disabled by do_gettimeoffset()
+ */
+static unsigned long imx21_gettimeoffset(void)
+{
+	unsigned long ticks;
+
+	/*
+	 * Get the current number of ticks.  Note that there is a race
+	 * condition between us reading the timer and checking for
+	 * an interrupt.  We get around this by ensuring that the
+	 * counter has not reloaded between our two reads.
+	 */
+	ticks = IMX21_TCN(GPT1);
+
+	/*
+	 * Interrupt pending?  If so, we've reloaded once already.
+	 */
+	if (IMX21_TSTAT(GPT1) & TSTAT_COMP)
+		ticks += LATCH;
+
+	/*
+	 * Convert the ticks to usecs
+	 */
+	return (1000000 / CLK32) * ticks;
+}
+
+/*
+ * IRQ handler for the timer
+ */
+static irqreturn_t
+imx21_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	write_seqlock(&xtime_lock);
+
+	/* if any bits set, rupt has occurred, clear it by  writing a 1 */
+	if ( IMX21_TSTAT(GPT1) ) {
+	    IMX21_TSTAT(GPT1) = TSTAT_CAPT | TSTAT_COMP;
+	}
+	
+	timer_tick(regs);
+	write_sequnlock(&xtime_lock);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction imx21_timer_irq = {
+	.name		= "i.MX21 Timer Tick",
+	.flags		= SA_INTERRUPT,
+	.handler	= imx21_timer_interrupt
+};
+
+/*
+ * Set up timer interrupt, and return the current time in seconds.
+ */
+static void __init imx21_timer_init(void)
+{
+	/*
+	 * Initialise to a known state (all timers off, and timing reset)
+	 */
+	IMX21_TCTL(GPT1) = 0;
+	IMX21_TPRER(GPT1) = 0;
+	IMX21_TCMP(GPT1) = LATCH - 1;
+	IMX21_TCTL(GPT1) = TCTL_CLK_32 | TCTL_IRQEN | TCTL_TEN;
+
+	/*
+	 * Make irqs happen for the system timer
+	 */
+	setup_irq(INT_GPT1, &imx21_timer_irq);
+}
+
+struct sys_timer imx21_timer = {
+	.init		= imx21_timer_init,
+	.offset		= imx21_gettimeoffset,
+};
diff -NaurbB linux-2.6.14_original/arch/arm/Makefile linux-2.6.14_imx21/arch/arm/Makefile
--- linux-2.6.14_original/arch/arm/Makefile	2005-10-28 02:02:08.000000000 +0200
+++ linux-2.6.14_imx21/arch/arm/Makefile	2006-04-11 10:55:33.000000000 +0200
@@ -5,6 +5,11 @@
 # License.  See the file "COPYING" in the main directory of this archive
 # for more details.
 #
+# March 2006 :
+# Adapted to ARM9 i.MX21/CSB535FS board by S.Gerber, G.Boutillier and D.Rossier
+# University of Applied Sciences Western Switzerland
+# Reconfigurable & Embedded Digital Systems, REDS Institute
+#
 # Copyright (C) 1995-2001 by Russell King
 
 LDFLAGS_vmlinux	:=-p --no-undefined -X
@@ -97,6 +102,7 @@
  machine-$(CONFIG_ARCH_LH7A40X)	   := lh7a40x
  machine-$(CONFIG_ARCH_VERSATILE)  := versatile
  machine-$(CONFIG_ARCH_IMX)	   := imx
+ machine-$(CONFIG_ARCH_IMX21)	   := imx21
  machine-$(CONFIG_ARCH_H720X)	   := h720x
  machine-$(CONFIG_ARCH_AAEC2000)   := aaec2000
 
diff -NaurbB linux-2.6.14_original/arch/arm/mm/Kconfig linux-2.6.14_imx21/arch/arm/mm/Kconfig
--- linux-2.6.14_original/arch/arm/mm/Kconfig	2005-10-28 02:02:08.000000000 +0200
+++ linux-2.6.14_imx21/arch/arm/mm/Kconfig	2006-04-11 11:23:03.000000000 +0200
@@ -1,3 +1,10 @@
+#
+# March 2006 :
+# Adapted to ARM9 i.MX21/CSB535FS board by S.Gerber, G.Boutillier and D.Rossier
+# University of Applied Sciences Western Switzerland
+# Reconfigurable & Embedded Digital Systems, REDS Institute
+#
+
 comment "Processor Type"
 
 config CPU_32
@@ -120,9 +127,9 @@
 
 # ARM926T
 config CPU_ARM926T
-	bool "Support ARM926T processor" if ARCH_INTEGRATOR
-	depends on ARCH_INTEGRATOR || ARCH_VERSATILE_PB || MACH_VERSATILE_AB || ARCH_OMAP730 || ARCH_OMAP16XX
-	default y if ARCH_VERSATILE_PB || MACH_VERSATILE_AB || ARCH_OMAP730 || ARCH_OMAP16XX
+	bool "Support ARM926T processor" if ARCH_INTEGRATOR || ARCH_IMX21
+	depends on ARCH_INTEGRATOR || ARCH_VERSATILE_PB || MACH_VERSATILE_AB || ARCH_OMAP730 || ARCH_OMAP16XX || FAMILY_IMX21
+	default y if ARCH_VERSATILE_PB || MACH_VERSATILE_AB || ARCH_OMAP730 || ARCH_OMAP16XX || ARCH_IMX21
 	select CPU_32v5
 	select CPU_ABRT_EV5TJ
 	select CPU_CACHE_VIVT
diff -NaurbB linux-2.6.14_original/config_2.6.14_imx21_cogent535fs linux-2.6.14_imx21/config_2.6.14_imx21_cogent535fs
--- linux-2.6.14_original/config_2.6.14_imx21_cogent535fs	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/config_2.6.14_imx21_cogent535fs	2006-04-11 13:36:23.000000000 +0200
@@ -0,0 +1,798 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.14
+# Tue Apr 11 13:36:23 2006
+#
+CONFIG_ARM=y
+CONFIG_MMU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+# CONFIG_HOTPLUG is not set
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+# CONFIG_MODULE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_IMX is not set
+CONFIG_FAMILY_IMX21=y
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_AAEC2000 is not set
+
+#
+# IMX Implementations
+#
+CONFIG_MACH_CSB535=y
+# CONFIG_ARCH_MX2ADS is not set
+CONFIG_UMON_SHIM=y
+CONFIG_ARCH_IMX21=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+
+#
+# Bus support
+#
+CONFIG_ISA_DMA_API=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_PREEMPT=y
+# CONFIG_NO_IDLE_HZ is not set
+# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_CMDLINE="console=ttySMX0,57600n8 ip=bootp root=/dev/nfs"
+# CONFIG_XIP_KERNEL is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+CONFIG_FPE_NWFPE_XP=y
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_ARTHUR is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_CONCAT=y
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_XIP is not set
+
+#
+# Mapping drivers for chip access
+#
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+CONFIG_MTD_CSB535=y
+# CONFIG_MTD_EDB7312 is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+CONFIG_DUMMY=y
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MII is not set
+CONFIG_CIRRUS=y
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_CONSOLE is not set
+CONFIG_SERIAL_8250_NR_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_IMX21=y
+CONFIG_SERIAL_IMX_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+# CONFIG_I2C_CHARDEV is not set
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_DS1337 is not set
+# CONFIG_SENSORS_DS1374 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_FSCPOS is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+# CONFIG_FB_CFB_FILLRECT is not set
+# CONFIG_FB_CFB_COPYAREA is not set
+# CONFIG_FB_CFB_IMAGEBLIT is not set
+# CONFIG_FB_SOFT_CURSOR is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+
+#
+# Logo configuration
+#
+# CONFIG_LOGO is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=y
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=m
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=m
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=m
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_DEBUG_BUGVERBOSE is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_USER is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
diff -NaurbB linux-2.6.14_original/drivers/mtd/maps/csbxxx.c linux-2.6.14_imx21/drivers/mtd/maps/csbxxx.c
--- linux-2.6.14_original/drivers/mtd/maps/csbxxx.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/drivers/mtd/maps/csbxxx.c	2006-04-11 10:29:12.000000000 +0200
@@ -0,0 +1,159 @@
+/*
+ *
+ * Map driver for the Cogent CSBxxx boards.
+ *
+ * Author:	Bill Gatliff
+ * Copyright:	(C) 2005 Bill Gatliff <bgat@billgatliff.com>
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+
+#define MTDID "flash00"
+#define MSG_PREFIX "csbxxx: "
+
+#if defined(CONFIG_MACH_CSB337) \
+  || defined(CONFIG_MACH_CSB437TL) \
+  || defined(CONFIG_MACH_CSB637)
+#define WINDOW_ADDR 0x10000000
+#define WINDOW_SIZE 0x1000000
+#elif defined(CONFIG_MACH_CSB625)
+#define WINDOW_ADDR 0x00000000
+#define WINDOW_SIZE 0x1000000
+#elif defined(CONFIG_MACH_CSB535)
+#define WINDOW_ADDR 0xc8000000
+#define WINDOW_SIZE 0x00800000
+#elif defined(CONFIG_ARCH_CSB226)
+#error TODO: finish MTD map for CSB226
+#else
+#error TODO: the MTD map you need goes here...
+#endif
+
+#define NB_OF(a) (sizeof(a)/sizeof(*(a)))
+
+static void csbxxx_map_inval_cache(struct map_info *map, unsigned long from, ssize_t len)
+{
+  consistent_sync((char *)map->cached + from, len, DMA_FROM_DEVICE);
+}
+
+static struct map_info csbxxx_map = {
+    .size = WINDOW_SIZE,
+    .phys = WINDOW_ADDR,
+    .inval_cache = csbxxx_map_inval_cache,
+    .bankwidth = 2,
+    .name = MTDID,
+};
+
+/* default map definition,
+   generally overridden on the command line */
+static struct mtd_partition csbxxx_partitions[] = {
+  {
+    .name = "uMON flash",
+    .size = WINDOW_SIZE,
+    .mask_flags = MTD_WRITEABLE  /* force read-only */
+  },
+};
+
+static const char *probes[] = { "cmdlinepart", NULL };
+
+static struct mtd_info *mymtd = 0;
+static int mtd_parts_nb = 0;
+static struct mtd_partition *mtd_parts = 0;
+
+static int __init init_csbxxx(void)
+{
+  int ret = 0;
+  const char *part_type = 0;
+
+  csbxxx_map.virt = ioremap(csbxxx_map.phys, WINDOW_SIZE);
+  if (!csbxxx_map.virt) {
+    printk(KERN_WARNING "Failed to ioremap %s, MTD disabled\n", csbxxx_map.name);
+    ret = -ENOMEM;
+    goto err;
+  }
+  csbxxx_map.cached = ioremap_cached(csbxxx_map.phys, WINDOW_SIZE);
+  if (!csbxxx_map.cached)
+    printk(KERN_WARNING "Failed to ioremap cached %s\n", csbxxx_map.name);
+
+  simple_map_init(&csbxxx_map);
+  
+  printk(KERN_NOTICE "Probing %s at physical address 0x%08lx (%d-bit bankwidth)\n",
+	 csbxxx_map.name, csbxxx_map.phys, csbxxx_map.bankwidth * 8);
+  
+  mymtd = do_map_probe("cfi_probe", &csbxxx_map);
+  
+  if (!mymtd)
+    goto err;
+
+  mymtd->owner = THIS_MODULE;
+  
+  mtd_parts_nb = parse_mtd_partitions(mymtd, probes, &mtd_parts, 0);
+
+  if (mtd_parts_nb > 0)
+    part_type = "command line";
+  else if (mtd_parts_nb == 0)
+    {
+      mtd_parts = csbxxx_partitions;
+      mtd_parts_nb = NB_OF(csbxxx_partitions);
+      part_type = "static";
+    }
+  else goto err;
+
+#if 1
+#warning "TODO: is add_mtd_device needed?"
+#else
+  add_mtd_device(mymtd);
+#endif
+  if (mtd_parts_nb == 0)
+    printk(KERN_NOTICE MSG_PREFIX "no partition info available\n");
+  else
+    {
+      printk(KERN_NOTICE MSG_PREFIX
+	     "using %s partition definition\n", part_type);
+      add_mtd_partitions(mymtd, mtd_parts, mtd_parts_nb);
+    }
+  
+  return 0;
+
+err:
+  if (csbxxx_map.virt)
+    iounmap(csbxxx_map.virt);
+  if (csbxxx_map.cached)
+    iounmap(csbxxx_map.cached);
+  if (!ret)
+    ret = -EIO;
+
+  return ret;
+}
+
+static void __exit cleanup_csbxxx(void)
+{
+  if (!mymtd)
+    return;
+
+  del_mtd_partitions(mymtd);
+  
+  map_destroy(mymtd);
+  iounmap((void *)csbxxx_map.virt);
+  if (csbxxx_map.cached)
+    iounmap(csbxxx_map.cached);
+}
+
+module_init(init_csbxxx);
+module_exit(cleanup_csbxxx);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Bill Gatliff <bgat@billgatliff.com>");
+MODULE_DESCRIPTION("MTD map driver for Cogent CSBXXX");
diff -NaurbB linux-2.6.14_original/drivers/mtd/maps/Kconfig linux-2.6.14_imx21/drivers/mtd/maps/Kconfig
--- linux-2.6.14_original/drivers/mtd/maps/Kconfig	2005-10-28 02:02:08.000000000 +0200
+++ linux-2.6.14_imx21/drivers/mtd/maps/Kconfig	2006-04-11 11:28:31.000000000 +0200
@@ -1,3 +1,10 @@
+#
+# March 2006 :
+# Adapted to ARM9 i.MX21/CSB535FS board by S.Gerber, G.Boutillier and D.Rossier
+# University of Applied Sciences Western Switzerland
+# Reconfigurable & Embedded Digital Systems, REDS Institute
+#
+
 # drivers/mtd/maps/Kconfig
 # $Id: Kconfig,v 1.55 2005/07/02 01:53:24 tpoynor Exp $
 
@@ -410,6 +417,16 @@
 	  This enables access to the flash or ROM chips on the CDB89712 board.
 	  If you have such a board, say 'Y'.
 
+config MTD_CSB535
+	tristate "CFI Flash device mapped on Cogent CSB535"
+	depends on ARM && MTD_CFI && MACH_CSB535
+	help
+	  This enables access to the flash chip on the Cogent CSB535
+	  single board computer.  The default behavior of the startup
+	  script the comes with BSPs for that board is to pass the address
+	  of a file romfs.img, which is assumed to be a romfs filesystem image
+	  to be used as the initial root filesystem.
+
 config MTD_SA1100
 	tristate "CFI Flash device mapped on StrongARM SA11x0"
 	depends on ARM && MTD_CFI && ARCH_SA1100 && MTD_PARTITIONS
diff -NaurbB linux-2.6.14_original/drivers/mtd/maps/Makefile linux-2.6.14_imx21/drivers/mtd/maps/Makefile
--- linux-2.6.14_original/drivers/mtd/maps/Makefile	2005-10-28 02:02:08.000000000 +0200
+++ linux-2.6.14_imx21/drivers/mtd/maps/Makefile	2006-04-11 11:29:09.000000000 +0200
@@ -1,6 +1,12 @@
 #
 # linux/drivers/maps/Makefile
 #
+# March 2006 :
+# Adapted to ARM9 i.MX21/CSB535FS board by S.Gerber, G.Boutillier and D.Rossier
+# University of Applied Sciences Western Switzerland
+# Reconfigurable & Embedded Digital Systems, REDS Institute
+#
+#
 # $Id: Makefile.common,v 1.30 2005/07/02 01:53:24 tpoynor Exp $
 
 ifeq ($(CONFIG_MTD_COMPLEX_MAPPINGS),y)
@@ -70,3 +76,4 @@
 obj-$(CONFIG_MTD_SHARP_SL)	+= sharpsl-flash.o
 obj-$(CONFIG_MTD_PLATRAM)	+= plat-ram.o
 obj-$(CONFIG_MTD_OMAP_NOR)	+= omap_nor.o
+obj-$(CONFIG_MTD_CSB535)	+= csbxxx.o
diff -NaurbB linux-2.6.14_original/drivers/net/cirrus.c linux-2.6.14_imx21/drivers/net/cirrus.c
--- linux-2.6.14_original/drivers/net/cirrus.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/drivers/net/cirrus.c	2006-04-11 10:29:12.000000000 +0200
@@ -0,0 +1,702 @@
+
+/*
+ * linux/drivers/net/cirrus.c
+ *
+ * Author: Abraham van der Merwe <abraham@2d3d.co.za>
+ *
+ * A Cirrus Logic CS8900A driver for Linux
+ * based on the cs89x0 driver written by Russell Nelson,
+ * Donald Becker, and others.
+ *
+ * This source code is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ */
+
+/*
+ * At the moment the driver does not support memory mode operation.
+ * It is trivial to implement this, but not worth the effort.
+ */
+
+/*
+ * TODO:
+ *
+ *   1. If !ready in send_start(), queue buffer and send it in interrupt handler
+ *      when we receive a BufEvent with Rdy4Tx, send it again. dangerous!
+ *   2. how do we prevent interrupt handler destroying integrity of get_stats()?
+ *   3. Change reset code to check status.
+ *   4. Implement set_mac_address and remove fake mac address
+ *   5. Link status detection stuff
+ *   6. Write utility to write EEPROM, do self testing, etc.
+ *   7. Implement DMA routines (I need a board w/ DMA support for that)
+ *   8. Power management
+ *   9. Add support for multiple ethernet chips
+ *  10. Add support for other cs89xx chips (need hardware for that)
+ */
+
+#include <linux/config.h>
+#include <linux/version.h>
+#include <linux/module.h>
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+
+#include <asm/irq.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+
+#include "cirrus.h"
+
+/* #define DEBUG */
+/* #define FULL_DUPLEX */
+
+
+typedef struct {
+	struct net_device_stats stats;
+	u16 txlen;
+} cirrus_t;
+
+typedef struct {
+	u16 io_base;		/* I/O Base Address			*/
+	u16 irq;			/* Interrupt Number			*/
+	u16 dma;			/* DMA Channel Numbers		*/
+	u32 mem_base;		/* Memory Base Address		*/
+	u32 rom_base;		/* Boot PROM Base Address	*/
+	u32 rom_mask;		/* Boot PROM Address Mask	*/
+	u8 mac[6];			/* Individual Address		*/
+} cirrus_eeprom_t;
+
+/*
+ * I/O routines
+ */
+
+static inline u16 cirrus_read (struct net_device *dev,u16 reg)
+{
+	CIRRUS_outw (reg, dev->base_addr, PP_Address);
+	return (CIRRUS_inw (dev->base_addr, PP_Data));
+}
+
+static inline void cirrus_write (struct net_device *dev,u16 reg,u16 value)
+{
+	CIRRUS_outw (reg, dev->base_addr, PP_Address);
+	CIRRUS_outw (value, dev->base_addr, PP_Data);
+}
+
+static inline void cirrus_set (struct net_device *dev,u16 reg,u16 value)
+{
+	cirrus_write (dev,reg,cirrus_read (dev,reg) | value);
+}
+
+static inline void cirrus_clear (struct net_device *dev,u16 reg,u16 value)
+{
+	cirrus_write (dev,reg,cirrus_read (dev,reg) & ~value);
+}
+
+static inline void cirrus_frame_read (struct net_device *dev,struct sk_buff *skb,u16 length)
+{
+	CIRRUS_insw (dev->base_addr, 0, skb_put (skb,length), (length + 1) / 2);
+}
+
+static inline void cirrus_frame_write (struct net_device *dev,struct sk_buff *skb)
+{
+	CIRRUS_outsw (dev->base_addr, 0, skb->data, (skb->len + 1) / 2);
+}
+
+/*
+ * Debugging functions
+ */
+
+#ifdef DEBUG
+static inline int printable (int c)
+{
+	return ((c >= 32 && c <= 126) ||
+			(c >= 174 && c <= 223) ||
+			(c >= 242 && c <= 243) ||
+			(c >= 252 && c <= 253));
+}
+
+static void dump16 (struct net_device *dev,const u8 *s,size_t len)
+{
+	int i;
+	char str[128];
+
+	if (!len) return;
+
+	*str = '\0';
+
+	for (i = 0; i < len; i++) {
+		if (i && !(i % 4)) strcat (str," ");
+		sprintf (str,"%s%.2x ",str,s[i]);
+	}
+
+	for ( ; i < 16; i++) {
+		if (i && !(i % 4)) strcat (str," ");
+		strcat (str,"   ");
+	}
+
+	strcat (str," ");
+	for (i = 0; i < len; i++) sprintf (str,"%s%c",str,printable (s[i]) ? s[i] : '.');
+
+	printk (KERN_DEBUG "%s:     %s\n",dev->name,str);
+}
+
+static void hexdump (struct net_device *dev,const void *ptr,size_t size)
+{
+	const u8 *s = (u8 *) ptr;
+	int i;
+	for (i = 0; i < size / 16; i++, s += 16) dump16 (dev,s,16);
+	dump16 (dev,s,size % 16);
+}
+
+static void dump_packet (struct net_device *dev,struct sk_buff *skb,const char *type)
+{
+	printk (KERN_INFO "%s: %s %d byte frame %.2x:%.2x:%.2x:%.2x:%.2x:%.2x to %.2x:%.2x:%.2x:%.2x:%.2x:%.2x type %.4x\n",
+			dev->name,
+			type,
+			skb->len,
+			skb->data[0],skb->data[1],skb->data[2],skb->data[3],skb->data[4],skb->data[5],
+			skb->data[6],skb->data[7],skb->data[8],skb->data[9],skb->data[10],skb->data[11],
+			(skb->data[12] << 8) | skb->data[13]);
+	if (skb->len < 0x100) hexdump (dev,skb->data,skb->len);
+}
+#endif	/* #ifdef DEBUG */
+
+/*
+ * Driver functions
+ */
+
+static void cirrus_receive (struct net_device *dev)
+{
+	cirrus_t *priv = (cirrus_t *) dev->priv;
+	struct sk_buff *skb;
+	u16 status,length;
+
+	status = cirrus_read (dev,PP_RxStatus);
+	length = cirrus_read (dev,PP_RxLength);
+
+	if (!(status & RxOK)) {
+		priv->stats.rx_errors++;
+		if ((status & (Runt | Extradata))) priv->stats.rx_length_errors++;
+		if ((status & CRCerror)) priv->stats.rx_crc_errors++;
+		return;
+	}
+
+	if ((skb = dev_alloc_skb (length + 4)) == NULL) {
+		priv->stats.rx_dropped++;
+		return;
+	}
+
+	skb->dev = dev;
+	skb_reserve (skb,2);
+
+	cirrus_frame_read (dev,skb,length);
+
+#ifdef DEBUG
+	dump_packet (dev,skb,"recv");
+#endif	/* #ifdef DEBUG */
+
+	skb->protocol = eth_type_trans (skb,dev);
+
+	netif_rx (skb);
+	dev->last_rx = jiffies;
+
+	priv->stats.rx_packets++;
+	priv->stats.rx_bytes += length;
+}
+
+static int cirrus_send_start (struct sk_buff *skb,struct net_device *dev)
+{
+	cirrus_t *priv = (cirrus_t *) dev->priv;
+	u16 status;
+
+	netif_stop_queue (dev);
+
+	cirrus_write (dev,PP_TxCMD,TxStart (After5));
+	cirrus_write (dev,PP_TxLength,skb->len);
+
+	status = cirrus_read (dev,PP_BusST);
+
+	if ((status & TxBidErr)) {
+		printk (KERN_WARNING "%s: Invalid frame size %d!\n",dev->name,skb->len);
+		priv->stats.tx_errors++;
+		priv->stats.tx_aborted_errors++;
+		priv->txlen = 0;
+		return (1);
+	}
+
+	if (!(status & Rdy4TxNOW)) {
+#warning TODO: figure out how to eliminate this message, not just mask it.
+//		printk (KERN_WARNING "%s: Transmit buffer not free!\n",dev->name);
+		priv->stats.tx_errors++;
+		priv->txlen = 0;
+		/* FIXME: store skb and send it in interrupt handler */
+		return (1);
+	}
+
+	cirrus_frame_write (dev,skb);
+
+#ifdef DEBUG
+	dump_packet (dev,skb,"send");
+#endif	/* #ifdef DEBUG */
+
+	dev->trans_start = jiffies;
+
+	dev_kfree_skb (skb);
+
+	priv->txlen = skb->len;
+
+	return (0);
+}
+
+static irqreturn_t cirrus_interrupt (int irq,void *id,struct pt_regs *regs)
+{
+	struct net_device *dev = (struct net_device *) id;
+	cirrus_t *priv;
+	u16 status;
+
+	int handled = 0;
+
+	//printk("### Cirrus IRQ\n");
+	
+	if (dev->priv == NULL) {
+		printk (KERN_WARNING "%s: irq %d for unknown device.\n",dev->name,irq);
+		handled = 1;
+		return IRQ_RETVAL(handled);
+	}
+
+	priv = (cirrus_t *) dev->priv;
+
+	while ((status = cirrus_read (dev,PP_ISQ))) {
+		switch (RegNum (status)) {
+		case RxEvent:
+			cirrus_receive (dev);
+			handled = 1;
+			break;
+
+		case TxEvent:
+			priv->stats.collisions += ColCount (cirrus_read (dev,PP_TxCOL));
+			if (!(RegContent (status) & TxOK)) {
+				priv->stats.tx_errors++;
+				if ((RegContent (status) & Out_of_window)) priv->stats.tx_window_errors++;
+				if ((RegContent (status) & Jabber)) priv->stats.tx_aborted_errors++;
+				break;
+			} else if (priv->txlen) {
+				priv->stats.tx_packets++;
+				priv->stats.tx_bytes += priv->txlen;
+			}
+			priv->txlen = 0;
+			netif_wake_queue (dev);
+			handled = 1;
+			break;
+
+		case BufEvent:
+			if ((RegContent (status) & RxMiss)) {
+				u16 missed = MissCount (cirrus_read (dev,PP_RxMISS));
+				priv->stats.rx_errors += missed;
+				priv->stats.rx_missed_errors += missed;
+			}
+			if ((RegContent (status) & TxUnderrun)) {
+				priv->stats.tx_errors++;
+				priv->stats.tx_fifo_errors++;
+			}
+			/* FIXME: if Rdy4Tx, transmit last sent packet (if any) */
+			priv->txlen = 0;
+			netif_wake_queue (dev);
+			handled = 1;
+			break;
+
+		case TxCOL:
+			priv->stats.collisions += ColCount (cirrus_read (dev,PP_TxCOL));
+			handled = 1;
+			break;
+
+		case RxMISS:
+			status = MissCount (cirrus_read (dev,PP_RxMISS));
+			priv->stats.rx_errors += status;
+			priv->stats.rx_missed_errors += status;
+			handled = 1;
+			break;
+		}
+	}
+
+	return IRQ_RETVAL(handled);
+}
+
+static void cirrus_transmit_timeout (struct net_device *dev)
+{
+	cirrus_t *priv = (cirrus_t *) dev->priv;
+	priv->stats.tx_errors++;
+	priv->stats.tx_heartbeat_errors++;
+	priv->txlen = 0;
+	netif_wake_queue (dev);
+}
+
+static int cirrus_start (struct net_device *dev)
+{
+	int result;
+
+	/* valid ethernet address? */
+	if (!is_valid_ether_addr(dev->dev_addr)) {
+		printk(KERN_ERR "%s: invalid ethernet MAC address\n",dev->name);
+		return (-EINVAL);
+	}
+
+	/* install interrupt handler */
+	printk("%s: requesting interrupt %i\n", __FUNCTION__, dev->irq);
+	if ((result = request_irq (dev->irq,&cirrus_interrupt,0,dev->name,dev)) < 0) {
+		printk (KERN_ERR "%s: could not register interrupt %d\n",dev->name,dev->irq);
+		return (result);
+	}
+	
+#if defined(CONFIG_ARCH_CSB226)
+#warning TODO: move this into csb226.c.
+#if 0
+	set_irq_type(dev->irq, IRQT_RISING);
+#endif
+#endif
+
+	/* enable the ethernet controller */
+	cirrus_set (dev,PP_RxCFG,RxOKiE | BufferCRC | CRCerroriE | RuntiE | ExtradataiE);
+	cirrus_set (dev,PP_RxCTL,RxOKA | IndividualA | BroadcastA);
+	cirrus_set (dev,PP_TxCFG,TxOKiE | Out_of_windowiE | JabberiE);
+	cirrus_set (dev,PP_BufCFG,Rdy4TxiE | RxMissiE | TxUnderruniE | TxColOvfiE | MissOvfloiE);
+	cirrus_set (dev,PP_LineCTL,SerRxON | SerTxON);
+	cirrus_set (dev,PP_BusCTL,EnableRQ);
+
+#ifdef FULL_DUPLEX
+	cirrus_set (dev,PP_TestCTL,FDX);
+#endif	/* #ifdef FULL_DUPLEX */
+
+	/* start the queue */
+	netif_start_queue (dev);
+
+	return (0);
+}
+
+static int cirrus_stop (struct net_device *dev)
+{
+	/* disable ethernet controller */
+	cirrus_write (dev,PP_BusCTL,0);
+	cirrus_write (dev,PP_TestCTL,0);
+	cirrus_write (dev,PP_SelfCTL,0);
+	cirrus_write (dev,PP_LineCTL,0);
+	cirrus_write (dev,PP_BufCFG,0);
+	cirrus_write (dev,PP_TxCFG,0);
+	cirrus_write (dev,PP_RxCTL,0);
+	cirrus_write (dev,PP_RxCFG,0);
+
+	/* uninstall interrupt handler */
+	free_irq (dev->irq,dev);
+
+	/* stop the queue */
+	netif_stop_queue (dev);
+
+	return (0);
+}
+
+static int cirrus_set_mac_address (struct net_device *dev, void *p)
+{
+	struct sockaddr *addr = (struct sockaddr *)p;
+	int i;
+
+	if (netif_running(dev))
+		return -EBUSY;
+
+	memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
+
+	/* configure MAC address */
+	for (i = 0; i < ETH_ALEN; i += 2)
+		cirrus_write (dev,PP_IA + i,dev->dev_addr[i] | (dev->dev_addr[i + 1] << 8));
+
+	return 0;
+}
+
+static struct net_device_stats *cirrus_get_stats (struct net_device *dev)
+{
+	cirrus_t *priv = (cirrus_t *) dev->priv;
+	return (&priv->stats);
+}
+
+static void cirrus_set_receive_mode (struct net_device *dev)
+{
+	if ((dev->flags & IFF_PROMISC))
+		cirrus_set (dev,PP_RxCTL,PromiscuousA);
+	else
+		cirrus_clear (dev,PP_RxCTL,PromiscuousA);
+
+	if ((dev->flags & IFF_ALLMULTI) && dev->mc_list)
+		cirrus_set (dev,PP_RxCTL,MulticastA);
+	else
+		cirrus_clear (dev,PP_RxCTL,MulticastA);
+}
+
+static int cirrus_eeprom_wait (struct net_device *dev)
+{
+	int i;
+
+	for (i = 0; i < 200; i++) {
+		if (!(cirrus_read (dev,PP_SelfST) & SIBUSY))
+			return (0);
+		udelay (1);
+	}
+
+	return (-1);
+}
+
+static int cirrus_eeprom_read (struct net_device *dev,u16 *value,u16 offset)
+{
+	if (cirrus_eeprom_wait (dev) < 0)
+		return (-1);
+
+	cirrus_write (dev,PP_EEPROMCommand,offset | EEReadRegister);
+
+	if (cirrus_eeprom_wait (dev) < 0)
+		return (-1);
+
+	*value = cirrus_read (dev,PP_EEPROMData);
+
+	return (0);
+}
+
+static int cirrus_eeprom (struct net_device *dev,cirrus_eeprom_t *eeprom)
+{
+	u16 offset,buf[16],*word;
+	u8 checksum = 0,*byte;
+
+	if (cirrus_eeprom_read (dev,buf,0) < 0) {
+		read_timed_out:
+		printk (KERN_DEBUG "%s: EEPROM read timed out\n",dev->name);
+		return (-ETIMEDOUT);
+	}
+
+	if ((buf[0] >> 8) != 0xa1) {
+		printk (KERN_DEBUG "%s: No EEPROM present\n",dev->name);
+		return (-ENODEV);
+	}
+
+	if ((buf[0] & 0xff) < sizeof (buf)) {
+		eeprom_too_small:
+		printk (KERN_DEBUG "%s: EEPROM too small\n",dev->name);
+		return (-ENODEV);
+	}
+
+	for (offset = 1; offset < (buf[0] & 0xff); offset++) {
+		if (cirrus_eeprom_read (dev,buf + offset,offset) < 0)
+			goto read_timed_out;
+
+		if (buf[offset] == 0xffff)
+			goto eeprom_too_small;
+	}
+
+	if (buf[1] != 0x2020) {
+		printk (KERN_DEBUG "%s: Group Header #1 mismatch\n",dev->name);
+		return (-EIO);
+	}
+
+	if (buf[5] != 0x502c) {
+		printk (KERN_DEBUG "%s: Group Header #2 mismatch\n",dev->name);
+		return (-EIO);
+	}
+
+	if (buf[12] != 0x2158) {
+		printk (KERN_DEBUG "%s: Group Header #3 mismatch\n",dev->name);
+		return (-EIO);
+	}
+
+	eeprom->io_base = buf[2];
+	eeprom->irq = buf[3];
+	eeprom->dma = buf[4];
+	eeprom->mem_base = (buf[7] << 16) | buf[6];
+	eeprom->rom_base = (buf[9] << 16) | buf[8];
+	eeprom->rom_mask = (buf[11] << 16) | buf[10];
+
+	word = (u16 *) eeprom->mac;
+	for (offset = 0; offset < 3; offset++) word[offset] = buf[13 + offset];
+
+	byte = (u8 *) buf;
+	for (offset = 0; offset < sizeof (buf); offset++) checksum += byte[offset];
+
+	if (cirrus_eeprom_read (dev,&offset,0x10) < 0)
+		goto read_timed_out;
+
+	if ((offset >> 8) != (u8) (0x100 - checksum)) {
+		printk (KERN_DEBUG "%s: Checksum mismatch (expected 0x%.2x, got 0x%.2x instead\n",
+				dev->name,
+				(u8) (0x100 - checksum),
+				offset >> 8);
+		return (-EIO);
+	}
+
+	return (0);
+}
+
+/*
+ * Architecture dependant code
+ */
+
+#ifdef CONFIG_SA1100_FRODO
+static void frodo_reset (struct net_device *dev)
+{
+	int i;
+	volatile u16 value;
+
+	/* reset ethernet controller */
+	FRODO_CPLD_ETHERNET |= FRODO_ETH_RESET;
+	mdelay (50);
+	FRODO_CPLD_ETHERNET &= ~FRODO_ETH_RESET;
+	mdelay (50);
+
+	/* we tied SBHE to CHIPSEL, so each memory access ensure the chip is in 16-bit mode */
+	for (i = 0; i < 3; i++) value = cirrus_read (dev,0);
+
+	/* FIXME: poll status bit */
+}
+#endif	/* #ifdef CONFIG_SA1100_FRODO */
+
+/*
+ * Driver initialization routines
+ */
+
+static int io = 0;
+static int irq = 0;
+
+int __init cirrus_probe (struct net_device *dev)
+{
+	static cirrus_t priv;
+	int i;
+	u16 value;
+	cirrus_eeprom_t eeprom;
+	printk ("Cirrus Logic CS8900A driver for Linux (V0.02)\n");
+
+	memset (&priv,0,sizeof (cirrus_t));
+
+	ether_setup (dev);
+
+	dev->open               = cirrus_start;
+	dev->stop               = cirrus_stop;
+	dev->hard_start_xmit    = cirrus_send_start;
+	dev->get_stats          = cirrus_get_stats;
+	dev->set_multicast_list = cirrus_set_receive_mode;
+	dev->set_mac_address	= cirrus_set_mac_address;
+	dev->tx_timeout         = cirrus_transmit_timeout;
+	dev->watchdog_timeo     = HZ;
+
+#warning TODO: fix this hack
+	/* hack!! */ // 00:05:5D:DD:81:18
+	dev->dev_addr[0] = 0x00;
+	dev->dev_addr[1] = 0x00;
+	dev->dev_addr[2] = 0x02;
+	dev->dev_addr[3] = 0x50;
+	dev->dev_addr[4] = 0x10;
+	dev->dev_addr[5] = 0x08;
+
+	dev->if_port   = IF_PORT_10BASET;
+	dev->priv      = (void *) &priv;
+
+	SET_MODULE_OWNER (dev);
+
+	dev->base_addr = CIRRUS_IOADDR;
+	dev->irq = CIRRUS_IRQ;
+
+	/* module parameters override everything */
+	if (io > 0) dev->base_addr = io;
+	if (irq > 0) dev->irq = irq;
+
+	if (!dev->base_addr) {
+		printk (KERN_ERR
+				"%s: No default I/O base address defined. Use io=... or\n"
+				"%s: define CIRRUS_DEFAULT_IO for your platform\n",
+				dev->name,dev->name);
+		return (-EINVAL);
+	}
+
+	if (!dev->irq) {
+		printk (KERN_ERR
+				"%s: No default IRQ number defined. Use irq=... or\n"
+				"%s: define CIRRUS_DEFAULT_IRQ for your platform\n",
+				dev->name,dev->name);
+		return (-EINVAL);
+	}
+
+	if (!request_region (dev->base_addr,16,dev->name)) {
+		printk (KERN_ERR "%s: can't get I/O port address 0x%lx\n",dev->name,dev->base_addr);
+		return -EBUSY;
+	}
+
+#ifdef CONFIG_SA1100_FRODO
+	frodo_reset (dev);
+#endif	/* #ifdef CONFIG_SA1100_FRODO */
+
+	/* if an EEPROM is present, use it's MAC address */
+	if (!cirrus_eeprom (dev,&eeprom)) {
+		for (i = 0; i < 6; i++)
+			dev->dev_addr[i] = eeprom.mac[i];
+        }
+#if defined(CONFIG_MACH_CSB535) || defined(CONFIG_MACH_CSB536)
+        else {
+            for (i = 0; i < ETH_ALEN; i+=2) {
+                u16 val;
+                val = cirrus_read(dev, PP_IA+i);
+                dev->dev_addr[i] = val & 0xff;
+                dev->dev_addr[i+1] = (val >> 8) & 0xff;
+            }
+        }
+#endif
+	/* verify EISA registration number for Cirrus Logic */
+	if ((value = cirrus_read (dev,PP_ProductID)) != EISA_REG_CODE) {
+		printk (KERN_ERR "%s: incorrect signature 0x%.4x\n",dev->name,value);
+		return (-ENXIO);
+	}
+
+	/* verify chip version */
+	value = cirrus_read (dev,PP_ProductID + 2);
+	if (VERSION (value) != CS8900A) {
+		printk (KERN_ERR "%s: unknown chip version 0x%.8x\n",dev->name,VERSION (value));
+		return (-ENXIO);
+	}
+	printk (KERN_INFO "%s: CS8900A rev %c detected\n",dev->name,'B' + REVISION (value) - REV_B);
+
+	/* setup interrupt number */
+	cirrus_write (dev,PP_IntNum,0);
+
+	/* configure MAC address */
+	for (i = 0; i < ETH_ALEN; i += 2)
+		cirrus_write (dev,PP_IA + i,dev->dev_addr[i] | (dev->dev_addr[i + 1] << 8));
+
+	return (0);
+}
+
+static struct net_device dev;
+
+static int __init cirrus_init (void)
+{
+	memset (&dev,0,sizeof (struct net_device));
+	dev.init = cirrus_probe;
+	return (register_netdev (&dev));
+}
+
+static void __exit cirrus_cleanup (void)
+{
+	release_region (dev.base_addr,16);
+	unregister_netdev (&dev);
+}
+
+MODULE_AUTHOR ("Abraham van der Merwe <abraham@2d3d.co.za>");
+MODULE_DESCRIPTION ("Cirrus Logic CS8900A driver for Linux (V0.02)");
+MODULE_LICENSE ("GPL");
+MODULE_PARM_DESC (io,"I/O Base Address");
+MODULE_PARM (io,"i");
+MODULE_PARM_DESC (irq,"IRQ Number");
+MODULE_PARM (irq,"i");
+
+module_init (cirrus_init);
+module_exit (cirrus_cleanup);
+
diff -NaurbB linux-2.6.14_original/drivers/net/cirrus.h linux-2.6.14_imx21/drivers/net/cirrus.h
--- linux-2.6.14_original/drivers/net/cirrus.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/drivers/net/cirrus.h	2006-04-11 10:29:12.000000000 +0200
@@ -0,0 +1,331 @@
+#ifndef CIRRUS_H
+#define CIRRUS_H
+
+/*
+ * linux/drivers/net/cirrus.h
+ *
+ * Author: Abraham van der Merwe <abraham@2d3d.co.za>
+ *
+ * A Cirrus Logic CS8900A driver for Linux
+ * based on the cs89x0 driver written by Russell Nelson,
+ * Donald Becker, and others.
+ *
+ * This source code is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ */
+
+/*
+ * Ports
+ */
+
+#define PP_Address		0x0a	/* PacketPage Pointer Port (Section 4.10.10) */
+#define PP_Data			0x0c	/* PacketPage Data Port (Section 4.10.10) */
+
+/*
+ * Registers
+ */
+
+#define PP_ProductID		0x0000	/* Section 4.3.1   Product Identification Code */
+#define PP_MemBase			0x002c	/* Section 4.9.2   Memory Base Address Register */
+#define PP_IntNum			0x0022	/* Section 3.2.3   Interrupt Number */
+#define PP_EEPROMCommand	0x0040	/* Section 4.3.11  EEPROM Command */
+#define PP_EEPROMData		0x0042	/* Section 4.3.12  EEPROM Data */
+#define PP_RxCFG			0x0102	/* Section 4.4.6   Receiver Configuration */
+#define PP_RxCTL			0x0104	/* Section 4.4.8   Receiver Control */
+#define PP_TxCFG			0x0106	/* Section 4.4.9   Transmit Configuration */
+#define PP_BufCFG			0x010a	/* Section 4.4.12  Buffer Configuration */
+#define PP_LineCTL			0x0112	/* Section 4.4.16  Line Control */
+#define PP_SelfCTL			0x0114	/* Section 4.4.18  Self Control */
+#define PP_BusCTL			0x0116	/* Section 4.4.20  Bus Control */
+#define PP_TestCTL			0x0118	/* Section 4.4.22  Test Control */
+#define PP_ISQ				0x0120	/* Section 4.4.5   Interrupt Status Queue */
+#define PP_TxEvent			0x0128	/* Section 4.4.10  Transmitter Event */
+#define PP_BufEvent			0x012c	/* Section 4.4.13  Buffer Event */
+#define PP_RxMISS			0x0130	/* Section 4.4.14  Receiver Miss Counter */
+#define PP_TxCOL			0x0132	/* Section 4.4.15  Transmit Collision Counter */
+#define PP_SelfST			0x0136	/* Section 4.4.19  Self Status */
+#define PP_BusST			0x0138	/* Section 4.4.21  Bus Status */
+#define PP_TxCMD			0x0144	/* Section 4.4.11  Transmit Command */
+#define PP_TxLength			0x0146	/* Section 4.5.2   Transmit Length */
+#define PP_IA				0x0158	/* Section 4.6.2   Individual Address (IEEE Address) */
+#define PP_RxStatus			0x0400	/* Section 4.7.1   Receive Status */
+#define PP_RxLength			0x0402	/* Section 4.7.1   Receive Length (in bytes) */
+#define PP_RxFrame			0x0404	/* Section 4.7.2   Receive Frame Location */
+#define PP_TxFrame			0x0a00	/* Section 4.7.2   Transmit Frame Location */
+
+/*
+ * Values
+ */
+
+/* PP_IntNum */
+#define INTRQ0			0x0000
+#define INTRQ1			0x0001
+#define INTRQ2			0x0002
+#define INTRQ3			0x0003
+
+/* PP_ProductID */
+#define EISA_REG_CODE	0x630e
+#define REVISION(x)		(((x) & 0x1f00) >> 8)
+#define VERSION(x)		((x) & ~0x1f00)
+
+#define CS8900A			0x0000
+#define REV_B			7
+#define REV_C			8
+#define REV_D			9
+
+/* PP_RxCFG */
+#define Skip_1			0x0040
+#define StreamE			0x0080
+#define RxOKiE			0x0100
+#define RxDMAonly		0x0200
+#define AutoRxDMAE		0x0400
+#define BufferCRC		0x0800
+#define CRCerroriE		0x1000
+#define RuntiE			0x2000
+#define ExtradataiE		0x4000
+
+/* PP_RxCTL */
+#define IAHashA			0x0040
+#define PromiscuousA	0x0080
+#define RxOKA			0x0100
+#define MulticastA		0x0200
+#define IndividualA		0x0400
+#define BroadcastA		0x0800
+#define CRCerrorA		0x1000
+#define RuntA			0x2000
+#define ExtradataA		0x4000
+
+/* PP_TxCFG */
+#define Loss_of_CRSiE	0x0040
+#define SQErroriE		0x0080
+#define TxOKiE			0x0100
+#define Out_of_windowiE	0x0200
+#define JabberiE		0x0400
+#define AnycolliE		0x0800
+#define T16colliE		0x8000
+
+/* PP_BufCFG */
+#define SWint_X			0x0040
+#define RxDMAiE			0x0080
+#define Rdy4TxiE		0x0100
+#define TxUnderruniE	0x0200
+#define RxMissiE		0x0400
+#define Rx128iE			0x0800
+#define TxColOvfiE		0x1000
+#define MissOvfloiE		0x2000
+#define RxDestiE		0x8000
+
+/* PP_LineCTL */
+#define SerRxON			0x0040
+#define SerTxON			0x0080
+#define AUIonly			0x0100
+#define AutoAUI_10BT	0x0200
+#define ModBackoffE		0x0800
+#define PolarityDis		0x1000
+#define L2_partDefDis	0x2000
+#define LoRxSquelch		0x4000
+
+/* PP_SelfCTL */
+#define RESET			0x0040
+#define SWSuspend		0x0100
+#define HWSleepE		0x0200
+#define HWStandbyE		0x0400
+#define HC0E			0x1000
+#define HC1E			0x2000
+#define HCB0			0x4000
+#define HCB1			0x8000
+
+/* PP_BusCTL */
+#define ResetRxDMA		0x0040
+#define DMAextend		0x0100
+#define UseSA			0x0200
+#define MemoryE			0x0400
+#define DMABurst		0x0800
+#define IOCHRDYE		0x1000
+#define RxDMAsize		0x2000
+#define EnableRQ		0x8000
+
+/* PP_TestCTL */
+#define DisableLT		0x0080
+#define ENDECloop		0x0200
+#define AUIloop			0x0400
+#define DisableBackoff	0x0800
+#define FDX				0x4000
+
+/* PP_ISQ */
+#define RegNum(x) ((x) & 0x3f)
+#define RegContent(x) ((x) & ~0x3d)
+
+#define RxEvent			0x0004
+#define TxEvent			0x0008
+#define BufEvent		0x000c
+#define RxMISS			0x0010
+#define TxCOL			0x0012
+
+/* PP_RxStatus */
+#define IAHash			0x0040
+#define Dribblebits		0x0080
+#define RxOK			0x0100
+#define Hashed			0x0200
+#define IndividualAdr	0x0400
+#define Broadcast		0x0800
+#define CRCerror		0x1000
+#define Runt			0x2000
+#define Extradata		0x4000
+
+#define HashTableIndex(x) ((x) >> 0xa)
+
+/* PP_TxCMD */
+#define After5			0
+#define After381		1
+#define After1021		2
+#define AfterAll		3
+#define TxStart(x) ((x) << 6)
+
+#define Force			0x0100
+#define Onecoll			0x0200
+#define InhibitCRC		0x1000
+#define TxPadDis		0x2000
+
+/* PP_BusST */
+#define TxBidErr		0x0080
+#define Rdy4TxNOW		0x0100
+
+/* PP_TxEvent */
+#define Loss_of_CRS		0x0040
+#define SQEerror		0x0080
+#define TxOK			0x0100
+#define Out_of_window	0x0200
+#define Jabber			0x0400
+#define T16coll			0x8000
+
+#define TX_collisions(x) (((x) >> 0xb) & ~0x8000)
+
+/* PP_BufEvent */
+#define SWint			0x0040
+#define RxDMAFrame		0x0080
+#define Rdy4Tx			0x0100
+#define TxUnderrun		0x0200
+#define RxMiss			0x0400
+#define Rx128			0x0800
+#define RxDest			0x8000
+
+/* PP_RxMISS */
+#define MissCount(x) ((x) >> 6)
+
+/* PP_TxCOL */
+#define ColCount(x) ((x) >> 6)
+
+/* PP_SelfST */
+#define T3VActive		0x0040
+#define INITD			0x0080
+#define SIBUSY			0x0100
+#define EEPROMpresent	0x0200
+#define EEPROMOK		0x0400
+#define ELpresent		0x0800
+#define EEsize			0x1000
+
+/* PP_EEPROMCommand */
+#define EEWriteRegister	0x0100
+#define EEReadRegister	0x0200
+#define EEEraseRegister	0x0300
+#define ELSEL			0x0400
+
+
+/* --------------- Set Hardware Capabilities for CSB226 and CSB625 -------- */
+
+#if defined(CONFIG_ARCH_CSB226) || defined(CONFIG_MACH_CSB625) || defined(CONFIG_MACH_CSB535) || defined(CONFIG_MACH_CSB536) 
+
+#if defined(CONFIG_ARCH_CSB226)
+#  include <asm/arch/csb226.h>
+#elif defined(CONFIG_MACH_CSB625)
+#  include <asm/arch/csb625.h>
+#elif defined(CONFIG_MACH_CSB535)
+#  include <asm/arch/csb535.h>
+#elif defined(CONFIG_MACH_CSB536)
+#  include <asm/arch/csb536.h>
+#endif
+
+
+#define CIRRUS_inw(a, r)		readw((a) + (r*0x02))
+#define CIRRUS_outw(v, a, r)		writew(v, (a) + (r*0x02))
+#define CIRRUS_insw(a, r, p, l)		insw((a) + (r*0x02), p, l)
+#define CIRRUS_outsw(a, r, p, l)	outsw((a) + (r*0x02), p, l)
+
+#if defined(CONFIG_ARCH_CSB226)
+#  define CIRRUS_IOADDR			(CSB226_ETH_VIRT + 0x300)
+#  define CIRRUS_IRQ			CSB226_ETH_IRQ
+#elif defined(CONFIG_MACH_CSB625)
+#  define CIRRUS_IOADDR			(CSB625_ETH_VIRT + 0x300)
+#  define CIRRUS_IRQ			CSB625_ETH_IRQ
+#elif defined(CONFIG_MACH_CSB535)
+#  define CIRRUS_IOADDR			(CSB535_ETH_VIRT + 0x300)
+#  define CIRRUS_IRQ			CSB535_ETH_IRQ
+#elif defined(CONFIG_MACH_CSB536)
+#  define CIRRUS_IOADDR			(CSB536_ETH_VIRT + 0x300)
+#  define CIRRUS_IRQ			CSB536_ETH_IRQ
+#endif
+
+/* -------------------- Set Hardware Capabilities for frodo --------------- */
+
+#elif defined(CONFIG_SA1100_FRODO)
+
+#define CIRRUS_inb(a, r)		inb((a) + (r))
+#define CIRRUS_inw(a, r)		inw((a) + (r))
+#define CIRRUS_outb(v, a, r)		outb(v, (a) + (r))
+#define CIRRUS_outw(v, a, r)            outw(v, (a) + (r))
+#define CIRRUS_insw(a, r, p, l)		insw((a) + (r), p, l)
+#define CIRRUS_outsw(a, r, p, l)	outsw((a) + (r), p, l)
+
+#define CIRRUS_IOADDR			(FRODO_ETH_IO + 0x300)
+#define CIRRUS_IRQ			FRODO_ETH_IRQ
+
+/* -------------------- Set Hardware Capabilities for cerf ---------------- */
+
+#elif defined(CONFIG_SA1100_CERF)
+
+#define CIRRUS_inb(a, r)		inb((a) + (r))
+#define CIRRUS_inw(a, r)		inw((a) + (r))
+#define CIRRUS_outb(v, a, r)		outb(v, (a) + (r))
+#define CIRRUS_outw(v, a, r)            outw(v, (a) + (r))
+#define CIRRUS_insw(a, r, p, l)		insw((a) + (r), p, l)
+#define CIRRUS_outsw(a, r, p, l)	outsw((a) + (r), p, l)
+
+#define CIRRUS_IOADDR			(CERF_ETH_IO + 0x300)
+#define CIRRUS_IRQ			CERF_ETH_IRQ
+
+/* -------------------- Set Hardware Capabilities for CDB89712 ------------ */
+
+#elif defined(CONFIG_ARCH_CDB89712)
+
+#define CIRRUS_inb(a, r)		inb((a) + (r))
+#define CIRRUS_inw(a, r)		inw((a) + (r))
+#define CIRRUS_outb(v, a, r)		outb(v, (a) + (r))
+#define CIRRUS_outw(v, a, r)            outw(v, (a) + (r))
+#define CIRRUS_insw(a, r, p, l)		insw((a) + (r), p, l)
+#define CIRRUS_outsw(a, r, p, l)	outsw((a) + (r), p, l)
+
+#define CIRRUS_IOADDR			(ETHER_BASE + 0x300)
+#define CIRRUS_IRQ			IRQ_EINT3
+
+/* -------------------- ISA ----------------------------------------------- */
+
+#elif defined(CONFIG_ISA)
+
+#define CIRRUS_inb(a, r)		inb((a) + (r))
+#define CIRRUS_inw(a, r)		inw((a) + (r))
+#define CIRRUS_outb(v, a, r)		outb(v, (a) + (r))
+#define CIRRUS_outw(v, a, r)            outw(v, (a) + (r))
+#define CIRRUS_insw(a, r, p, l)		insw((a) + (r), p, l)
+#define CIRRUS_outsw(a, r, p, l)	outsw((a) + (r), p, l)
+
+#define CIRRUS_IOADDR			0
+#define CIRRUS_IRQ			0
+
+#else
+#error "FIXME..."
+#endif
+
+#endif	/* #ifndef CIRRUS_H */
+
diff -NaurbB linux-2.6.14_original/drivers/net/Kconfig linux-2.6.14_imx21/drivers/net/Kconfig
--- linux-2.6.14_original/drivers/net/Kconfig	2005-10-28 02:02:08.000000000 +0200
+++ linux-2.6.14_imx21/drivers/net/Kconfig	2006-04-11 11:32:15.000000000 +0200
@@ -2,6 +1,12 @@
 #
 # Network device configuration
 #
+# March 2006 :
+# Adapted to ARM9 i.MX21/CSB535FS board by S.Gerber, G.Boutillier and D.Rossier
+# University of Applied Sciences Western Switzerland
+# Reconfigurable & Embedded Digital Systems, REDS Institute
+#
+#
 
 menu "Network device support"
 
@@ -307,6 +312,16 @@
 	  <file:Documentation/networking/net-modules.txt>.  This module will
 	  be called mac89x0.
 
+config CIRRUS
+       tristate "CS89x support (Cirrus driver)"
+       depends on (MACH_CSB625 || ARCH_CSB226 || MACH_CSB536 || MACH_CSB535)
+       ---help---
+         There are two drivers for Cirrus Logic CS89x0 devices.  This
+         driver seems to work better than the generic CS89x0 driver 
+         on ARM targets.  If you have a Cogent CSB226, CSB535,
+         CSB536, or CSB226 and you want to use the cs89x0 chip
+         present on those machines, select Y.
+
 config MACSONIC
 	tristate "Macintosh SONIC based ethernet (onboard, NuBus, LC, CS)"
 	depends on NET_ETHERNET && MAC
diff -NaurbB linux-2.6.14_original/drivers/net/Makefile linux-2.6.14_imx21/drivers/net/Makefile
--- linux-2.6.14_original/drivers/net/Makefile	2005-10-28 02:02:08.000000000 +0200
+++ linux-2.6.14_imx21/drivers/net/Makefile	2006-04-11 11:32:35.000000000 +0200
@@ -1,6 +1,12 @@
 #
 # Makefile for the Linux network (ethercard) device drivers.
 #
+# March 2006 :
+# Adapted to ARM9 i.MX21/CSB535FS board by S.Gerber, G.Boutillier and D.Rossier
+# University of Applied Sciences Western Switzerland
+# Reconfigurable & Embedded Digital Systems, REDS Institute
+#
+#
 
 ifeq ($(CONFIG_ISDN_PPP),y)
   obj-$(CONFIG_ISDN) += slhc.o
@@ -178,6 +184,7 @@
 obj-$(CONFIG_MACSONIC) += macsonic.o
 obj-$(CONFIG_MACMACE) += macmace.o
 obj-$(CONFIG_MAC89x0) += mac89x0.o
+obj-$(CONFIG_CIRRUS) += cirrus.o
 obj-$(CONFIG_TUN) += tun.o
 obj-$(CONFIG_DL2K) += dl2k.o
 obj-$(CONFIG_R8169) += r8169.o
diff -NaurbB linux-2.6.14_original/drivers/serial/imx21.c linux-2.6.14_imx21/drivers/serial/imx21.c
--- linux-2.6.14_original/drivers/serial/imx21.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/drivers/serial/imx21.c	2006-04-11 10:29:12.000000000 +0200
@@ -0,0 +1,1002 @@
+/*
+ *  linux/drivers/serial/imx21.c
+ *
+ *  Driver for Motorola IMX serial ports
+ *
+ *  Based on drivers/char/serial.c, by Linus Torvalds, Theodore Ts'o.
+ *
+ *  Author: Sascha Hauer <sascha@saschahauer.de>
+ *  Copyright (C) 2004 Pengutronix
+ *
+ *  Modified by: Stephen Donecker (sdonecker@sbcglobal.net)
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#include <linux/config.h>
+
+#if defined(CONFIG_SERIAL_IMX_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/device.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/hardware.h>
+
+/* We've been assigned a range on the "Low-density serial ports" major */
+#define SERIAL_IMX_MAJOR	204
+#define MINOR_START		41
+
+#define NR_PORTS		2
+
+#define IMX_ISR_PASS_LIMIT	256
+
+/*
+ * This is the size of our serial port register set.
+ */
+#define UART_PORT_SIZE	0x100
+
+/*
+ * This determines how often we check the modem status signals
+ * for any change.  They generally aren't connected to an IRQ
+ * so we have to poll them.  We also check immediately before
+ * filling the TX fifo incase CTS has been dropped.
+ */
+#define MCTRL_TIMEOUT	(250*HZ/1000)
+
+#define DRIVER_NAME "IMX-uart"
+
+struct imx_port {
+	struct uart_port	port;
+#warning "Removed by JTM"
+//	struct timer_list	timer;
+	unsigned int		old_status;
+	int			irq;
+};
+
+/*
+ * Handle any change of modem status signal since we were last called.
+ */
+static void imx_mctrl_check(struct imx_port *sport)
+{
+	unsigned int status, changed;
+
+	status = sport->port.ops->get_mctrl(&sport->port);
+	changed = status ^ sport->old_status;
+
+	if (changed == 0)
+		return;
+
+	sport->old_status = status;
+
+	if (changed & TIOCM_RI)
+		sport->port.icount.rng++;
+	if (changed & TIOCM_DSR)
+		sport->port.icount.dsr++;
+	if (changed & TIOCM_CAR)
+		uart_handle_dcd_change(&sport->port, status & TIOCM_CAR);
+	if (changed & TIOCM_CTS)
+		uart_handle_cts_change(&sport->port, status & TIOCM_CTS);
+
+	wake_up_interruptible(&sport->port.info->delta_msr_wait);
+}
+
+/*
+ * This is our per-port timeout handler, for checking the
+ * modem status signals.
+ */
+static void imx_timeout(unsigned long data)
+{
+	struct imx_port *sport = (struct imx_port *)data;
+	unsigned long flags;
+
+	if (sport->port.info) {
+		spin_lock_irqsave(&sport->port.lock, flags);
+		imx_mctrl_check(sport);
+		spin_unlock_irqrestore(&sport->port.lock, flags);
+
+#warning "Removed by JTM"
+//		mod_timer(&sport->timer, jiffies + MCTRL_TIMEOUT);
+	}
+}
+
+/*
+ * interrupts disabled on entry
+ */
+static void imx_stop_tx(struct uart_port *port, unsigned int tty_stop)
+{
+	struct imx_port *sport = (struct imx_port *)port;
+	UCR1((u32)sport->port.membase) &= ~UCR1_TXMPTYEN;
+}
+
+/*
+ * interrupts disabled on entry
+ */
+static void imx_stop_rx(struct uart_port *port)
+{
+	struct imx_port *sport = (struct imx_port *)port;
+	UCR2((u32)sport->port.membase) &= ~UCR2_RXEN;
+}
+
+/*
+ * Set the modem control timer to fire immediately.
+ */
+static void imx_enable_ms(struct uart_port *port)
+{
+	struct imx_port *sport = (struct imx_port *)port;
+
+#warning "Removed by JTM"
+//	mod_timer(&sport->timer, jiffies);
+}
+
+static inline void imx_transmit_buffer(struct imx_port *sport)
+{
+	struct circ_buf *xmit = &sport->port.info->xmit;
+
+	do {
+		/* send xmit->buf[xmit->tail]
+		 * out the port here */
+		URTX0((u32)sport->port.membase) = xmit->buf[xmit->tail];
+		xmit->tail = (xmit->tail + 1) &
+		         (UART_XMIT_SIZE - 1);
+		sport->port.icount.tx++;
+		if (uart_circ_empty(xmit))
+			break;
+	} while (!(UTS((u32)sport->port.membase) & UTS_TXFULL));
+
+	if (uart_circ_empty(xmit))
+		imx_stop_tx(&sport->port, 0);
+}
+
+/*
+ * interrupts disabled on entry
+ */
+static void imx_start_tx(struct uart_port *port, unsigned int tty_start)
+{
+	struct imx_port *sport = (struct imx_port *)port;
+
+	UCR1((u32)sport->port.membase) |= UCR1_TXMPTYEN;
+
+	if(UTS((u32)sport->port.membase) & UTS_TXEMPTY)
+		imx_transmit_buffer(sport);
+}
+
+static irqreturn_t imx_txint(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct imx_port *sport = (struct imx_port *)dev_id;
+	struct circ_buf *xmit = &sport->port.info->xmit;
+	unsigned long flags;
+	
+	spin_lock_irqsave(&sport->port.lock,flags);
+	if (sport->port.x_char)
+	{
+		/* Send next char */
+		URTX0((u32)sport->port.membase) = sport->port.x_char;
+		goto out;
+	}
+
+	if (uart_circ_empty(xmit) || uart_tx_stopped(&sport->port)) {
+		imx_stop_tx(&sport->port, 0);
+		goto out;
+	}
+
+	imx_transmit_buffer(sport);
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(&sport->port);
+
+out:
+	spin_unlock_irqrestore(&sport->port.lock,flags);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t imx_rxint(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct imx_port *sport = dev_id;
+	unsigned int rx,flg,ignored = 0;
+	struct tty_struct *tty = sport->port.info->tty;
+	unsigned long flags;
+
+	rx = URXD0((u32)sport->port.membase);
+	spin_lock_irqsave(&sport->port.lock,flags);
+
+	do {
+		flg = TTY_NORMAL;
+		sport->port.icount.rx++;
+
+		if( USR2((u32)sport->port.membase) & USR2_BRCD ) {
+			USR2((u32)sport->port.membase) |= USR2_BRCD;
+			if(uart_handle_break(&sport->port))
+				goto ignore_char;
+		}
+
+		if (uart_handle_sysrq_char
+		            (&sport->port, (unsigned char)rx, regs))
+			goto ignore_char;
+
+		if( rx & (URXD_PRERR | URXD_OVRRUN | URXD_FRMERR) )
+			goto handle_error;
+
+	error_return:
+		tty_insert_flip_char(tty, rx, flg);
+
+		if (tty->flip.count >= TTY_FLIPBUF_SIZE)
+			goto out;
+
+	ignore_char:
+		rx = URXD0((u32)sport->port.membase);
+	} while(rx & URXD_CHARRDY);
+
+out:
+	spin_unlock_irqrestore(&sport->port.lock,flags);
+	tty_flip_buffer_push(tty);
+	return IRQ_HANDLED;
+
+handle_error:
+	if (rx & URXD_PRERR)
+		sport->port.icount.parity++;
+	else if (rx & URXD_FRMERR)
+		sport->port.icount.frame++;
+	if (rx & URXD_OVRRUN)
+		sport->port.icount.overrun++;
+
+	if (rx & sport->port.ignore_status_mask) {
+		if (++ignored > 100)
+			goto out;
+		goto ignore_char;
+	}
+
+	rx &= sport->port.read_status_mask;
+
+	if (rx & URXD_PRERR)
+		flg = TTY_PARITY;
+	else if (rx & URXD_FRMERR)
+		flg = TTY_FRAME;
+	if (rx & URXD_OVRRUN)
+		flg = TTY_OVERRUN;
+
+#ifdef SUPPORT_SYSRQ
+	sport->port.sysrq = 0;
+#endif
+	goto error_return;
+}
+
+/*
+ * Determine if this is a TX or RX int, call appropriate handler
+ */
+static irqreturn_t imx21_int(int irq, void *dev_id, struct pt_regs *regs)
+{
+    	struct imx_port *sport = dev_id;
+
+	if ( USR1((u32)sport->port.membase) & USR1_TRDY )
+	    imx_txint(irq, dev_id, regs);
+	if ( USR1((u32)sport->port.membase) & USR1_RRDY )
+	    imx_rxint(irq, dev_id, regs);
+	return IRQ_HANDLED;
+}
+
+/*
+ * Return TIOCSER_TEMT when transmitter is not busy.
+ */
+static unsigned int imx_tx_empty(struct uart_port *port)
+{
+	struct imx_port *sport = (struct imx_port *)port;
+
+	return USR2((u32)sport->port.membase) & USR2_TXDC ?  TIOCSER_TEMT : 0;
+}
+
+static unsigned int imx_get_mctrl(struct uart_port *port)
+{
+	return TIOCM_CTS | TIOCM_DSR | TIOCM_CAR;
+}
+
+static void imx_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+}
+
+/*
+ * Interrupts always disabled.
+ */
+static void imx_break_ctl(struct uart_port *port, int break_state)
+{
+	struct imx_port *sport = (struct imx_port *)port;
+	unsigned long flags;
+
+	spin_lock_irqsave(&sport->port.lock, flags);
+
+	if ( break_state != 0 )
+		UCR1((u32)sport->port.membase) |= UCR1_SNDBRK;
+	else
+		UCR1((u32)sport->port.membase) &= ~UCR1_SNDBRK;
+
+	spin_unlock_irqrestore(&sport->port.lock, flags);
+}
+
+#define TXTL 2 /* reset default */
+#define RXTL 1 /* reset default */
+
+static int imx_startup(struct uart_port *port)
+{
+	struct imx_port *sport = (struct imx_port *)port;
+	int retval;
+	unsigned int val;
+	unsigned long flags;
+	
+	/* set receiver / transmitter trigger level. We assume
+	 * that RFDIV has been set by the arch setup or by the bootloader.
+	 */
+	val = (UFCR((u32)sport->port.membase) & UFCR_RFDIV)  | TXTL<<10 | RXTL;
+	UFCR((u32)sport->port.membase) = val;
+;
+	/* disable the DREN bit (Data Ready interrupt enable) before
+	 * requesting IRQs
+	 */
+	UCR4((u32)sport->port.membase) &= ~UCR4_DREN;
+
+	/*
+	 * Allocate the IRQ
+	 */
+	retval = request_irq(sport->irq, imx21_int, 0,
+			     DRIVER_NAME, sport);
+	if (retval) {
+	        free_irq(sport->irq, sport);
+	        return retval;
+	}
+	
+
+	/*
+	 * Finally, clear and enable interrupts
+	 */
+
+	UCR1((u32)sport->port.membase) |=
+	                 (UCR1_TXMPTYEN | UCR1_RRDYEN | UCR1_UARTEN);
+
+	UCR2((u32)sport->port.membase) |= (UCR2_RXEN | UCR2_TXEN);
+	/*
+	 * Enable modem status interrupts
+	 */
+	spin_lock_irqsave(&sport->port.lock,flags);
+	imx_enable_ms(&sport->port);
+	spin_unlock_irqrestore(&sport->port.lock,flags);
+
+	return 0;
+
+}
+
+static void imx_shutdown(struct uart_port *port)
+{
+	struct imx_port *sport = (struct imx_port *)port;
+
+	/*
+	 * Stop our timer.
+	 */
+#warning "Removed by JTM"
+//	del_timer_sync(&sport->timer);
+
+	/*
+	 * Free the interrupts
+	 */
+	free_irq(sport->irq, sport);
+
+	/*
+	 * Disable all interrupts, port and break condition.
+	 */
+
+	UCR1((u32)sport->port.membase) &=
+	                 ~(UCR1_TXMPTYEN | UCR1_RRDYEN | UCR1_UARTEN);
+}
+
+static void
+imx_set_termios(struct uart_port *port, struct termios *termios,
+		   struct termios *old)
+{
+	struct imx_port *sport = (struct imx_port *)port;
+	unsigned long flags;
+	unsigned int ucr2, old_ucr1, old_txrxen, baud, quot;
+	unsigned int old_csize = old ? old->c_cflag & CSIZE : CS8;
+
+	/*
+	 * If we don't support modem control lines, don't allow
+	 * these to be set.
+	 */
+	if (0) {
+		termios->c_cflag &= ~(HUPCL | CRTSCTS | CMSPAR);
+		termios->c_cflag |= CLOCAL;
+	}
+
+	/*
+	 * We only support CS7 and CS8.
+	 */
+	while ((termios->c_cflag & CSIZE) != CS7 &&
+	       (termios->c_cflag & CSIZE) != CS8) {
+		termios->c_cflag &= ~CSIZE;
+		termios->c_cflag |= old_csize;
+		old_csize = CS8;
+	}
+
+	if ((termios->c_cflag & CSIZE) == CS8)
+		ucr2 = UCR2_WS | UCR2_SRST | UCR2_IRTS;
+	else
+		ucr2 = UCR2_SRST | UCR2_IRTS;
+
+	if (termios->c_cflag & CSTOPB)
+		ucr2 |= UCR2_STPB;
+	if (termios->c_cflag & PARENB) {
+		ucr2 |= UCR2_PREN;
+		if (!(termios->c_cflag & PARODD))
+			ucr2 |= UCR2_PROE;
+	}
+
+	/*
+	 * Ask the core to calculate the divisor for us.
+	 */
+	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16);
+	quot = uart_get_divisor(port, baud);
+
+	spin_lock_irqsave(&sport->port.lock, flags);
+
+	sport->port.read_status_mask = 0;
+	if (termios->c_iflag & INPCK)
+		sport->port.read_status_mask |= (URXD_FRMERR | URXD_PRERR);
+	if (termios->c_iflag & (BRKINT | PARMRK))
+		sport->port.read_status_mask |= URXD_BRK;
+
+	/*
+	 * Characters to ignore
+	 */
+	sport->port.ignore_status_mask = 0;
+	if (termios->c_iflag & IGNPAR)
+		sport->port.ignore_status_mask |= URXD_PRERR;
+	if (termios->c_iflag & IGNBRK) {
+		sport->port.ignore_status_mask |= URXD_BRK;
+		/*
+		 * If we're ignoring parity and break indicators,
+		 * ignore overruns too (for real raw support).
+		 */
+		if (termios->c_iflag & IGNPAR)
+			sport->port.ignore_status_mask |= URXD_OVRRUN;
+	}
+
+#warning "Removed by JTM"
+//	del_timer_sync(&sport->timer);
+
+	/*
+	 * Update the per-port timeout.
+	 */
+	uart_update_timeout(port, termios->c_cflag, baud);
+
+	/*
+	 * disable interrupts and drain transmitter
+	 */
+	old_ucr1 = UCR1((u32)sport->port.membase);
+	UCR1((u32)sport->port.membase) &= ~(UCR1_TXMPTYEN | UCR1_RRDYEN);
+
+	while ( !(USR2((u32)sport->port.membase) & USR2_TXDC))
+		barrier();
+
+	/* then, disable everything */
+	old_txrxen = UCR2((u32)sport->port.membase) & ( UCR2_TXEN | UCR2_RXEN );
+	UCR2((u32)sport->port.membase) &= ~( UCR2_TXEN | UCR2_RXEN);
+
+	/* set the parity, stop bits and data size */
+	UCR2((u32)sport->port.membase) = ucr2;
+
+#if 0
+	{
+	    int rfdiv;
+	    int perclk1 = imx_get_perclk1();
+	    int uartclk;
+	    printk("baud was set to %d\n", baud);
+	    
+	    rfdiv =  (((UFCR((u32)sport->port.membase)) & UFCR_RFDIV)
+		      >> UFCR_RFDIV_SHF) ;
+	    
+	
+	    printk("sysclk=%d HZ\n", imx_get_system_clk());
+	    printk("clk1=%d HZ\n", perclk1);
+	
+	    printk("RFDIV=%d\n", rfdiv);
+	    uartclk = perclk1/rfdiv;
+	    printk("ref freq = %d\n", uartclk);
+	    printk("PCDR:5:0 = %d\n", PCDR1 & 0x3f);
+	    
+	}
+	
+
+#endif	
+	/* set the baud rate. We assume uartclk = 16 MHz
+	 *
+	 * baud * 16   UBIR - 1
+	 * --------- = --------
+	 *  uartclk    UBMR - 1
+	 */
+	// UBIR((u32)sport->port.membase) = (baud / 100) - 1;
+	// UBMR((u32)sport->port.membase) = 10000 - 1;
+#if 0
+#define BIR_115200	837
+#define BIR_DIV		9999
+	/*  I cant figure out why these numbers work, so using this formula
+	 *  and above numbers, I solved for uartclk and got
+	 *  22,995,227. Looks like it should be 11,998,549 (pclk1/4)???
+	 */
+#else
+#define BIR_DIV		999
+#define UCLK		22995227
+#define BIR(br)	(((16 * (br) * (BIR_DIV+1))/UCLK) + 1)
+#endif
+
+#warning "Changed by JTM"
+//	UBIR((u32)sport->port.membase) = BIR(baud);
+//	UBMR((u32)sport->port.membase) = BIR_DIV;
+	//	    UBIR((u32)sport->port.membase) = BIR_115200;
+	//	    UBMR((u32)sport->port.membase) = BIR_DIV;
+
+	UCR1((u32)sport->port.membase) = old_ucr1;
+	UCR2((u32)sport->port.membase) |= old_txrxen;
+
+	if (UART_ENABLE_MS(&sport->port, termios->c_cflag))
+		imx_enable_ms(&sport->port);
+
+	spin_unlock_irqrestore(&sport->port.lock, flags);
+}
+
+static const char *imx_type(struct uart_port *port)
+{
+	struct imx_port *sport = (struct imx_port *)port;
+
+	return sport->port.type == PORT_IMX ? "IMX" : NULL;
+}
+
+/*
+ * Release the memory region(s) being used by 'port'.
+ */
+static void imx_release_port(struct uart_port *port)
+{
+	struct imx_port *sport = (struct imx_port *)port;
+
+	release_mem_region(sport->port.mapbase, UART_PORT_SIZE);
+}
+
+/*
+ * Request the memory region(s) being used by 'port'.
+ */
+static int imx_request_port(struct uart_port *port)
+{
+	struct imx_port *sport = (struct imx_port *)port;
+
+	return request_mem_region(sport->port.mapbase, UART_PORT_SIZE,
+			"imx-uart") != NULL ? 0 : -EBUSY;
+}
+
+/*
+ * Configure/autoconfigure the port.
+ */
+static void imx_config_port(struct uart_port *port, int flags)
+{
+	struct imx_port *sport = (struct imx_port *)port;
+
+	if (flags & UART_CONFIG_TYPE &&
+	    imx_request_port(&sport->port) == 0)
+		sport->port.type = PORT_IMX;
+}
+
+/*
+ * Verify the new serial_struct (for TIOCSSERIAL).
+ * The only change we allow are to the flags and type, and
+ * even then only between PORT_IMX and PORT_UNKNOWN
+ */
+static int
+imx_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	struct imx_port *sport = (struct imx_port *)port;
+	int ret = 0;
+	
+	if (ser->type != PORT_UNKNOWN && ser->type != PORT_IMX)
+		ret = -EINVAL;
+	if (sport->port.irq != ser->irq)
+		ret = -EINVAL;
+	if (ser->io_type != UPIO_MEM)
+		ret = -EINVAL;
+	if (sport->port.uartclk / 16 != ser->baud_base)
+		ret = -EINVAL;
+	if ((void *)sport->port.mapbase != ser->iomem_base)
+		ret = -EINVAL;
+	if (sport->port.iobase != ser->port)
+		ret = -EINVAL;
+	if (ser->hub6 != 0)
+		ret = -EINVAL;
+	return ret;
+}
+
+static struct uart_ops imx_pops = {
+	.tx_empty	= imx_tx_empty,
+	.set_mctrl	= imx_set_mctrl,
+	.get_mctrl	= imx_get_mctrl,
+	.stop_tx	= imx_stop_tx,
+	.start_tx	= imx_start_tx,
+	.stop_rx	= imx_stop_rx,
+	.enable_ms	= imx_enable_ms,
+	.break_ctl	= imx_break_ctl,
+	.startup	= imx_startup,
+	.shutdown	= imx_shutdown,
+	.set_termios	= imx_set_termios,
+	.type		= imx_type,
+	.release_port	= imx_release_port,
+	.request_port	= imx_request_port,
+	.config_port	= imx_config_port,
+	.verify_port	= imx_verify_port,
+};
+
+static struct imx_port imx_ports[] = {
+	{
+	.irq  = INT_UART1,
+	.port	= {
+		.type		= PORT_IMX,
+		.iotype		= SERIAL_IO_MEM,
+		.membase	= (void *)MX2ADS_UART1_BASE,
+		.mapbase	= MX2ADS_UART1_BASE, /* FIXME */
+		.irq		= INT_UART1,
+		.uartclk	= 16000000,
+		.fifosize	= 8,
+		.flags		= ASYNC_BOOT_AUTOCONF,
+		.ops		= &imx_pops,
+		.line		= 0,
+	},
+	}, {
+	.irq  = INT_UART2,
+	.port	= {
+		.type		= PORT_IMX,
+		.iotype		= SERIAL_IO_MEM,
+		.membase	= (void *)MX2ADS_UART2_BASE,
+		.mapbase	= MX2ADS_UART2_BASE, /* FIXME */
+		.irq		= INT_UART2,
+		.uartclk	= 16000000,
+		.fifosize	= 8,
+		.flags		= ASYNC_BOOT_AUTOCONF,
+		.ops		= &imx_pops,
+		.line		= 1,
+	},
+	}
+};
+
+/*
+ * Setup the IMX serial ports.
+ * Note also that we support "console=ttySMXx" where "x" is either 0 or 1.
+ * Which serial port this ends up being depends on the machine you're
+ * running this kernel on.  I'm not convinced that this is a good idea,
+ * but that's the way it traditionally works.
+ *
+ */
+static void __init imx_init_ports(void)
+{
+	static int	first = 1;
+	int		i;
+	struct imx_port *sport;
+	
+	if (!first)
+		return;
+	first = 0;
+
+#if 0
+	
+#if 1 
+
+	/* Enable HCLK input to the UART1 module */
+	CRM_PCCR0 |= PCCR0_UART1_EN;
+
+	// software reset
+	for (i = 0; i < ARRAY_SIZE(imx_ports); i++) {
+	        sport = &imx_ports[i];
+		UCR2((u32)sport->port.membase) = 0x0;
+	
+		//write 1 to RXDMUXSEL = 1
+		UCR3((u32)sport->port.membase) |= 0x4;
+	}
+#endif
+
+	for (i = 0; i < ARRAY_SIZE(imx_ports); i++) {
+#warning "Removed by JTM"
+//	        init_timer(&imx_ports[i].timer);
+#warning "Removed by JTM"
+//		imx_ports[i].timer.function = imx_timeout;
+#warning "Removed by JTM"
+//		imx_ports[i].timer.data     = (unsigned long)&imx_ports[i];
+	}
+
+	/* See section 37.2 in I.MX21 RM */
+	imx21_gpio_mode(PE14_PF_UART1_CTS);
+	imx21_gpio_mode(PE15_PF_UART1_RTS);
+	imx21_gpio_mode(PE12_PF_UART1_TXD);
+	imx21_gpio_mode(PE13_PF_UART1_RXD);
+
+#if 0
+	imx21_gpio_mode(PB28_PF_UART2_CTS);
+	imx21_gpio_mode(PB29_PF_UART2_RTS);
+	imx21_gpio_mode(PB30_PF_UART2_TXD);
+	imx21_gpio_mode(PB31_PF_UART2_RXD);
+#endif
+
+#if 1
+	sport = &imx_ports[UART_1];
+	
+	//software reset
+	UCR2((u32)sport->port.membase) = 0x61E6;
+	UCR1 ((u32)sport->port.membase)= 0x0;
+	UCR3((u32)sport->port.membase) = 0x4;
+	UCR4 ((u32)sport->port.membase)= 0x8000;
+
+	// configure appropriate pins for UART_1_RX, UART_1_TX,
+	// UART2_RX and UART2_TX		
+	
+    UCR1 ((u32)sport->port.membase)= 0x0005; // UARTEN = 1,enable the clock
+    //UUCR2 = CTSC,TXEN,RXEN=1,reset, ignore IRTS bit, WS = 1 , 
+    //8 bit tx and rx,1 stop bit, disable parity
+    UCR2((u32)sport->port.membase) = 0x6026;		
+    UCR3((u32)sport->port.membase) = 0x0004;		
+    UCR4((u32)sport->port.membase) = 0x8000;		
+
+    //=================================================================
+    // Set up reference freq divide for UART module 
+    // MX2 only support 16MHz output
+    // PerCLK1(31.99998691MHz)/UFCR[RFDIV] (2)= 15.99999673MHz
+    UFCR((u32)sport->port.membase) = 0x0a01; 	// CKIH = PerCLK1 set to div by 1 (UART 1)
+
+    //=================================================================
+
+    //clear loopback bit
+    UTS((u32)sport->port.membase) = 0x0000;
+#endif
+#endif
+}
+
+#ifdef CONFIG_SERIAL_IMX_CONSOLE
+
+/*
+ * Interrupts are disabled on entering
+ */
+static void
+imx_console_write(struct console *co, const char *s, unsigned int count)
+{
+	struct imx_port *sport = &imx_ports[co->index];
+	unsigned int old_ucr1, old_ucr2, i;
+
+	/*
+	 *	First, save UCR1/2 and then disable interrupts
+	 */
+	old_ucr1 = UCR1((u32)sport->port.membase);
+	old_ucr2 = UCR2((u32)sport->port.membase);
+
+	UCR1((u32)sport->port.membase) =
+	                   (old_ucr1 | UCR1_UARTEN)
+	                   & ~(UCR1_TXMPTYEN | UCR1_RRDYEN);
+	UCR2((u32)sport->port.membase) = old_ucr2 | UCR2_TXEN;
+
+	/*
+	 *	Now, do each character
+	 */
+	for (i = 0; i < count; i++) {
+
+		while ((UTS((u32)sport->port.membase) & UTS_TXFULL))
+			barrier();
+
+		URTX0((u32)sport->port.membase) = s[i];
+
+		if (s[i] == '\n') {
+			while ((UTS((u32)sport->port.membase) & UTS_TXFULL))
+				barrier();
+			URTX0((u32)sport->port.membase) = '\r';
+		}
+	}
+
+	/*
+	 *	Finally, wait for transmitter to become empty
+	 *	and restore UCR1/2
+	 */
+	while (!(USR2((u32)sport->port.membase) & USR2_TXDC));
+
+	UCR1((u32)sport->port.membase) = old_ucr1;
+	UCR2((u32)sport->port.membase) = old_ucr2;
+}
+
+/*
+ * If the port was already initialised (eg, by a boot loader),
+ * try to determine the current setup.
+ */
+static void __init
+imx_console_get_options(struct imx_port *sport, int *baud,
+			   int *parity, int *bits)
+{
+    
+	if ( UCR1((u32)sport->port.membase) | UCR1_UARTEN ) {
+		/* ok, the port was enabled */
+		unsigned int ucr2, ubir,ubmr, uartclk;
+
+		ucr2 = UCR2((u32)sport->port.membase);
+
+		*parity = 'n';
+		if (ucr2 & UCR2_PREN) {
+			if (ucr2 & UCR2_PROE)
+				*parity = 'o';
+			else
+				*parity = 'e';
+		}
+
+		if (ucr2 & UCR2_WS)
+			*bits = 8;
+		else
+			*bits = 7;
+
+		ubir = UBIR((u32)sport->port.membase) & 0xffff;
+		ubmr = UBMR((u32)sport->port.membase) & 0xffff;
+		uartclk = sport->port.uartclk;
+
+		*baud = ((uartclk/16) * (ubir + 1)) / (ubmr + 1);
+	}
+}
+
+static int __init
+imx_console_setup(struct console *co, char *options)
+{
+	struct imx_port *sport;
+	int baud = 9600;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+	
+	/*
+	 * Check whether an invalid uart number has been specified, and
+	 * if so, search for the first available port that does have
+	 * console support.
+	 */
+	if (co->index == -1 || co->index >= ARRAY_SIZE(imx_ports))
+		co->index = 0;
+	sport = &imx_ports[co->index];
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+	else
+		imx_console_get_options(sport, &baud, &parity, &bits);
+
+	return uart_set_options(&sport->port, co, baud, parity, bits, flow);
+}
+
+extern struct uart_driver imx_reg;
+static struct console imx_console = {
+	.name		= "ttySMX",
+	.write		= imx_console_write,
+	.device		= uart_console_device,
+	.setup		= imx_console_setup,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	.data		= &imx_reg,
+};
+
+static int __init imx_rs_console_init(void)
+{
+	imx_init_ports();
+	register_console(&imx_console);
+	return 0;
+}
+console_initcall(imx_rs_console_init);
+
+#define IMX_CONSOLE	&imx_console
+#else
+#define IMX_CONSOLE	NULL
+#endif
+
+static struct uart_driver imx_reg = {
+	.owner          = THIS_MODULE,
+	.driver_name    = DRIVER_NAME,
+	.dev_name       = "ttySMX",
+	.devfs_name	= "ttsmx/",
+	.major          = SERIAL_IMX_MAJOR,
+	.minor          = MINOR_START,
+	.nr             = ARRAY_SIZE(imx_ports),
+	.cons           = IMX_CONSOLE,
+};
+
+static int serial_imx_suspend(struct device *_dev, u32 state, u32 level)
+{
+        struct imx_port *sport = dev_get_drvdata(_dev);
+
+        if (sport && level == SUSPEND_DISABLE)
+                uart_suspend_port(&imx_reg, &sport->port);
+
+        return 0;
+}
+
+static int serial_imx_resume(struct device *_dev, u32 level)
+{
+        struct imx_port *sport = dev_get_drvdata(_dev);
+
+        if (sport && level == RESUME_ENABLE)
+                uart_resume_port(&imx_reg, &sport->port);
+
+        return 0;
+}
+
+static int serial_imx_probe(struct device *_dev)
+{
+	struct platform_device *dev = to_platform_device(_dev);
+
+	imx_ports[dev->id].port.dev = _dev;
+	uart_add_one_port(&imx_reg, &imx_ports[dev->id].port);
+	dev_set_drvdata(_dev, &imx_ports[dev->id]);
+	return 0;
+}
+
+static int serial_imx_remove(struct device *_dev)
+{
+	struct imx_port *sport = dev_get_drvdata(_dev);
+
+	dev_set_drvdata(_dev, NULL);
+
+	if (sport)
+		uart_remove_one_port(&imx_reg, &sport->port);
+
+	return 0;
+}
+
+static struct device_driver serial_imx_driver = {
+        .name           = "imx21-uart",
+        .bus            = &platform_bus_type,
+        .probe          = serial_imx_probe,
+        .remove         = serial_imx_remove,
+
+	.suspend	= serial_imx_suspend,
+	.resume		= serial_imx_resume,
+};
+
+static int __init imx_serial_init(void)
+{
+	int ret;
+
+	printk(KERN_INFO "Serial: IMX driver\n");
+
+	imx_init_ports();
+
+	ret = uart_register_driver(&imx_reg);
+	if (ret)
+		return ret;
+
+	ret = driver_register(&serial_imx_driver);
+	if (ret != 0)
+		uart_unregister_driver(&imx_reg);
+
+	return 0;
+}
+
+static void __exit imx_serial_exit(void)
+{
+	uart_unregister_driver(&imx_reg);
+}
+
+module_init(imx_serial_init);
+module_exit(imx_serial_exit);
+
+MODULE_AUTHOR("Sascha Hauer");
+MODULE_DESCRIPTION("IMX generic serial port driver");
+MODULE_LICENSE("GPL");
diff -NaurbB linux-2.6.14_original/drivers/serial/Kconfig linux-2.6.14_imx21/drivers/serial/Kconfig
--- linux-2.6.14_original/drivers/serial/Kconfig	2005-10-28 02:02:08.000000000 +0200
+++ linux-2.6.14_imx21/drivers/serial/Kconfig	2006-04-11 11:33:28.000000000 +0200
@@ -3,6 +3,12 @@
 #
 # $Id: Kconfig,v 1.11 2004/03/11 18:08:04 lethal Exp $
 #
+# March 2006 :
+# Adapted to ARM9 i.MX21/CSB535FS board by S.Gerber, G.Boutillier and D.Rossier
+# University of Applied Sciences Western Switzerland
+# Reconfigurable & Embedded Digital Systems, REDS Institute
+#
+#
 
 menu "Serial drivers"
 
@@ -444,12 +450,20 @@
 	  If you have a machine based on a Motorola IMX CPU you
 	  can enable its onboard serial port by enabling this option.
 
+config SERIAL_IMX21
+	bool "IMX21 serial port support"
+	depends on ARM && ARCH_IMX21
+	select SERIAL_CORE
+	help
+	  If you have a machine based on a Motorola IMX21 CPU you
+	  can enable its onboard serial port by enabling this option.
+
 config SERIAL_IMX_CONSOLE
 	bool "Console on IMX serial port"
-	depends on SERIAL_IMX
+	depends on SERIAL_IMX || SERIAL_IMX21
 	select SERIAL_CORE_CONSOLE
 	help
-	  If you have enabled the serial port on the Motorola IMX
+	  If you have enabled the serial port on the Motorola IMX or IMX21
 	  CPU you can make it the console by answering Y to this option.
 
 	  Even if you say Y here, the currently visible virtual console
diff -NaurbB linux-2.6.14_original/drivers/serial/Makefile linux-2.6.14_imx21/drivers/serial/Makefile
--- linux-2.6.14_original/drivers/serial/Makefile	2005-10-28 02:02:08.000000000 +0200
+++ linux-2.6.14_imx21/drivers/serial/Makefile	2006-04-11 11:33:40.000000000 +0200
@@ -3,6 +3,12 @@
 #
 #  $Id: Makefile,v 1.8 2002/07/21 21:32:30 rmk Exp $
 #
+# March 2006 :
+# Adapted to ARM9 i.MX21/CSB535FS board by S.Gerber, G.Boutillier and D.Rossier
+# University of Applied Sciences Western Switzerland
+# Reconfigurable & Embedded Digital Systems, REDS Institute
+#
+#
 
 serial-8250-y :=
 serial-8250-$(CONFIG_SERIAL_8250_ACPI) += 8250_acpi.o
@@ -47,6 +53,7 @@
 obj-$(CONFIG_SERIAL_SGI_L1_CONSOLE) += sn_console.o
 obj-$(CONFIG_SERIAL_CPM) += cpm_uart/
 obj-$(CONFIG_SERIAL_IMX) += imx.o
+obj-$(CONFIG_SERIAL_IMX21) += imx21.o
 obj-$(CONFIG_SERIAL_MPC52xx) += mpc52xx_uart.o
 obj-$(CONFIG_SERIAL_ICOM) += icom.o
 obj-$(CONFIG_SERIAL_M32R_SIO) += m32r_sio.o
diff -NaurbB linux-2.6.14_original/include/asm-arm/arch-imx21/csb535.h linux-2.6.14_imx21/include/asm-arm/arch-imx21/csb535.h
--- linux-2.6.14_original/include/asm-arm/arch-imx21/csb535.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/include/asm-arm/arch-imx21/csb535.h	2006-04-11 10:29:12.000000000 +0200
@@ -0,0 +1,45 @@
+/*
+ * linux/include/asm-arm/arch-imx21/csb535.h
+ *
+ * Copyright (C) 2004 Robert Schwebel, Pengutronix
+ *
+ * Modified By: Ron Melvin (ron.melvin@timesys.com)
+ * Copyright (C) 2005 TimeSys Corporation 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef __ASM_ARCH_CSB535_H
+#define __ASM_ARCH_CSB535_H
+
+/* ------------------------------------------------------------------------ */
+/* Memory Map for the M9328CSB535 (CSB535) Board                            */
+/* ------------------------------------------------------------------------ */
+
+#define CSB535_FLASH_PHYS		0x10000000
+#define CSB535_FLASH_SIZE		(16*1024*1024)
+
+#define IMX_FB_PHYS			(0x0C000000 - 0x40000)
+
+#define CLK32 32768
+
+#define CSB535_ETH_VIRT IMX21_CS1_VIRT
+#define CSB535_ETH_PHYS IMX21_CS1_PHYS
+#define CSB535_ETH_SIZE IMX21_CS1_SIZE
+#define CSB535_ETH_IRQ  IRQ_GPIOE(2)
+
+
+#endif /* __ASM_ARCH_CSB535_H */
diff -NaurbB linux-2.6.14_original/include/asm-arm/arch-imx21/debug-macro.S linux-2.6.14_imx21/include/asm-arm/arch-imx21/debug-macro.S
--- linux-2.6.14_original/include/asm-arm/arch-imx21/debug-macro.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/include/asm-arm/arch-imx21/debug-macro.S	2006-04-11 10:29:12.000000000 +0200
@@ -0,0 +1,36 @@
+/* linux/include/asm-arm/arch-imx21/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) 1994-1999 Russell King
+ *  Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+		.macro	addruart,rx
+	        mrc     p15, 0, \rx, c1, c0
+                tst     \rx, #1                 @ MMU enabled?
+                moveq   \rx, #0x10000000        @ Physical
+                movne   \rx, #0xe4000000        @ Virtual
+                orr     \rx, \rx, #0xa000
+                orr     \rx, \rx, #0x40
+		.endm
+
+		.macro	senduart,rd,rx
+		str	\rd, [\rx]	@ TXDATA
+		.endm
+
+		.macro	waituart,rd,rx
+		.endm
+
+		.macro	busyuart,rd,rx
+1002:		ldrb    \rd, [\rx, #0x54]
+		@ Check TRDY in USR1_1 (phys=0x1000a094)
+                and     \rd, \rd, #0x2000  
+                cmp     \rd, #0x2000
+                bne     1002b
+		.endm
diff -NaurbB linux-2.6.14_original/include/asm-arm/arch-imx21/dma.h linux-2.6.14_imx21/include/asm-arm/arch-imx21/dma.h
--- linux-2.6.14_original/include/asm-arm/arch-imx21/dma.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/include/asm-arm/arch-imx21/dma.h	2006-04-11 10:29:12.000000000 +0200
@@ -0,0 +1,71 @@
+/*
+ *  linux/include/asm-arm/arch-imx21/dma.h
+ *
+ *  Copyright (C) 1997,1998 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+#define MAX_DMA_ADDRESS		0xffffffff
+
+#define MAX_DMA_CHANNELS	0
+
+/*
+ * DMA registration
+ */
+
+typedef enum {
+	DMA_PRIO_HIGH = 0,
+	DMA_PRIO_MEDIUM = 3,
+	DMA_PRIO_LOW = 6
+} imx_dma_prio;
+
+int imx_request_dma(char *name, imx_dma_prio prio,
+		    void (*irq_handler) (int, void *, struct pt_regs *),
+		    void (*err_handler) (int, void *, struct pt_regs *),
+		    void *data);
+
+void imx_free_dma(int dma_ch);
+
+
+#define DMA_REQ_UART3_T        2
+#define DMA_REQ_UART3_R        3
+#define DMA_REQ_SSI2_T         4
+#define DMA_REQ_SSI2_R         5
+#define DMA_REQ_CSI_STAT       6
+#define DMA_REQ_CSI_R          7
+#define DMA_REQ_MSHC           8
+#define DMA_REQ_DSPA_DCT_DOUT  9
+#define DMA_REQ_DSPA_DCT_DIN  10
+#define DMA_REQ_DSPA_MAC      11
+#define DMA_REQ_EXT           12
+#define DMA_REQ_SDHC          13
+#define DMA_REQ_SPI1_R        14
+#define DMA_REQ_SPI1_T        15
+#define DMA_REQ_SSI_T         16
+#define DMA_REQ_SSI_R         17
+#define DMA_REQ_ASP_DAC       18
+#define DMA_REQ_ASP_ADC       19
+#define DMA_REQ_USP_EP(x)    (20+(x))
+#define DMA_REQ_SPI2_R        26
+#define DMA_REQ_SPI2_T        27
+#define DMA_REQ_UART2_T       28
+#define DMA_REQ_UART2_R       29
+#define DMA_REQ_UART1_T       30
+#define DMA_REQ_UART1_R       31
+
+#endif				/* _ASM_ARCH_DMA_H */
diff -NaurbB linux-2.6.14_original/include/asm-arm/arch-imx21/entry-macro.S linux-2.6.14_imx21/include/asm-arm/arch-imx21/entry-macro.S
--- linux-2.6.14_original/include/asm-arm/arch-imx21/entry-macro.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/include/asm-arm/arch-imx21/entry-macro.S	2006-04-11 10:29:12.000000000 +0200
@@ -0,0 +1,29 @@
+/*
+ * include/asm-arm/arch-imx21/entry-macro.S
+ *
+ * Low-level IRQ helper macros for iMX-based platforms
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+		.macro	disable_fiq
+		.endm
+#define AITC_NIVECSR   0x40
+		.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+		ldr	\irqstat, =IO_ADDRESS(MX2ADS_AITC_BASE)
+		@ Load offset & priority of the highest priority
+		@ interrupt pending.
+		ldr	\irqnr, [\irqstat, #AITC_NIVECSR]
+		@ Shift off the priority leaving the offset or
+		@ "interrupt number"
+		mov	\irqnr, \irqnr, lsr #16
+ 		ldr	\irqstat, =1	@ dummy compare
+		ldr	\base, =0xFFFF		// invalid interrupt
+		cmp	\irqnr, \base
+		bne	1001f
+		ldr	\irqstat, =0
+1001:
+		tst	\irqstat, #1	@ to make the condition code = TRUE
+		.endm
+
diff -NaurbB linux-2.6.14_original/include/asm-arm/arch-imx21/hardware.h linux-2.6.14_imx21/include/asm-arm/arch-imx21/hardware.h
--- linux-2.6.14_original/include/asm-arm/arch-imx21/hardware.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/include/asm-arm/arch-imx21/hardware.h	2006-04-11 10:29:12.000000000 +0200
@@ -0,0 +1,116 @@
+/*
+ *  linux/include/asm-arm/arch-imx21/hardware.h
+ *
+ *  Copyright (C) 1999 ARM Limited.
+ *
+ * Modified By: Ron Melvin (ron.melvin@timesys.com)
+ * Copyright (C) 2005 TimeSys Corporation 
+
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/sizes.h>
+#include "imx-regs.h"
+
+#ifndef __ASSEMBLY__
+# define __REG(x)	(*((volatile u32 *)IO_ADDRESS(x)))
+
+# define __REG2(x,y)	\
+	( __builtin_constant_p(y) ? (__REG((x) + (y))) \
+			  : (*(volatile u32 *)((u32)&__REG(x) + (y))) )
+extern int x4;
+#endif
+
+/*
+ * Memory map
+ */
+
+#define IMX21_IO_PHYS		0x10000000
+#define IMX21_IO_SIZE		0x00100000
+#define IMX21_IO_BASE		0xe0000000
+
+#define IMX21_CS0_PHYS		0xc8000000
+#define IMX21_CS0_SIZE		0x02000000
+#define IMX21_CS0_VIRT		0xe8000000
+
+#define IMX21_CS1_PHYS		0xcc000000
+#define IMX21_CS1_SIZE		0x01000000
+#define IMX21_CS1_VIRT		0xea000000
+
+#define IMX21_EMI_PHYS		0xdf000000
+#define IMX21_EMI_SIZE		0x00004000
+#define IMX21_EMI_VIRT		0xeb000000
+
+#if 0	// TODO remove??
+#define IMX21_CS2_PHYS		0x13000000
+#define IMX21_CS2_SIZE		0x01000000
+#define IMX21_CS2_VIRT		0xeb000000
+
+#define IMX21_CS3_PHYS		0x14000000
+#define IMX21_CS3_SIZE		0x01000000
+#define IMX21_CS3_VIRT		0xec000000
+
+#define IMX21_CS4_PHYS		0x15000000
+#define IMX21_CS4_SIZE		0x01000000
+#define IMX21_CS4_VIRT		0xed000000
+
+#define IMX21_CS5_PHYS		0x16000000
+#define IMX21_CS5_SIZE		0x01000000
+#define IMX21_CS5_VIRT		0xee000000
+#endif // NOT USED
+
+#define IMX21_FB_VIRT		0xF1000000
+#define IMX21_FB_SIZE		(256*1024)
+
+/* macro to get at IO space when running virtually */
+#define IO_ADDRESS(x) ((x) | IMX21_IO_BASE)
+
+#ifndef __ASSEMBLY__
+/*
+ * Handy routine to set GPIO functions
+ */
+extern void imx21_gpio_mode( int gpio_mode );
+
+/* get frequencies in Hz */
+extern unsigned int imx21_get_system_clk(void);
+extern unsigned int imx21_get_mcu_clk(void);
+extern unsigned int imx21_get_perclk1(void); /* UART[12], Timer[12], PWM */
+extern unsigned int imx21_get_perclk2(void); /* LCD, SD, SPI[12]         */
+extern unsigned int imx21_get_perclk3(void); /* SSI                      */
+extern unsigned int imx21_get_hclk(void);    /* SDRAM, CSI, Memory Stick,*/
+                                           /* I2C, DMA                 */
+#endif
+
+#define MAXIRQNUM                       62
+#define MAXFIQNUM                       62
+#define MAXSWINUM                       62
+
+/*
+ * Use SDRAM for memory
+ */
+#define MEM_SIZE		0x01000000
+
+#ifdef CONFIG_ARCH_MX2ADS
+#include "mx2ads.h"
+#endif
+
+#ifdef CONFIG_MACH_CSB535
+#include "csb535.h"
+#endif
+
+#endif
diff -NaurbB linux-2.6.14_original/include/asm-arm/arch-imx21/imx21fb.h linux-2.6.14_imx21/include/asm-arm/arch-imx21/imx21fb.h
--- linux-2.6.14_original/include/asm-arm/arch-imx21/imx21fb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/include/asm-arm/arch-imx21/imx21fb.h	2006-04-11 10:29:12.000000000 +0200
@@ -0,0 +1,35 @@
+/*
+ * This structure describes the machine which we are running on.
+ */
+struct imxfb_mach_info {
+	u_long		pixclock;
+
+	u_short		xres;
+	u_short		yres;
+
+	u_char		bpp;
+	u_char		hsync_len;
+	u_char		left_margin;
+	u_char		right_margin;
+
+	u_char		vsync_len;
+	u_char		upper_margin;
+	u_char		lower_margin;
+	u_char		sync;
+
+	u_int		cmap_greyscale:1,
+			cmap_inverse:1,
+			cmap_static:1,
+			unused:29;
+
+	u_int		lpcr;
+	u_int		lpccr;
+	u_int		lscr;
+
+	u_char * fixed_screen_cpu;
+	dma_addr_t fixed_screen_dma;
+
+	void (*lcd_power)(int);
+	void (*backlight_power)(int);
+};
+void set_imx_fb_info(struct imxfb_mach_info *hard_imx_fb_info);
diff -NaurbB linux-2.6.14_original/include/asm-arm/arch-imx21/imx-regs.h linux-2.6.14_imx21/include/asm-arm/arch-imx21/imx-regs.h
--- linux-2.6.14_original/include/asm-arm/arch-imx21/imx-regs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/include/asm-arm/arch-imx21/imx-regs.h	2005-10-26 19:45:10.000000000 +0200
@@ -0,0 +1,719 @@
+#ifndef _MX2ADS_REGS_H
+#define _MX2ADS_REGS_H
+/* ------------------------------------------------------------------------
+ *  Freescale i.iMX21 system registers
+ * ------------------------------------------------------------------------
+ *
+ * Modified By: Ron Melvin (ron.melvin@timesys.com)
+ * Copyright (C) 2005 TimeSys Corporation 
+ *
+ * Modified by: Stephen Donecker (sdonecker@sbcglobal.net)
+ */
+
+/*
+ * Memory mapped I/O for the M9328MX21ADS    
+ *
+ * TODO: move these defines to an appropiate board specific file
+ */
+
+#define MX2ADS_MMIO_PHYS	(0xCC800000)
+#define MX2ADS_MMIO_OFFSET	MX2ADS_MMIO_PHYS-IMX21_CS1_PHYS
+#define MMIO_REG		(*((volatile u16 *)(IMX21_CS1_VIRT+MX2ADS_MMIO_OFFSET)))
+
+#define MMIO_SD_WP		(1<<0)
+#define MMIO_SW_SEL		(1<<1)
+#define MMIO_RESET_E_UART	(1<<2)
+#define MMIO_RESET_BASE		(1<<3)
+#define MMIO_CSI_CTL2		(1<<4)
+#define MMIO_CSI_CTL1		(1<<5)
+#define MMIO_CSI_CTL0		(1<<6)
+#define MMIO_UART1_EN		(1<<7)
+#define MMIO_UART4_EN		(1<<8)
+#define	MMIO_LCDON		(1<<9)
+#define MMIO_IRDA_EN		(1<<10)
+#define MMIO_IRDA_FIR_SEL	(1<<11)
+#define MMIO_IRDA_MD0_B		(1<<12)
+#define MMIO_IRDA_MD1		(1<<13)
+#define MMIO_LED4_ON		(1<<14)
+#define MMIO_LED3_ON		(1<<15)
+
+/*
+ *  Register BASEs, based on OFFSETs
+ *
+ */
+
+/* TODO: Rename MX2ADS to processor specific name, not a board name */
+
+#define MX2ADS_AIPI1_BASE             (0x00000 + IMX21_IO_BASE)
+#define MX2ADS_AIPI2_BASE             (0x20000 + IMX21_IO_BASE)
+
+#define MX2ADS_DMA_BASE               (0x01000 + IMX21_IO_BASE)
+#define MX2ADS_WDT_BASE               (0x02000 + IMX21_IO_BASE)
+#define MX2ADS_GPT1_BASE              (0x03000 + IMX21_IO_BASE)
+#define MX2ADS_GPT2_BASE              (0x04000 + IMX21_IO_BASE)
+#define MX2ADS_GPT3_BASE              (0x05000 + IMX21_IO_BASE)
+#define MX2ADS_PWM_BASE               (0x06000 + IMX21_IO_BASE)
+#define MX2ADS_RTC_BASE               (0x07000 + IMX21_IO_BASE)
+#define MX2ADS_KPP_BASE               (0x08000 + IMX21_IO_BASE)
+#define MX2ADS_OWIRE_BASE             (0x09000 + IMX21_IO_BASE)
+#define MX2ADS_UART1_BASE             (0x0A000 + IMX21_IO_BASE)
+#define MX2ADS_UART2_BASE             (0x0B000 + IMX21_IO_BASE)
+#define MX2ADS_UART3_BASE             (0x0C000 + IMX21_IO_BASE)
+#define MX2ADS_UART4_BASE             (0x0D000 + IMX21_IO_BASE)
+#define MX2ADS_CSPI1_BASE             (0x0E000 + IMX21_IO_BASE)
+#define MX2ADS_CSPI2_BASE             (0x0F000 + IMX21_IO_BASE)
+#define MX2ADS_SSI1_BASE              (0x10000 + IMX21_IO_BASE)
+#define MX2ADS_SSI2_BASE              (0x11000 + IMX21_IO_BASE)
+#define MX2ADS_I2C_BASE               (0x12000 + IMX21_IO_BASE)
+#define MX2ADS_SDHC1_BASE             (0x13000 + IMX21_IO_BASE)
+#define MX2ADS_SDHC2_BASE             (0x14000 + IMX21_IO_BASE)
+#define MX2ADS_GPIO_BASE              (0x15000 + IMX21_IO_BASE)
+#define MX2ADS_AUDMUX_BASE            (0x16000 + IMX21_IO_BASE)
+#define MX2ADS_CSPI3_BASE		(IMX21_IO_BASE + 0x17000)
+#define MX2ADS_LCDC_BASE              (0x21000 + IMX21_IO_BASE)
+#define MX2ADS_SLCDC_BASE             (0x22000 + IMX21_IO_BASE)
+#define MX2ADS_SAHARA_BASE            (0x23000 + IMX21_IO_BASE)
+#define MX2ADS_USBOTG_BASE            (0x24000 + IMX21_IO_BASE)
+#define MX2ADS_EMMA_BASE              (0x26000 + IMX21_IO_BASE)
+#define MX2ADS_CRM_BASE               (0x27000 + IMX21_IO_BASE)
+#define MX2ADS_FIRI_BASE              (0x28000 + IMX21_IO_BASE)
+#define MX2ADS_RNGA_BASE		(IMX21_IO_BASE + 0x29000)
+#define MX2ADS_RTIC_BASE		(IMX21_IO_BASE + 0x2A000)
+#define MX2ADS_JAM_BASE               (0x3E000 + IMX21_IO_BASE)
+#define MX2ADS_MAX_BASE               (0x3F000 + IMX21_IO_BASE)
+#define MX2ADS_AITC_BASE              (0x40000 + IMX21_IO_BASE)
+
+#define GPIO_A	0
+#define GPIO_B	1
+#define GPIO_C	2
+#define GPIO_D	3
+#define GPIO_E	4
+#define GPIO_F	5
+
+/*
+ *  GPIO Module and I/O Multiplexer
+ *  x = 0..5 for reg_A, reg_B, reg_C, reg_D, reg_E, reg_F
+ */
+
+#define DDIR(x)    __REG2(MX2ADS_GPIO_BASE + 0x00, ((x) & 7) << 8)
+#define OCR1(x)    __REG2(MX2ADS_GPIO_BASE + 0x04, ((x) & 7) << 8)
+#define OCR2(x)    __REG2(MX2ADS_GPIO_BASE + 0x08, ((x) & 7) << 8)
+#define ICONFA1(x) __REG2(MX2ADS_GPIO_BASE + 0x0c, ((x) & 7) << 8)
+#define ICONFA2(x) __REG2(MX2ADS_GPIO_BASE + 0x10, ((x) & 7) << 8)
+#define ICONFB1(x) __REG2(MX2ADS_GPIO_BASE + 0x14, ((x) & 7) << 8)
+#define ICONFB2(x) __REG2(MX2ADS_GPIO_BASE + 0x18, ((x) & 7) << 8)
+#define DR(x)      __REG2(MX2ADS_GPIO_BASE + 0x1c, ((x) & 7) << 8)
+#define GIUS(x)    __REG2(MX2ADS_GPIO_BASE + 0x20, ((x) & 7) << 8)
+#define SSR(x)     __REG2(MX2ADS_GPIO_BASE + 0x24, ((x) & 7) << 8)
+#define ICR1(x)    __REG2(MX2ADS_GPIO_BASE + 0x28, ((x) & 7) << 8)
+#define ICR2(x)    __REG2(MX2ADS_GPIO_BASE + 0x2c, ((x) & 7) << 8)
+#define IMR(x)     __REG2(MX2ADS_GPIO_BASE + 0x30, ((x) & 7) << 8)
+#define ISR(x)     __REG2(MX2ADS_GPIO_BASE + 0x34, ((x) & 7) << 8)
+#define GPR(x)     __REG2(MX2ADS_GPIO_BASE + 0x38, ((x) & 7) << 8)
+#define SWR(x)     __REG2(MX2ADS_GPIO_BASE + 0x3c, ((x) & 7) << 8)
+#define PUEN(x)    __REG2(MX2ADS_GPIO_BASE + 0x40, ((x) & 7) << 8)
+#define PMASK      __REG(MX2ADS_GPIO_BASE + 0x600)
+
+/*  ethernet controller IRQ is tied to UART3_RTS */ 
+#define NET_IRQ_BIT		(1 << 11)
+
+/*
+ *  GPIO Mode
+ *
+ *  The pin, port, data direction, pull-up enable, primary/alternate
+ *  function, output configuration, and input configuration are encoded in a 
+ *  single word as follows.
+ *
+ *  4:0 Pin (31-0)
+ *  7:5 Port (F-A)
+ *  8 Direction
+ *  9 PUEN
+ *  10:11 Primary Function,Alternate Function,GPIO
+ *  13:12 OCR
+ *  15:14 ICONF
+ * 
+ *  [ 15 14 | 13 12 | 11 10 | 9  |  8  | 7 6 5 | 4 3 2 1 0 ]
+ *  [ ICONF |  OCR  | P/A/G | PU | Dir | Port  |    Pin    ]
+ */
+
+#define GPIO_PIN_MASK		(0x1f<<0)
+
+#define GPIO_PORT_POS		5
+#define GPIO_PORT_MASK		(0x3 << GPIO_PORT_POS)
+#define GPIO_PORTA 		(0 << GPIO_PORT_POS)
+#define GPIO_PORTB		(1 << GPIO_PORT_POS)
+#define GPIO_PORTC		(2 << GPIO_PORT_POS)
+#define GPIO_PORTD		(3 << GPIO_PORT_POS)
+#define GPIO_PORTE		(4 << GPIO_PORT_POS)
+#define GPIO_PORTF		(5 << GPIO_PORT_POS)
+
+#define GPIO_DIR_MASK		(1<<8)
+#define GPIO_IN			(0<<8)
+#define GPIO_OUT		(1<<8)
+
+#define GPIO_PU_MASK		(1<<9)
+#define GPIO_PUDIS		(0<<9)
+#define GPIO_PUEN		(1<<9)
+
+#define GPIO_FUNC_MASK		(0x3<<10)
+#define GPIO_PF			(0<<10)
+#define GPIO_AF			(1<<10)
+#define GPIO_GP			(2<<10)
+
+#define GPIO_OCR_POS		12
+#define GPIO_OCR_MASK		(0x3 << GPIO_OCR_POS)
+#define GPIO_AIN		(0 << GPIO_OCR_POS)
+#define GPIO_BIN		(1 << GPIO_OCR_POS)
+#define GPIO_CIN		(2 << GPIO_OCR_POS)
+#define GPIO_DR			(3 << GPIO_OCR_POS)
+
+#define GPIO_ICONF_MASK		(0x3<<14)
+#define GPIO_AOUT		(1<<14)
+#define GPIO_BOUT		(2<<14)
+
+/*
+ *  Freescale i.MX21 GPIO signal multiplexing mode defines
+ */
+
+/*
+ *  The GPIO pin naming convention was developed by the original unknown author. 
+ *  Although using defines for variables is always a good idea for portability, 
+ *  in this case the names are as specific as the values, and thus loose their 
+ *  portability. Ultimately the pin names should be changed to reflect the signal
+ *  name only.  
+ *
+ *  The current naming convention is as follows.
+ *
+ *  P(port)(pin)_(function)_(signal)
+ *
+ *  port = (A-F)
+ *  pin = (0-31)
+ *  function = (PF|AF|AIN|BIN|CIN|DR|AOUT|BOUT)
+ *  signal = signal name from datasheet
+ *
+ *  Remember that when in GPIO mode, AIN, BIN, CIN, and DR are inputs to the GPIO
+ *  peripheral module and represent outputs to the pin. Similarly AOUT, and BOUT
+ *  are outputs from the GPIO peripheral module and represent inputs to the physical 
+ *  pin in question. Refer to the multiplexing table in the section titled "Signal 
+ *  Descriptions and Pin Assignments" in the reference manual.
+ */
+   
+#define PE14_PF_UART1_CTS	( GPIO_PORTE | 14 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PE15_PF_UART1_RTS	( GPIO_PORTE | 15 | GPIO_PF | GPIO_IN | GPIO_PUDIS )
+#define PE12_PF_UART1_TXD	( GPIO_PORTE | 12 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PE13_PF_UART1_RXD	( GPIO_PORTE | 13 | GPIO_PF | GPIO_IN | GPIO_PUDIS )
+
+#define PA5_PF_LSCLK		( GPIO_PORTA | 5 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA6_PF_LD0		( GPIO_PORTA | 6 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA7_PF_LD1		( GPIO_PORTA | 7 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA8_PF_LD2		( GPIO_PORTA | 8 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA9_PF_LD3		( GPIO_PORTA | 9 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA10_PF_LD4		( GPIO_PORTA | 10 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA11_PF_LD5		( GPIO_PORTA | 11 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA12_PF_LD6		( GPIO_PORTA | 12 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA13_PF_LD7		( GPIO_PORTA | 13 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA14_PF_LD8		( GPIO_PORTA | 14 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA15_PF_LD9		( GPIO_PORTA | 15 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA16_PF_LD10		( GPIO_PORTA | 16 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA17_PF_LD11		( GPIO_PORTA | 17 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA18_PF_LD12		( GPIO_PORTA | 18 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA19_PF_LD13		( GPIO_PORTA | 19 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA20_PF_LD14		( GPIO_PORTA | 20 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA21_PF_LD15		( GPIO_PORTA | 21 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA22_PF_LD16		( GPIO_PORTA | 22 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA23_PF_LD17		( GPIO_PORTA | 23 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA24_PF_REV		( GPIO_PORTA | 24 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA25_PF_CLS		( GPIO_PORTA | 25 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA26_PF_PS		( GPIO_PORTA | 26 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA27_PF_SPL_SPR		( GPIO_PORTA | 27 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA28_PF_HSYNC		( GPIO_PORTA | 28 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA29_PF_VSYNC		( GPIO_PORTA | 29 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA30_PF_CONTRAST	( GPIO_PORTA | 30 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA31_PF_OE_ACD		( GPIO_PORTA | 31 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+
+/*
+ *  Freescale i.MX21 register defines
+ *
+ *  All register and field defines should conform to the following naming
+ *  convention, and preferably use the exact names from the corresponding
+ *  datasheets. 
+ *
+ *  #define <module>_<register>		<value>
+ *  #define <register>_<field><type>	<value>
+ *
+ *  Where <type> can be one of the following.
+ *
+ *  _POS = defines the field LSB bit position	
+ *  _MASK = defines the field mask
+ *  (x) = writes x to the field location
+ *
+ *  The POS and MASK entries will be defined on an as needed basis. 
+ */
+
+/*
+ *  Freescale i.MX21 clock controller registers
+ */
+
+#define CRM_CSCR	__REG(MX2ADS_CRM_BASE + 0x0)
+#define CSCR_PRESC_MASK		(0x7<<29)
+#define CSCR_PRESC(x)		(((x) & 0x7) << 29)
+#define CSCR_USB_DIV_MASK	(0x7<<26)
+#define CSCR_USB_DIV(x)		(((x) & 0x7) << 26)
+#define CSCR_SD_CNT_MASK	(0x3<<24)
+#define CSCR_SD_CNT(x)		(((x) & 0x3) << 24)
+#define CSCR_SPLL_RESTART	(1<<22)
+#define CSCR_MPLL_RESTART	(1<<21)
+#define CSCR_SSI2_SEL		(1<<20)
+#define CSCR_SSI1_SEL		(1<<19)
+#define CSCR_FIR_SEL		(1<<18)
+#define CSCR_SP_SEL		(1<<17)
+#define CSCR_MCU_SEL		(1<<16)
+#define CSCR_BCLKDIV_MASK	(0xf<<10)
+#define CSCR_BCLKDIV(x)		(((x) & 0xf) << 10)
+#define CSCR_IPDIV		(1<<9)
+#define CSCR_OSC26M_DIV1P5	(1<<4)
+#define CSCR_OSC28M_DIS		(1<<3)
+#define CSCR_FPM_EN		(1<<2)
+#define CSCR_SPEN		(1<<1)
+#define CSCR_MPEN		(1<<0)
+
+#define CRM_MPCTL0	__REG(MX2ADS_CRM_BASE + 0x4)
+#define MPCTL0_CPLM		(1<<31)
+#define MPCTL0_PD(x)		(((x) & 0xf) << 26)
+#define MPCTL0_MFD(x)		(((x) & 0x3ff) << 16)
+#define MPCTL0_MFI(x)		(((x) & 0xf) << 10)
+#define MPCTL0_MFN(x)		(((x) & 0x3ff) << 0)
+
+#define CRM_MPCTL1	__REG(MX2ADS_CRM_BASE + 0x8)
+#define MPCTL1_LF		(1<<15)
+#define MPCTL1_BRMO		(1<<6)
+
+#define CRM_SPCTL0	__REG(MX2ADS_CRM_BASE + 0xc)
+#define SPCTL0_CPLM		(1<<31)
+#define SPCTL0_PD(x)		(((x) & 0xf) << 26)
+#define SPCTL0_MFD(x)		(((x) & 0x3ff) << 16)
+#define SPCTL0_MFI(x)		(((x) & 0xf) << 10)
+#define SPCTL0_MFN(x)		(((x) & 0x3ff) << 0)
+
+#define CRM_SPCTL1	__REG(MX2ADS_CRM_BASE + 0x10)
+#define SPCTL1_LF		(1<<15)
+#define SPCTL1_BRMO		(1<<6)
+
+#define CRM_OSC26MCTL	__REG(MX2ADS_CRM_BASE + 0x14)
+#define OSC26MCTL_OSC26M_PEAK	(0x2<<16)
+#define OSC25MCTL_AGC(x)	(((x) & 0x3f) << 8)
+
+#define CRM_PCDR0	__REG(MX2ADS_CRM_BASE + 0x18)
+#define PCDR0_SSI2DIV(x)	(((x) & 0x3f) << 26)
+#define PCDR0_SSI1DIV(x)	(((x) & 0x3f) << 16)
+#define PCDR0_NFCDIV(x)		(((x) & 0xf) << 12)
+#define PCDR0_CLKO_48MDIV(x)	(((x) & 0x7) << 5)
+#define PCDR0_FIRI_DIV(x)	(((x) & 0x1f) << 0)
+		
+#define CRM_PCDR1	__REG(MX2ADS_CRM_BASE + 0x1c)
+#define PCDR1_PERDIV4_POS	24
+#define PCDR1_PERDIV4_MASK	(0x3f << PCDR1_PERDIV4_POS)
+#define PCDR1_PERDIV4(x)	(((x) << PCDR1_PERDIV4_POS) & PCDR1_PERDIV4_MASK)
+#define PCDR1_PERDIV3_POS	16
+#define PCDR1_PERDIV3_MASK	(0x3f << PCDR1_PERDIV3_POS)
+#define PCDR1_PERDIV3(x) 	(((x) << PCDR1_PERDIV3_POS) & PCDR1_PERDIV3_MASK)
+#define PCDR1_PERDIV2_POS	8
+#define PCDR1_PERDIV2_MASK	(0x3f << PCDR1_PERDIV2_POS)
+#define PCDR1_PERDIV2(x) 	(((x) << PCDR1_PERDIV2_POS) & PCDR1_PERDIV2_MASK)
+#define PCDR1_PERDIV1_POS	0
+#define PCDR1_PERDIV1_MASK	(0x3f << PCDR1_PERDIV1_POS)
+#define PCDR1_PERDIV1(x) 	(((x) << PCDR1_PERDIV1_POS) & PCDR1_PERDIV1_MASK)
+
+#define CRM_PCCR0	__REG(MX2ADS_CRM_BASE + 0x20) 
+#define PCCR0_HCLK_CSI_EN 	(1<<31)
+#define PCCR0_HCLK_DMA_EN 	(1<<30)
+#define PCCR0_HCLK_BROM_EN 	(1<<28)
+#define PCCR0_HCLK_EMMA_EN 	(1<<27)
+#define PCCR0_HCLK_LCDC_EN 	(1<<26)
+#define PCCR0_HCLK_SLCDC_EN 	(1<<25)
+#define PCCR0_HCLK_USBOTG_EN 	(1<<24)
+#define PCCR0_HCLK_BMI_EN 	(1<<23)
+#define PCCR0_PERCLK4_EN 	(1<<22)
+#define PCCR0_SLCDC_EN	 	(1<<21)
+#define PCCR0_FIRI_BAUD_EN 	(1<<20)
+#define PCCR0_NFC_EN		(1<<19)
+#define PCCR0_PERCLK3_EN 	(1<<18)
+#define PCCR0_SSI1_BAUD_EN 	(1<<17)
+#define PCCR0_SSI2_BAUD_EN 	(1<<16)
+#define PCCR0_EMMA_EN 		(1<<15)
+#define PCCR0_USBOTG_EN	 	(1<<14)
+#define PCCR0_DMA_EN 		(1<<13)
+#define PCCR0_I2C_EN 		(1<<12)
+#define PCCR0_GPIO_EN	 	(1<<11)
+#define PCCR0_SDHC2_EN	 	(1<<10)
+#define PCCR0_SDHC1_EN	 	(1<<9)
+#define PCCR0_FIRI_EN	 	(1<<8)
+#define PCCR0_SSI2_EN	 	(1<<7)
+#define PCCR0_SSI1_EN		(1<<6)
+#define PCCR0_CSPI2_EN	 	(1<<5)
+#define PCCR0_CSPI1_EN	 	(1<<4)
+#define PCCR0_UART4_EN	 	(1<<3)
+#define PCCR0_UART3_EN	 	(1<<2)
+#define PCCR0_UART2_EN 		(1<<1)
+#define PCCR0_UART1_EN	 	(1<<0)
+
+#define CRM_PCCR1	__REG(MX2ADS_CRM_BASE + 0x24)
+#define PCCR1_OWIRE_EN		(1<<31)
+#define PCCR1_KPP_EN		(1<<30)
+#define PCCR1_RTC_EN		(1<<29)
+#define PCCR1_PWM_EN		(1<<28)
+#define PCCR1_GPT3_EN		(1<<27)
+#define PCCR1_GPT2_EN		(1<<26)
+#define PCCR1_GPT1_EN		(1<<25)
+#define PCCR1_WDT_EN		(1<<24)
+#define PCCR1_CSPI3_EN		(1<<23)
+#define PCCR1_RTIC_EN		(1<<22)
+#define PCCR1_RNGA_EN		(1<<21)
+
+#define CRM_CCSR	__REG(MX2ADS_CRM_BASE + 0x28)
+#define CCSR_32K_SR		(1<<15)
+#define CCSR_CLK0_SEL(x)	(((x) & 0x1f) << 0)
+	
+#define CRM_WKGDCTL	__REG(MX2ADS_CRM_BASE + 0x34)
+#define WKGDCTL_WKDG_EN		(1<<0)
+
+/*
+ * LCD controller (LCDC) registers
+ */
+
+#define LCDC_LSSAR	__REG(MX2ADS_LCDC_BASE + 0x0)
+#define LSSAR_SSA(x)		(((x) & 0x3fffffff) << 2)
+
+#define LCDC_LSR 	__REG(MX2ADS_LCDC_BASE + 0x4)
+#define LSR_XMAX(x)		(((x) & 0x3f) << 20)
+#define LSR_YMAX(x)		(((x) & 0x3ff) << 0)
+
+#define LCDC_LVPWR 	__REG(MX2ADS_LCDC_BASE + 0x8)
+#define LVPWR_VPW(x)		(((x) & 0x3ff) << 0)
+
+#define LCDC_LCPR 	__REG(MX2ADS_LCDC_BASE + 0xc)
+#define LCPR_CC(x)		(((x) & 0x3) << 30)
+#define LCPR_OP			(1<<28)
+#define LCPR_CXP(x)		(((x) & 0x3ff) << 16)
+#define LCPR_CYP(x)		(((x) & 0x3ff) << 0)
+
+#define LCPR_CC_DISABLED	0
+#define LCPR_CC_OR		1
+#define LCPR_CC_XOR		2
+#define LCPR_CC_AND		3
+
+#define LCDC_LCWHBR 	__REG(MX2ADS_LCDC_BASE + 0x10)
+#define LCWHBR_BK_EN		(1<<31)
+#define LCWHBR_CW(x)		(((x) & 0x1f) << 24)
+#define LCWHBR_CH(x)		(((x) & 0x1f) << 16)
+#define LCWHBR_BD(x)		(((x) & 0xff) << 0)
+
+#define LCDC_LCCMR 	__REG(MX2ADS_LCDC_BASE + 0x14)
+#define LCCMR_CUR_COL_R(x)	(((x) & 0x3f) << 12)
+#define LCCMR_CUR_COL_G(x)	(((x) & 0x3f) << 6)
+#define LCCMR_CUR_COL_B(x)	(((x) & 0x3f) << 0)
+
+#define LCDC_LPCR 	__REG(MX2ADS_LCDC_BASE + 0x18)
+#define LPCR_TFT		(1<<31)
+#define LPCR_COLOR		(1<<30)
+#define LPCR_PBSIZ_POS		28
+#define LPCR_PBSIZ_MASK		(0x3 << LPCR_PBSIZ_POS)
+#define LPCR_PBSIZ(x)		(((x) << LPCR_PBSIZ_POS) & LPCR_PBSIZ_MASK)
+#define LPCR_BPIX_POS		25
+#define LPCR_BPIX_MASK		(0x7 << LPCR_BPIX_POS)
+#define LPCR_BPIX(x)		(((x) << LPCR_BPIX_POS) & LPCR_BPIX_MASK)
+#define LPCR_PIXPOL		(1<<24)
+#define LPCR_FLMPOL		(1<<23)
+#define LPCR_LPPOL		(1<<22)
+#define LPCR_CLKPOL		(1<<21)
+#define LPCR_OEPOL		(1<<20)
+#define LPCR_SCLKIDLE		(1<<19)
+#define LPCR_END_SEL		(1<<18)
+#define LPCR_SWAP_SEL		(1<<17)
+#define LPCR_REV_VS		(1<<16)
+#define LPCR_ACDSEL		(1<<15)
+#define LPCR_ACD(x)		(((x) & 0x7f) << 8)
+#define LPCR_SCLKSEL		(1<<7)
+#define LPCR_SHARP		(1<<6)
+#define LPCR_PCD(x)		(((x) & 0x3f) << 0)
+
+#define LPCR_PBSIZ_PANEL_BUS_WIDTH_1	0
+#define LPCR_PBSIZ_PANEL_BUS_WIDTH_4	2
+#define LPCR_PBSIZ_PANEL_BUS_WIDTH_8	3
+
+#define LPCR_BPIX_BITS_PER_PIXEL_1	0
+#define LPCR_BPIX_BITS_PER_PIXEL_2	1
+#define LPCR_BPIX_BITS_PER_PIXEL_4	2
+#define LPCR_BPIX_BITS_PER_PIXEL_8	3
+#define LPCR_BPIX_BITS_PER_PIXEL_12	4
+#define LPCR_BPIX_BITS_PER_PIXEL_16	5
+#define LPCR_BPIX_BITS_PER_PIXEL_18	6
+
+#define LCDC_LHCR 	__REG(MX2ADS_LCDC_BASE + 0x1c)
+#define LHCR_H_WIDTH(x)		(((x) & 0x3f) << 26)
+#define LHCR_H_WAIT_1(x)	(((x) & 0x1ff) << 8)
+#define LHCR_H_WAIT_2(x)	(((x) & 0x1ff) << 0)
+
+#define LCDC_LVCR 	__REG(MX2ADS_LCDC_BASE + 0x20)
+#define LVCR_V_WIDTH(x)		(((x) & 0x3f) << 26)
+#define LVCR_V_WAIT_1(x)	(((x) & 0x1ff) << 8)
+#define LVCR_V_WAIT_2(x)	(((x) & 0x1ff) << 0)
+
+#define LCDC_LPOR 	__REG(MX2ADS_LCDC_BASE + 0x24)
+#define LPOR_POS(x)		(((x) & 0x1f) << 0)
+
+#define LCDC_LSCR 	__REG(MX2ADS_LCDC_BASE + 0x28)
+#define LSCR_PS_RISE_DELAY(x)		(((x) & 0x3f) << 26)
+#define LSCR_CLS_RISE_DELAY(x)		(((x) & 0xff) << 16)
+#define LSCR_REV_TOGGLE_DELAY(x)	(((x) & 0xf) << 8)
+#define LSCR_GRAY2(x)			(((x) & 0xf) << 4)
+#define LSCR_GRAY1(x)			(((x) & 0xf) << 0)
+
+#define LCDC_LPCCR 	__REG(MX2ADS_LCDC_BASE + 0x2c)
+#define LPCCR_CLS_HI_WIDTH(x)	(((x) & 0x1ff) << 16)
+#define LPCCR_LDMSK		(1<<15)
+#define LPCCR_SCR(x)		(((x) & 0x3) << 9)
+#define LPCCR_CC_EN		(1<<8)
+#define LPCCR_PW(x)		(((x) & 0xff) << 0)
+
+#define LPCCR_SCR_LINE_PULSE	0
+#define LPCCR_SCR_PIXEL_CLOCK	1
+#define LPCCR_SCR_LCD_CLOCK	2
+
+#define LCDC_LDCR 	__REG(MX2ADS_LCDC_BASE + 0x30)
+#define LDCR_BURST		(1<<31)
+#define LDCR_HM(x)		(((x) & 0x1f) << 16)
+#define LDCR_TM(x)		(((x) & 0x1f) << 0)
+
+#define LCDC_LRMCR 	__REG(MX2ADS_LCDC_BASE + 0x34)
+#define LRMCR_SELF_REF		(1<<0)
+
+#define LCDC_LICR 	__REG(MX2ADS_LCDC_BASE + 0x38)
+#define LICR_GW_INIT_CON	(1<<4)
+#define LICR_INTSYN		(1<<2)
+#define LICR_INTCON		(1<<0)
+
+#define LCDC_LIER 	__REG(MX2ADS_LCDC_BASE + 0x3c)
+#define LIER_GW_UDR_ERR_EN	(1<<7)
+#define LIER_GW_ERR_RES_EN	(1<<6)
+#define LIER_GW_EOF_EN		(1<<5)
+#define LIER_GW_BOF_EN		(1<<4)
+#define LIER_UDR_ERR_EN		(1<<3)
+#define LIER_ERR_RES_EN		(1<<2)
+#define LIER_EOF_EN		(1<<1)
+#define LIER_BOF_EN		(1<<0)
+
+#define LCDC_LISR 	__REG(MX2ADS_LCDC_BASE + 0x40)
+#define LISR_GW_UDR_ERR_MASK	(1<<7)
+#define LISR_GW_ERR_RES_MASK	(1<<6)
+#define LISR_GW_EOF_MASK	(1<<5)
+#define LISR_GW_BOF_MASK	(1<<4)
+#define LISR_UDR_ERR_MASK	(1<<3)
+#define LISR_ERR_RES_MASK	(1<<2)
+#define LISR_EOF_MASK		(1<<1)
+#define LISR_BOF_MASK		(1<<0)
+
+#define LCDC_LGWSAR 	__REG(MX2ADS_LCDC_BASE + 0x50)
+#define LGWSAR_GWSA(x)		(((x) & 0x3fffffff) << 2)
+
+#define LCDC_LGWSR 	__REG(MX2ADS_LCDC_BASE + 0x54)
+#define LGWSR_GWW(x)		(((x) & 0x3f) << 20)
+#define LGWSR_GWH(x)		(((x) & 0x3fff) << 0)
+
+#define LCDC_LGWVPWR 	__REG(MX2ADS_LCDC_BASE + 0x58)
+#define LGWVPWR_GWVPW(x)	(((x) & 0x3ff) << 0)
+
+#define LCDC_LGWPOR 	__REG(MX2ADS_LCDC_BASE + 0x5c)
+#define LGWPOR(x)		(((x) & 0x1f) << 0)
+
+#define LCDC_LGWPR 	__REG(MX2ADS_LCDC_BASE + 0x60)
+#define LGWPR_GWXP(x)		(((x) & 0x3ff) << 16)
+#define LGWPR_GWYP(x)		(((x) & 0x3ff) << 0)
+
+#define LCDC_LGWCR 	__REG(MX2ADS_LCDC_BASE + 0x64)
+#define LGWCR_GWAV(x)		(((x) & 0xff) << 24)
+#define LGWCR_GWCKE		(1<<23)
+#define LGWCR_GWE		(1<<22)
+#define LGWCR_GW_RVS		(1<<21)
+#define LGWCR_GWCKR(x)		(((x) & 0x3f) << 12)
+#define LGWCR_GWCKG(x)		(((x) & 0x3f) << 6)
+#define LGWCR_GWCKB(x)		(((x) & 0x3f) << 0)
+
+#define LCDC_LGWDCR 	__REG(MX2ADS_LCDC_BASE + 0x68)
+#define LGWDCR_GWBT		(1<<31)
+#define LGWDCR_GWHM(x)		(((x) & 0x1f) << 16)
+#define LGWDCR_GWTM(x)		(((x) & 0x1f) << 0)
+
+/*
+ *  General purpose timers
+ */
+
+#define WHICH_TIMER(x)     ((x)*0x1000)
+#define IMX21_TCTL(x)        __REG( 0x00 + MX2ADS_GPT1_BASE + WHICH_TIMER(x) )
+#define TCTL_SWR           (1<<15)
+#define TCTL_FRR           (1<<8)
+#define TCTL_CAP_RIS       (1<<6)
+#define TCTL_CAP_FAL       (2<<6)
+#define TCTL_CAP_RIS_FAL   (3<<6)
+#define TCTL_OM            (1<<5)
+#define TCTL_IRQEN         (1<<4)
+#define TCTL_CLK_PCLK1     (1<<1)
+#define TCTL_CLK_PCLK1_16  (2<<1)
+#define TCTL_CLK_TIN       (3<<1)
+#define TCTL_CLK_32        (4<<1)
+#define TCTL_TEN           (1<<0)
+
+#define IMX21_TPRER(x)       __REG( 0x04 + MX2ADS_GPT1_BASE + WHICH_TIMER(x))
+#define IMX21_TCMP(x)        __REG( 0x08 + MX2ADS_GPT1_BASE + WHICH_TIMER(x))
+#define IMX21_TCR(x)         __REG( 0x0C + MX2ADS_GPT1_BASE + WHICH_TIMER(x))
+#define IMX21_TCN(x)         __REG( 0x10 + MX2ADS_GPT1_BASE + WHICH_TIMER(x))
+#define IMX21_TSTAT(x)       __REG( 0x14 + MX2ADS_GPT1_BASE + WHICH_TIMER(x))
+#define TSTAT_CAPT         (1<<1)
+#define TSTAT_COMP         (1<<0)
+
+#define GPT1		0
+#define GPT2		1
+#define GPT3		2
+
+/*
+ *  Uart controller registers 
+ */
+
+#define UART_1  0
+#define UART_2  1
+#define UART_3  2
+#define UART_4  3
+
+
+#define URXD0(x) __REG( 0x0 + (x)) /* Receiver Register */
+#define URTX0(x) __REG( 0x40 + (x)) /* Transmitter Register */
+#define UCR1(x)  __REG( 0x80 + (x)) /* Control Register 1 */
+#define UCR2(x)  __REG( 0x84 + (x)) /* Control Register 2 */
+#define UCR3(x)  __REG( 0x88 + (x)) /* Control Register 3 */
+#define UCR4(x)  __REG( 0x8c + (x)) /* Control Register 4 */
+#define UFCR(x)  __REG( 0x90 + (x)) /* FIFO Control Register */
+#define USR1(x)  __REG( 0x94 + (x)) /* Status Register 1 */
+#define USR2(x)  __REG( 0x98 + (x)) /* Status Register 2 */
+#define UESC(x)  __REG( 0x9c + (x)) /* Escape Character Register */
+#define UTIM(x)  __REG( 0xa0 + (x)) /* Escape Timer Register */
+#define UBIR(x)  __REG( 0xa4 + (x)) /* BRM Incremental Register */
+#define UBMR(x)  __REG( 0xa8 + (x)) /* BRM Modulator Register */
+#define UBRC(x)  __REG( 0xac + (x)) /* Baud Rate Count Register */
+#define ONMES(x) __REG( 0xb0 + (x)) /* One Millisecond Register */
+#define UTS(x)   __REG( 0xb4 + (x)) /* UART Test Register */
+
+
+
+/* UART Control Register Bit Fields.*/
+#define  URXD_CHARRDY    (1<<15)
+#define  URXD_ERR        (1<<14)
+#define  URXD_OVRRUN     (1<<13)
+#define  URXD_FRMERR     (1<<12)
+#define  URXD_BRK        (1<<11)
+#define  URXD_PRERR      (1<<10)
+
+#define  UCR1_ADEN       (1<<15) /* Auto dectect interrupt */
+#define  UCR1_ADBR       (1<<14) /* Auto detect baud rate */
+#define  UCR1_TRDYEN     (1<<13) /* Transmitter ready interrupt enable */
+#define  UCR1_IDEN       (1<<12) /* Idle condition interrupt */
+#define  UCR1_RRDYEN     (1<<9)	 /* Recv ready interrupt enable */
+#define  UCR1_RDMAEN     (1<<8)	 /* Recv ready DMA enable */
+#define  UCR1_IREN       (1<<7)	 /* Infrared interface enable */
+#define  UCR1_TXMPTYEN   (1<<6)	 /* Transimitter empty interrupt enable */
+#define  UCR1_RTSDEN     (1<<5)	 /* RTS delta interrupt enable */
+#define  UCR1_SNDBRK     (1<<4)	 /* Send break */
+#define  UCR1_TDMAEN     (1<<3)	 /* Transmitter ready DMA enable */
+// not on mx21 #define  UCR1_UARTCLKEN  (1<<2)	 /* UART clock enabled */
+#define  UCR1_DOZE       (1<<1)	 /* Doze */
+#define  UCR1_UARTEN     (1<<0)	 /* UART enabled */
+
+#define  UCR2_ESCI     	 (1<<15) /* Escape seq interrupt enable */
+#define  UCR2_IRTS  	 (1<<14) /* Ignore RTS pin */
+#define  UCR2_CTSC  	 (1<<13) /* CTS pin control */
+#define  UCR2_CTS        (1<<12) /* Clear to send */
+#define  UCR2_ESCEN      (1<<11) /* Escape enable */
+#define  UCR2_PREN       (1<<8)  /* Parity enable */
+#define  UCR2_PROE       (1<<7)  /* Parity odd/even */
+#define  UCR2_STPB       (1<<6)	 /* Stop */
+#define  UCR2_WS         (1<<5)	 /* Word size */
+#define  UCR2_RTSEN      (1<<4)	 /* Request to send interrupt enable */
+#define  UCR2_ATEN	 (1<<3)  /* Aging Timer Enable */
+#define  UCR2_TXEN       (1<<2)	 /* Transmitter enabled */
+#define  UCR2_RXEN       (1<<1)	 /* Receiver enabled */
+#define  UCR2_SRST 	 (1<<0)	 /* SW reset */
+
+#define  UCR3_DTREN 	 (1<<13) /* DTR interrupt enable */
+#define  UCR3_PARERREN   (1<<12) /* Parity enable */
+#define  UCR3_FRAERREN   (1<<11) /* Frame error interrupt enable */
+#define  UCR3_DSR        (1<<10) /* Data set ready */
+#define  UCR3_DCD        (1<<9)  /* Data carrier detect */
+#define  UCR3_RI         (1<<8)  /* Ring indicator */
+#define  UCR3_ADNIMP     (1<<7)  /* Timeout interrupt enable */
+#define  UCR3_RXDSEN	 (1<<6)  /* Receive status interrupt enable */
+#define  UCR3_AIRINTEN   (1<<5)  /* Async IR wake interrupt enable */
+#define  UCR3_AWAKEN	 (1<<4)  /* Async wake interrupt enable */
+// not on mx21 #define  UCR3_REF25 	 (1<<3)  /* Ref freq 25 MHz */
+#define  UCR3_RXDMUXSEL  (1<<2)  /* RXD Mux Input Select */
+#define  UCR3_INVT  	 (1<<1)  /* Inverted Infrared transmission */
+#define  UCR3_ACIEN  	 (1<<0)  /* Autobaud Counter  Interrupt Enable */
+
+
+#define  UCR4_INVR  	 (1<<9)  /* Inverted infrared reception */
+#define  UCR4_ENIRI 	 (1<<8)  /* Serial infrared interrupt enable */
+#define  UCR4_WKEN  	 (1<<7)  /* Wake interrupt enable */
+// not on mx21 #define  UCR4_REF16 	 (1<<6)  /* Ref freq 16 MHz */
+#define  UCR4_IRSC  	 (1<<5)  /* IR special case */
+#define  UCR4_LPBYP  	 (1<<5)  /* Low Power Bypass */
+#define  UCR4_TCEN  	 (1<<3)  /* Transmit complete interrupt enable */
+#define  UCR4_BKEN  	 (1<<2)  /* Break condition interrupt enable */
+#define  UCR4_OREN  	 (1<<1)  /* Receiver overrun interrupt enable */
+#define  UCR4_DREN  	 (1<<0)  /* Recv data ready interrupt enable */
+
+#define  UFCR_RXTL_SHF   0       /* Receiver trigger level shift */
+#define  UFCR_RFDIV      (7<<7)  /* Reference freq divider mask */
+#define  UFCR_RFDIV_SHF  7	 /* Reference freq divider shift */
+#define  UFCR_TXTL_SHF   10      /* Transmitter trigger level shift */
+#define  UFCR_DCEDTE	 (1<<6)  /* DCE/DTE Mode */
+
+#define  USR1_PARITYERR  (1<<15) /* Parity error interrupt flag */
+#define  USR1_RTSS  	 (1<<14) /* RTS pin status */
+#define  USR1_TRDY  	 (1<<13) /* Transmitter ready interrupt/dma flag */
+#define  USR1_RTSD  	 (1<<12) /* RTS delta */
+#define  USR1_ESCF  	 (1<<11) /* Escape seq interrupt flag */
+#define  USR1_FRAMERR    (1<<10) /* Frame error interrupt flag */
+#define  USR1_RRDY       (1<<9)	 /* Receiver ready interrupt/dma flag */
+#define  USR1_AGTIM      (1<<8)	 /* Aging Timer Interrupt Flag */
+// not on mx21 #define  USR1_TIMEOUT    (1<<7)	 /* Receive timeout interrupt status */
+#define  USR1_RXDS  	 (1<<6)	 /* Receiver idle interrupt flag */
+#define  USR1_AIRINT	 (1<<5)	 /* Async IR wake interrupt flag */
+#define  USR1_AWAKE 	 (1<<4)	 /* Aysnc wake interrupt flag */
+
+#define  USR2_ADET  	 (1<<15) /* Auto baud rate detect complete */
+#define  USR2_TXFE  	 (1<<14) /* Transmit buffer FIFO empty */
+#define  USR2_DTRF  	 (1<<13) /* DTR edge interrupt flag */
+#define  USR2_IDLE  	 (1<<12) /* Idle condition */
+#define  USR2_ACST  	 (1<<11) /* Autobaud Controller Stopped*/
+#define  USR2_RIDELT  	 (1<<10) /* Ring Indicator Delta */
+#define  USR2_RIIN  	 (1<<9)  /* Ring Indicator Input*/
+#define  USR2_IRINT 	 (1<<8)	 /* Serial infrared interrupt flag */
+#define  USR2_WAKE  	 (1<<7)	 /* Wake */
+#define  USR2_DCDDELT  	 (1<<6)	 /* Data Carrier Delta Detect */
+#define  USR2_DCDIN  	 (1<<5)	 /* Data Carrier Detect Input */
+#define  USR2_RTSF  	 (1<<4)	 /* RTS edge interrupt flag */
+#define  USR2_TXDC  	 (1<<3)	 /* Transmitter complete */
+#define  USR2_BRCD  	 (1<<2)	 /* Break condition */
+#define  USR2_ORE        (1<<1)	 /* Overrun error */
+#define  USR2_RDR        (1<<0)	 /* Recv data ready */
+
+#define  UTS_FRCPERR	 (1<<13) /* Force parity error */
+#define  UTS_LOOP        (1<<12) /* Loop tx and rx */
+#define  UTS_DBGEN       (1<<11) /* /Debug Enable */
+#define  UTS_LOOPIR      (1<<10) /* Loop tx and rx for IR */
+#define  UTS_RXFIFO	 (1<<9)	 /* RXFifo Debug */
+#define  UTS_TXEMPTY	 (1<<6)	 /* TxFIFO empty */
+#define  UTS_RXEMPTY	 (1<<5)	 /* RxFIFO empty */
+#define  UTS_TXFULL 	 (1<<4)	 /* TxFIFO full */
+#define  UTS_RXFULL 	 (1<<3)	 /* RxFIFO full */
+#define  UTS_SOFTRST	 (1<<0)	 /* Software reset */
+
+#endif				// _MX2ADS_REGS_H
diff -NaurbB linux-2.6.14_original/include/asm-arm/arch-imx21/io.h linux-2.6.14_imx21/include/asm-arm/arch-imx21/io.h
--- linux-2.6.14_original/include/asm-arm/arch-imx21/io.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/include/asm-arm/arch-imx21/io.h	2006-04-11 10:29:12.000000000 +0200
@@ -0,0 +1,28 @@
+/*
+ *  linux/include/asm-arm/arch-imx21/io.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+#define __io(a)		((void __iomem *)(a))
+#define __mem_pci(a)	(a)
+
+#endif
diff -NaurbB linux-2.6.14_original/include/asm-arm/arch-imx21/irq.h linux-2.6.14_imx21/include/asm-arm/arch-imx21/irq.h
--- linux-2.6.14_original/include/asm-arm/arch-imx21/irq.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/include/asm-arm/arch-imx21/irq.h	2006-04-11 10:29:12.000000000 +0200
@@ -0,0 +1,20 @@
+/*
+ *  linux/include/asm-arm/arch-imx21/irq.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define fixup_irq(i)	(i)
diff -NaurbB linux-2.6.14_original/include/asm-arm/arch-imx21/irqs.h linux-2.6.14_imx21/include/asm-arm/arch-imx21/irqs.h
--- linux-2.6.14_original/include/asm-arm/arch-imx21/irqs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/include/asm-arm/arch-imx21/irqs.h	2006-04-11 10:29:12.000000000 +0200
@@ -0,0 +1,127 @@
+/*
+ *  linux/include/asm-arm/arch-imx21/irqs.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *
+ * Modified By: Ron Melvin (ron.melvin@timesys.com)
+ * Copyright (C) 2005 TimeSys Corporation 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ARM_IRQS_H__
+#define __ARM_IRQS_H__
+
+/* Use the imx definitions */
+#include <asm/arch/hardware.h>
+
+/*
+ *  IMX21 Interrupt numbers
+ *
+ */
+
+#define INT_CSPI3		    6
+#define INT_SRCL		    7
+#define INT_GPIO                    8
+#define INT_FIRI                    9
+#define INT_SDHC2                   10
+#define INT_SDHC1                   11
+#define INT_I2C                     12
+#define INT_SSI2                    13
+#define INT_SSI1                    14
+#define INT_CSPI2                   15
+#define INT_CSPI1                   16
+#define INT_UART4                   17
+#define INT_UART3                   18
+#define INT_UART2                   19
+#define INT_UART1                   20
+#define INT_KPP_TX                  21
+#define INT_RTC_RX                  22
+#define INT_PWM                     23
+#define INT_GPT3                    24
+#define INT_GPT2                    25
+#define INT_GPT1                    26
+#define INT_WDOG                    27
+#define INT_PCMCIA                  28
+#define INT_NFC                     29
+#define INT_BMI                     30
+#define INT_CSI                     31
+#define INT_DMACH0                  32
+#define INT_DMACH1                  33
+#define INT_DMACH2                  34
+#define INT_DMACH3                  35
+#define INT_DMACH4                  36
+#define INT_DMACH5                  37
+#define INT_DMACH6                  38
+#define INT_DMACH7                  39
+#define INT_DMACH8                  40
+#define INT_DMACH9                  41
+#define INT_DMACH10                 42
+#define INT_DMACH11                 43
+#define INT_DMACH12                 44
+#define INT_DMACH13                 45
+#define INT_DMACH14                 46
+#define INT_DMACH15                 47
+#define INT_EMMAENC                 49
+#define INT_EMMADEC                 50
+#define INT_EMMAPRP                 51
+#define INT_EMMAPP                  52
+#define INT_USBWKUP                 53
+#define INT_USBMNP                  54
+#define INT_USBDMA                  55
+#define INT_USBFUNC                 56
+#define INT_USBHOST                 57
+#define INT_USBCTRL                 58
+#define INT_SAHARA                  59
+#define INT_SLCDC                   60
+#define INT_LCDC                    61
+
+
+#define IMX21_IRQS		    (64)
+
+/* note: the IMX21 has six gpio ports (A-F), but only
+ *       the following pins are connected to the outside
+ *       world:
+ *
+ * PORT A: bits 0-31
+ * PORT B: bits 8-31
+ * PORT C: bits 3-17
+ * PORT D: bits 6-31
+ * PORT E:
+ * PORT F: bits 0-31 (NAND Flash)
+ *
+ * We map these interrupts straight on. As a result we have
+ * several holes in the interrupt mapping. We do this for two
+ * reasons:
+ *   - mapping the interrupts without holes would get
+ *     far more complicated
+ *   - Motorola could well decide to bring some processor
+ *     with more pins connected
+ */
+
+#define IRQ_GPIOA(x)  (IMX21_IRQS + x)
+#define IRQ_GPIOB(x)  (IRQ_GPIOA(32) + x)
+#define IRQ_GPIOC(x)  (IRQ_GPIOB(32) + x)
+#define IRQ_GPIOD(x)  (IRQ_GPIOC(32) + x)
+#define IRQ_GPIOE(x)  (IRQ_GPIOD(32) + x)
+#define IRQ_GPIOF(x)  (IRQ_GPIOE(32) + x)
+
+/* decode irq number to use with IMR(x), ISR(x) and friends */
+#define IRQ_TO_REG(irq) ((irq - IMX21_IRQS) >> 5)
+
+#define NR_IRQS (IRQ_GPIOF(32) + 1)
+#define IRQ_GPIO(x)
+#endif
diff -NaurbB linux-2.6.14_original/include/asm-arm/arch-imx21/memory.h linux-2.6.14_imx21/include/asm-arm/arch-imx21/memory.h
--- linux-2.6.14_original/include/asm-arm/arch-imx21/memory.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/include/asm-arm/arch-imx21/memory.h	2006-04-11 10:29:12.000000000 +0200
@@ -0,0 +1,41 @@
+/*
+ *  linux/include/asm-arm/arch-imx21/memory.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *  Copyright (C) 2002 Shane Nay (shane@minirl.com)
+ *
+ * Modified By: Ron Melvin (ron.melvin@timesys.com)
+ * Copyright (C) 2005 TimeSys Corporation 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_MMU_H
+#define __ASM_ARCH_MMU_H
+
+#define PHYS_OFFSET	(0xc0000000UL)
+
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *              address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *              to an address that the kernel can use.
+ */
+#define __virt_to_bus__is_a_macro
+#define __virt_to_bus(x)	(x - PAGE_OFFSET +  PHYS_OFFSET)
+#define __bus_to_virt__is_a_macro
+#define __bus_to_virt(x)	(x -  PHYS_OFFSET + PAGE_OFFSET)
+
+#endif
diff -NaurbB linux-2.6.14_original/include/asm-arm/arch-imx21/mx2ads.h linux-2.6.14_imx21/include/asm-arm/arch-imx21/mx2ads.h
--- linux-2.6.14_original/include/asm-arm/arch-imx21/mx2ads.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/include/asm-arm/arch-imx21/mx2ads.h	2006-04-11 10:29:12.000000000 +0200
@@ -0,0 +1,39 @@
+/*
+ * linux/include/asm-arm/arch-imx21/mx2ads.h
+ *
+ * Copyright (C) 2004 Robert Schwebel, Pengutronix
+ *
+ * Modified By: Ron Melvin (ron.melvin@timesys.com)
+ * Copyright (C) 2005 TimeSys Corporation 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef __ASM_ARCH_MX2ADS_H
+#define __ASM_ARCH_MX2ADS_H
+
+/* ------------------------------------------------------------------------ */
+/* Memory Map for the M9328MX2ADS (MX2ADS) Board                            */
+/* ------------------------------------------------------------------------ */
+
+#define MX2ADS_FLASH_PHYS		0x10000000
+#define MX2ADS_FLASH_SIZE		(16*1024*1024)
+
+#define IMX_FB_PHYS			(0x0C000000 - 0x40000)
+
+#define CLK32 32768
+
+#endif /* __ASM_ARCH_MX2ADS_H */
diff -NaurbB linux-2.6.14_original/include/asm-arm/arch-imx21/param.h linux-2.6.14_imx21/include/asm-arm/arch-imx21/param.h
--- linux-2.6.14_original/include/asm-arm/arch-imx21/param.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/include/asm-arm/arch-imx21/param.h	2006-04-11 10:29:12.000000000 +0200
@@ -0,0 +1,19 @@
+/*
+ *  linux/include/asm-arm/arch-imx21/param.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
diff -NaurbB linux-2.6.14_original/include/asm-arm/arch-imx21/system.h linux-2.6.14_imx21/include/asm-arm/arch-imx21/system.h
--- linux-2.6.14_original/include/asm-arm/arch-imx21/system.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/include/asm-arm/arch-imx21/system.h	2006-04-11 10:29:12.000000000 +0200
@@ -0,0 +1,40 @@
+/*
+ *  linux/include/asm-arm/arch-imx21/system.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+static void
+arch_idle(void)
+{
+	/*
+	 * This should do all the clock switching
+	 * and wait for interrupt tricks
+	 */
+	cpu_do_idle();
+}
+
+static inline void
+arch_reset(char mode)
+{
+	cpu_reset(0);
+}
+
+#endif
diff -NaurbB linux-2.6.14_original/include/asm-arm/arch-imx21/timex.h linux-2.6.14_imx21/include/asm-arm/arch-imx21/timex.h
--- linux-2.6.14_original/include/asm-arm/arch-imx21/timex.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/include/asm-arm/arch-imx21/timex.h	2006-04-11 10:29:12.000000000 +0200
@@ -0,0 +1,27 @@
+/*
+ *  linux/include/asm-arm/imx/timex.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_TIMEX_H
+#define __ASM_ARCH_TIMEX_H
+
+#include <asm/arch/hardware.h>
+#define CLOCK_TICK_RATE		(CLK32)
+
+#endif
diff -NaurbB linux-2.6.14_original/include/asm-arm/arch-imx21/uncompress.h linux-2.6.14_imx21/include/asm-arm/arch-imx21/uncompress.h
--- linux-2.6.14_original/include/asm-arm/arch-imx21/uncompress.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/include/asm-arm/arch-imx21/uncompress.h	2006-04-11 10:29:12.000000000 +0200
@@ -0,0 +1,182 @@
+/*
+ *  linux/include/asm-arm/arch-imx21/uncompress.h
+ *
+ *
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *  Copyright (C) Shane Nay (shane@minirl.com)
+ *
+ * Modified By: Ron Melvin (ron.melvin@timesys.com)
+ * Copyright (C) 2005 TimeSys Corporation 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+#if 0		// TODO: use similar code (automatically pick port
+
+#define UART_TX  ((char *) (0xcc200000))
+#define UART_LSR ((char *) (0xcc200005))
+#if 1
+#define UARTDELAY { int x = 8000;		\
+	while (x--);				\
+    }	
+#else	
+#define UARTDELAY {				\
+	while ( ((*UART_LSR) & 0x20) ) {	\
+	    ;					\
+	}					\
+    }
+#endif
+void dputc(char c)
+{
+    UARTDELAY;
+    *UART_TX = c;
+}
+
+static void puts(const char *s)
+{
+    while (*s) {
+	dputc(*s);
+	if ( *s == '\n' ) {
+	    dputc('\r');
+	}
+	s++;
+    }
+}
+
+static void
+putstr(const char *s)
+{
+    puts(s);
+}
+
+void puthex(int x)
+{
+    int i;
+    char tmp[8];
+    
+    for ( i = 0; i <= 7; i++ ) {
+	int y = x & 0xf;
+	if ( y <= 9 )
+	    tmp[i] = y + '0';	    
+	else
+	    tmp[i] = y + 'a' - 10;
+	
+	x >>= 4;
+    }
+
+    puts("0x");
+    for ( i = 7; i >= 0; i-- ) {
+	dputc(tmp[i]);
+    }
+    
+}
+
+void pval(char *s, int v)
+{
+    puts(s);
+    puts(": ");
+    puthex(v);
+    puts("\n");
+    
+}
+
+
+#else		// orig 2.6 mx1 code:
+
+#define UART(x) (*(volatile unsigned long *)(serial_port + (x)))
+
+#define UART1_BASE 0x1000a000
+#define UART2_BASE 0x1000b000
+#define USR2 0x98
+#define USR2_TXFE (1<<14)
+#define TXR  0x40
+#define UCR1 0x80
+#define UCR1_UARTEN 1
+
+/*
+ * The following code assumes the serial port has already been
+ * initialized by the bootloader.  We search for the first enabled
+ * port in the most probable order.  If you didn't setup a port in
+ * your bootloader then nothing will appear (which might be desired).
+ *
+ * This does not append a newline
+ */
+static void
+putstr(const char *s)
+{
+	unsigned long serial_port;
+
+	do {
+		serial_port = UART1_BASE;
+		if ( UART(UCR1) & UCR1_UARTEN )
+			break;
+		serial_port = UART2_BASE;
+		if ( UART(UCR1) & UCR1_UARTEN )
+			break;
+		return;
+	} while(0);
+
+	while (*s) {
+		while ( !(UART(USR2) & USR2_TXFE) )
+			barrier();
+
+		UART(TXR) = *s;
+
+		if (*s == '\n') {
+			while ( !(UART(USR2) & USR2_TXFE) )
+				barrier();
+
+			UART(TXR) = '\r';
+		}
+		s++;
+	}
+}
+
+void puthex(int x)
+{
+    int i;
+    char tmp[8];
+    char num[11];
+    num[0]  = '0';
+    num[1]  = 'x';
+    num[10] = 0;
+
+    for ( i = 0; i <= 7; i++ ) {
+	int y = x & 0xf;
+	if ( y <= 9 )
+	    tmp[i] = y + '0';	    
+	else
+	    tmp[i] = y + 'a' - 10;
+	
+	x >>= 4;
+    }
+
+    for ( i = 7; i >= 0; i-- ) {
+        num[9-i] = tmp[i];
+    }
+
+    putstr(num);
+    
+}
+#endif		// TMP UART CODE....
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+
+#define arch_decomp_wdog()
diff -NaurbB linux-2.6.14_original/include/asm-arm/arch-imx21/vmalloc.h linux-2.6.14_imx21/include/asm-arm/arch-imx21/vmalloc.h
--- linux-2.6.14_original/include/asm-arm/arch-imx21/vmalloc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.14_imx21/include/asm-arm/arch-imx21/vmalloc.h	2006-04-11 10:29:12.000000000 +0200
@@ -0,0 +1,32 @@
+/*
+ *  linux/include/asm-arm/arch-imx21/vmalloc.h
+ *
+ *  Copyright (C) 2000 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * Just any arbitrary offset to the start of the vmalloc VM area: the
+ * current 8MB value just means that there will be a 8MB "hole" after the
+ * physical memory until the kernel virtual memory starts.  That means that
+ * any out-of-bounds memory accesses will hopefully be caught.
+ * The vmalloc() routines leaves a hole of 4kB between each vmalloced
+ * area for the same reason. ;)
+ */
+#define VMALLOC_OFFSET	  (8*1024*1024)
+#define VMALLOC_START	  (((unsigned long)high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
+#define VMALLOC_VMADDR(x) ((unsigned long)(x))
+#define VMALLOC_END       (PAGE_OFFSET + 0x10000000)
diff -NaurbB linux-2.6.14_original/Makefile linux-2.6.14_imx21/Makefile
--- linux-2.6.14_original/Makefile	2005-10-28 02:02:08.000000000 +0200
+++ linux-2.6.14_imx21/Makefile	2006-04-11 10:29:12.000000000 +0200
@@ -189,8 +189,8 @@
 # Default value for CROSS_COMPILE is not to prefix executables
 # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
 
-ARCH		?= $(SUBARCH)
-CROSS_COMPILE	?=
+ARCH		?= arm
+CROSS_COMPILE	?= arm-linux-
 
 # Architecture as present in compile.h
 UTS_MACHINE := $(ARCH)
