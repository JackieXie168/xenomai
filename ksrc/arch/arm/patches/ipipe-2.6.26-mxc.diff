diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/Kconfig ipipe-2.6.26-mxc/arch/arm/Kconfig
--- adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/Kconfig	2008-10-19 14:26:54.000000000 +0200
+++ ipipe-2.6.26-mxc/arch/arm/Kconfig	2008-10-19 15:15:34.000000000 +0200
@@ -369,7 +369,11 @@ config ARCH_NS9XXX
 
 config ARCH_MXC
 	bool "Freescale MXC/iMX-based"
+	select GENERIC_TIME
+	select GENERIC_CLOCKEVENTS
 	select ARCH_MTD_XIP
+	select GENERIC_GPIO
+	select HAVE_GPIO_LIB
 	help
 	  Support for Freescale MXC/iMX-based family of processors
 
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx2/clock_imx27.c ipipe-2.6.26-mxc/arch/arm/mach-mx2/clock_imx27.c
--- adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx2/clock_imx27.c	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/arch/arm/mach-mx2/clock_imx27.c	2008-10-19 15:15:34.000000000 +0200
@@ -0,0 +1,1626 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ */
+
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+
+#include <asm/arch/clock.h>
+#include <asm/arch/common.h>
+#include <asm/div64.h>
+#include <asm/mach-types.h>
+
+#include "crm_regs.h"
+
+static struct clk ckil_clk;
+static struct clk mpll_clk;
+static struct clk mpll_main_clk[];
+static struct clk spll_clk;
+
+static int _clk_enable(struct clk *clk)
+{
+	unsigned long reg;
+
+	reg = __raw_readl(clk->enable_reg);
+	reg |= 1 << clk->enable_shift;
+	__raw_writel(reg, clk->enable_reg);
+
+	return 0;
+}
+
+static void _clk_disable(struct clk *clk)
+{
+	unsigned long reg;
+
+	reg = __raw_readl(clk->enable_reg);
+	reg &= ~(1 << clk->enable_shift);
+	__raw_writel(reg, clk->enable_reg);
+}
+
+static int _clk_spll_enable(struct clk *clk)
+{
+	unsigned long reg;
+
+	reg = __raw_readl(CCM_CSCR);
+	reg |= CCM_CSCR_SPEN;
+	__raw_writel(reg, CCM_CSCR);
+
+	while ((__raw_readl(CCM_SPCTL1) & CCM_SPCTL1_LF) == 0)
+		;
+
+	return 0;
+}
+
+static void _clk_spll_disable(struct clk *clk)
+{
+	unsigned long reg;
+
+	reg = __raw_readl(CCM_CSCR);
+	reg &= ~CCM_CSCR_SPEN;
+	__raw_writel(reg, CCM_CSCR);
+}
+
+static void _clk_pccr01_enable(unsigned long mask0, unsigned long mask1)
+{
+	unsigned long reg;
+
+	reg = __raw_readl(CCM_PCCR0);
+	reg |= mask0;
+	__raw_writel(reg, CCM_PCCR0);
+
+	reg = __raw_readl(CCM_PCCR1);
+	reg |= mask1;
+	__raw_writel(reg, CCM_PCCR1);
+
+}
+
+static void _clk_pccr01_disable(unsigned long mask0, unsigned long mask1)
+{
+	unsigned long reg;
+
+	reg = __raw_readl(CCM_PCCR0);
+	reg &= ~mask0;
+	__raw_writel(reg, CCM_PCCR0);
+
+	reg = __raw_readl(CCM_PCCR1);
+	reg &= ~mask1;
+	__raw_writel(reg, CCM_PCCR1);
+}
+
+static void _clk_pccr10_enable(unsigned long mask1, unsigned long mask0)
+{
+	unsigned long reg;
+
+	reg = __raw_readl(CCM_PCCR1);
+	reg |= mask1;
+	__raw_writel(reg, CCM_PCCR1);
+
+	reg = __raw_readl(CCM_PCCR0);
+	reg |= mask0;
+	__raw_writel(reg, CCM_PCCR0);
+}
+
+static void _clk_pccr10_disable(unsigned long mask1, unsigned long mask0)
+{
+	unsigned long reg;
+
+	reg = __raw_readl(CCM_PCCR1);
+	reg &= ~mask1;
+	__raw_writel(reg, CCM_PCCR1);
+
+	reg = __raw_readl(CCM_PCCR0);
+	reg &= ~mask0;
+	__raw_writel(reg, CCM_PCCR0);
+}
+
+static int _clk_dma_enable(struct clk *clk)
+{
+	_clk_pccr01_enable(CCM_PCCR0_DMA_MASK, CCM_PCCR1_HCLK_DMA_MASK);
+
+	return 0;
+}
+
+static void _clk_dma_disable(struct clk *clk)
+{
+	_clk_pccr01_disable(CCM_PCCR0_DMA_MASK, CCM_PCCR1_HCLK_DMA_MASK);
+}
+
+static int _clk_rtic_enable(struct clk *clk)
+{
+	_clk_pccr01_enable(CCM_PCCR0_RTIC_MASK, CCM_PCCR1_HCLK_RTIC_MASK);
+
+	return 0;
+}
+
+static void _clk_rtic_disable(struct clk *clk)
+{
+	_clk_pccr01_disable(CCM_PCCR0_RTIC_MASK, CCM_PCCR1_HCLK_RTIC_MASK);
+}
+
+static int _clk_emma_enable(struct clk *clk)
+{
+	_clk_pccr01_enable(CCM_PCCR0_EMMA_MASK, CCM_PCCR1_HCLK_EMMA_MASK);
+
+	return 0;
+}
+
+static void _clk_emma_disable(struct clk *clk)
+{
+	_clk_pccr01_disable(CCM_PCCR0_EMMA_MASK, CCM_PCCR1_HCLK_EMMA_MASK);
+}
+
+static int _clk_slcdc_enable(struct clk *clk)
+{
+	_clk_pccr01_enable(CCM_PCCR0_SLCDC_MASK, CCM_PCCR1_HCLK_SLCDC_MASK);
+
+	return 0;
+}
+
+static void _clk_slcdc_disable(struct clk *clk)
+{
+	_clk_pccr01_disable(CCM_PCCR0_SLCDC_MASK, CCM_PCCR1_HCLK_SLCDC_MASK);
+}
+
+static int _clk_fec_enable(struct clk *clk)
+{
+	_clk_pccr01_enable(CCM_PCCR0_FEC_MASK, CCM_PCCR1_HCLK_FEC_MASK);
+
+	return 0;
+}
+
+static void _clk_fec_disable(struct clk *clk)
+{
+	_clk_pccr01_disable(CCM_PCCR0_FEC_MASK, CCM_PCCR1_HCLK_FEC_MASK);
+}
+
+static int _clk_vpu_enable(struct clk *clk)
+{
+	unsigned long reg;
+
+	reg = __raw_readl(CCM_PCCR1);
+	reg |= CCM_PCCR1_VPU_BAUD_MASK | CCM_PCCR1_HCLK_VPU_MASK;
+	__raw_writel(reg, CCM_PCCR1);
+
+	return 0;
+}
+
+static void _clk_vpu_disable(struct clk *clk)
+{
+	unsigned long reg;
+
+	reg = __raw_readl(CCM_PCCR1);
+	reg &= ~(CCM_PCCR1_VPU_BAUD_MASK | CCM_PCCR1_HCLK_VPU_MASK);
+	__raw_writel(reg, CCM_PCCR1);
+}
+
+static int _clk_sahara2_enable(struct clk *clk)
+{
+	_clk_pccr01_enable(CCM_PCCR0_SAHARA_MASK, CCM_PCCR1_HCLK_SAHARA_MASK);
+
+	return 0;
+}
+
+static void _clk_sahara2_disable(struct clk *clk)
+{
+	_clk_pccr01_disable(CCM_PCCR0_SAHARA_MASK, CCM_PCCR1_HCLK_SAHARA_MASK);
+}
+
+static int _clk_mstick1_enable(struct clk *clk)
+{
+	_clk_pccr10_enable(CCM_PCCR1_MSHC_BAUD_MASK, CCM_PCCR0_MSHC_MASK);
+
+	return 0;
+}
+
+static void _clk_mstick1_disable(struct clk *clk)
+{
+	_clk_pccr10_disable(CCM_PCCR1_MSHC_BAUD_MASK, CCM_PCCR0_MSHC_MASK);
+}
+
+#define CSCR() (__raw_readl(CCM_CSCR))
+#define PCDR0() (__raw_readl(CCM_PCDR0))
+#define PCDR1() (__raw_readl(CCM_PCDR1))
+
+static int _clk_cpu_set_parent(struct clk *clk, struct clk *parent)
+{
+	int cscr = CSCR();
+
+	if (clk->parent == parent)
+		return 0;
+
+	if (mx27_revision() >= CHIP_REV_2_0) {
+		if (parent == &mpll_main_clk[0]) {
+			cscr |= CCM_CSCR_ARM_SRC;
+		} else {
+			if (parent == &mpll_main_clk[1])
+				cscr &= ~CCM_CSCR_ARM_SRC;
+			else
+				return -EINVAL;
+		}
+		__raw_writel(cscr, CCM_CSCR);
+	} else
+		return -ENODEV;
+
+	clk->parent = parent;
+	return 0;
+}
+
+static unsigned long _clk_cpu_round_rate(struct clk *clk, unsigned long rate)
+{
+	int div;
+	unsigned long parent_rate;
+
+	parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+	if (parent_rate % rate)
+		div++;
+
+	if (div > 4)
+		div = 4;
+
+	return parent_rate / div;
+}
+
+static int _clk_cpu_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned int div;
+	uint32_t reg;
+	unsigned long parent_rate;
+
+	parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+
+	if (div > 4 || div < 1 || ((parent_rate / div) != rate))
+		return -EINVAL;
+
+	div--;
+
+	reg = __raw_readl(CCM_CSCR);
+	if (mx27_revision() >= CHIP_REV_2_0) {
+		reg &= ~CCM_CSCR_ARM_MASK;
+		reg |= div << CCM_CSCR_ARM_OFFSET;
+		reg &= ~0x06;
+		__raw_writel(reg | 0x80000000, CCM_CSCR);
+	} else {
+		printk(KERN_ERR "Cant set CPU frequency!\n");
+	}
+
+	return 0;
+}
+
+static unsigned long _clk_perclkx_round_rate(struct clk *clk,
+					     unsigned long rate)
+{
+	u32 div;
+	unsigned long parent_rate;
+
+	parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+	if (parent_rate % rate)
+		div++;
+
+	if (div > 64)
+		div = 64;
+
+	return parent_rate / div;
+}
+
+static int _clk_perclkx_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	u32 div;
+	unsigned long parent_rate;
+
+	parent_rate = clk_get_rate(clk->parent);
+
+	if (clk->id < 0 || clk->id > 3)
+		return -EINVAL;
+
+	div = parent_rate / rate;
+	if (div > 64 || div < 1 || ((parent_rate / div) != rate))
+		return -EINVAL;
+	div--;
+
+	reg =
+	    __raw_readl(CCM_PCDR1) & ~(CCM_PCDR1_PERDIV1_MASK <<
+				       (clk->id << 3));
+	reg |= div << (clk->id << 3);
+	__raw_writel(reg, CCM_PCDR1);
+
+	return 0;
+}
+
+static unsigned long _clk_usb_recalc(struct clk *clk)
+{
+	unsigned long usb_pdf;
+	unsigned long parent_rate;
+
+	parent_rate = clk_get_rate(clk->parent);
+
+	usb_pdf = (CSCR() & CCM_CSCR_USB_MASK) >> CCM_CSCR_USB_OFFSET;
+
+	return parent_rate / (usb_pdf + 1U);
+}
+
+static unsigned long _clk_ssi1_recalc(struct clk *clk)
+{
+	unsigned long ssi1_pdf;
+	unsigned long parent_rate;
+
+	parent_rate = clk_get_rate(clk->parent);
+
+	ssi1_pdf = (PCDR0() & CCM_PCDR0_SSI1BAUDDIV_MASK) >>
+					CCM_PCDR0_SSI1BAUDDIV_OFFSET;
+
+	if (mx27_revision() >= CHIP_REV_2_0)
+		ssi1_pdf += 4;
+	else
+		ssi1_pdf = (ssi1_pdf < 2) ? 124UL : ssi1_pdf;
+
+	return 2UL * parent_rate / ssi1_pdf;
+}
+
+static unsigned long _clk_ssi2_recalc(struct clk *clk)
+{
+	unsigned long ssi2_pdf;
+	unsigned long parent_rate;
+
+	parent_rate = clk_get_rate(clk->parent);
+
+	ssi2_pdf = (PCDR0() & CCM_PCDR0_SSI2BAUDDIV_MASK) >>
+	    CCM_PCDR0_SSI2BAUDDIV_OFFSET;
+
+	if (mx27_revision() >= CHIP_REV_2_0)
+		ssi2_pdf += 4;
+	else
+		ssi2_pdf = (ssi2_pdf < 2) ? 124UL : ssi2_pdf;
+
+	return 2UL * parent_rate / ssi2_pdf;
+}
+
+static unsigned long _clk_nfc_recalc(struct clk *clk)
+{
+	unsigned long nfc_pdf;
+	unsigned long parent_rate;
+
+	parent_rate = clk_get_rate(clk->parent);
+
+	if (mx27_revision() >= CHIP_REV_2_0) {
+		nfc_pdf =
+		    (PCDR0() & CCM_PCDR0_NFCDIV2_MASK) >>
+		    CCM_PCDR0_NFCDIV2_OFFSET;
+	} else {
+		nfc_pdf =
+		    (PCDR0() & CCM_PCDR0_NFCDIV_MASK) >>
+		    CCM_PCDR0_NFCDIV_OFFSET;
+	}
+
+	return parent_rate / (nfc_pdf + 1);
+}
+
+static unsigned long _clk_vpu_recalc(struct clk *clk)
+{
+	unsigned long vpu_pdf;
+	unsigned long parent_rate;
+
+	parent_rate = clk_get_rate(clk->parent);
+
+	if (mx27_revision() >= CHIP_REV_2_0) {
+		vpu_pdf =
+		    (PCDR0() & CCM_PCDR0_VPUDIV2_MASK) >>
+		    CCM_PCDR0_VPUDIV2_OFFSET;
+		vpu_pdf += 4;
+	} else {
+		vpu_pdf =
+		    (PCDR0() & CCM_PCDR0_VPUDIV_MASK) >>
+		    CCM_PCDR0_VPUDIV_OFFSET;
+		vpu_pdf = (vpu_pdf < 2) ? 124 : vpu_pdf;
+	}
+	return 2UL * parent_rate / vpu_pdf;
+}
+
+static unsigned long _clk_parent_round_rate(struct clk *clk, unsigned long rate)
+{
+	return clk->parent->round_rate(clk->parent, rate);
+}
+
+static int _clk_parent_set_rate(struct clk *clk, unsigned long rate)
+{
+	return clk->parent->set_rate(clk->parent, rate);
+}
+
+/* in Hz */
+static unsigned long external_high_reference = 26000000;
+
+static unsigned long get_high_reference_clock_rate(struct clk *clk)
+{
+	return external_high_reference;
+}
+
+/*
+ * the high frequency external clock reference
+ * Default case is 26MHz. Could be changed at runtime
+ * with a call to change_external_high_reference()
+ */
+static struct clk ckih_clk = {
+	.name = "ckih",
+	.get_rate = get_high_reference_clock_rate,
+};
+
+/* in Hz */
+static unsigned long external_low_reference = 32768;
+
+static unsigned long get_low_reference_clock_rate(struct clk *clk)
+{
+	return external_low_reference;
+}
+
+/*
+ * the low frequency external clock reference
+ * Default case is 32.768kHz Could be changed at runtime
+ * with a call to change_external_low_reference()
+ */
+static struct clk ckil_clk = {
+	.name = "ckil",
+	.get_rate = get_low_reference_clock_rate,
+};
+
+static unsigned long get_mpll_clk(struct clk *clk)
+{
+	uint32_t reg;
+	unsigned long ref_clk;
+	unsigned long mfi = 0, mfn = 0, mfd = 0, pdf = 0;
+	unsigned long long temp;
+
+	ref_clk = clk_get_rate(clk->parent);
+
+	reg = __raw_readl(CCM_MPCTL0);
+	pdf = (reg & CCM_MPCTL0_PD_MASK) >> CCM_MPCTL0_PD_OFFSET;
+	mfd = (reg & CCM_MPCTL0_MFD_MASK) >> CCM_MPCTL0_MFD_OFFSET;
+	mfi = (reg & CCM_MPCTL0_MFI_MASK) >> CCM_MPCTL0_MFI_OFFSET;
+	mfn = (reg & CCM_MPCTL0_MFN_MASK) >> CCM_MPCTL0_MFN_OFFSET;
+
+	mfi = (mfi <= 5) ? 5 : mfi;
+	temp = 2LL * ref_clk * mfn;
+	do_div(temp, mfd + 1);
+	temp = 2LL * ref_clk * mfi + temp;
+	do_div(temp, pdf + 1);
+
+	return (unsigned long)temp;
+}
+
+static struct clk mpll_clk = {
+	.name = "mpll",
+	.parent = &ckih_clk,
+	.get_rate = get_mpll_clk,
+};
+
+static unsigned long _clk_mpll_main_get_rate(struct clk *clk)
+{
+	unsigned long parent_rate;
+
+	parent_rate = clk_get_rate(clk->parent);
+
+	/* i.MX27 TO2:
+	 * clk->id == 0: arm clock source path 1 which is from 2*MPLL/DIV_2
+	 * clk->id == 1: arm clock source path 2 which is from 2*MPLL/DIV_3
+	 */
+
+	if (mx27_revision() >= CHIP_REV_2_0 && clk->id == 1)
+		return 2UL * parent_rate / 3UL;
+
+	return parent_rate;
+}
+
+static struct clk mpll_main_clk[] = {
+	{
+		/* For i.MX27 TO2, it is the MPLL path 1 of ARM core
+		 * It provide the clock source whose rate is same as MPLL
+		 */
+		.name = "mpll_main",
+		.id = 0,
+		.parent = &mpll_clk,
+		.get_rate = _clk_mpll_main_get_rate
+	}, {
+		/* For i.MX27 TO2, it is the MPLL path 2 of ARM core
+		 * It provide the clock source whose rate is same MPLL * 2/3
+		 */
+		.name = "mpll_main",
+		.id = 1,
+		.parent = &mpll_clk,
+		.get_rate = _clk_mpll_main_get_rate
+	}
+};
+
+static unsigned long get_spll_clk(struct clk *clk)
+{
+	uint32_t reg;
+	unsigned long ref_clk;
+	unsigned long mfi = 0, mfn = 0, mfd = 0, pdf = 0;
+	unsigned long long temp;
+
+	ref_clk = clk_get_rate(clk->parent);
+
+	reg = __raw_readl(CCM_SPCTL0);
+	/*TODO: This is TO2 Bug */
+	if (mx27_revision() >= CHIP_REV_2_0)
+		__raw_writel(reg, CCM_SPCTL0);
+
+	pdf = (reg & CCM_SPCTL0_PD_MASK) >> CCM_SPCTL0_PD_OFFSET;
+	mfd = (reg & CCM_SPCTL0_MFD_MASK) >> CCM_SPCTL0_MFD_OFFSET;
+	mfi = (reg & CCM_SPCTL0_MFI_MASK) >> CCM_SPCTL0_MFI_OFFSET;
+	mfn = (reg & CCM_SPCTL0_MFN_MASK) >> CCM_SPCTL0_MFN_OFFSET;
+
+	mfi = (mfi <= 5) ? 5 : mfi;
+	temp = 2LL * ref_clk * mfn;
+	do_div(temp, mfd + 1);
+	temp = 2LL * ref_clk * mfi + temp;
+	do_div(temp, pdf + 1);
+
+	return (unsigned long)temp;
+}
+
+static struct clk spll_clk = {
+	.name = "spll",
+	.parent = &ckih_clk,
+	.get_rate = get_spll_clk,
+	.enable = _clk_spll_enable,
+	.disable = _clk_spll_disable,
+};
+
+static unsigned long get_cpu_clk(struct clk *clk)
+{
+	u32 div;
+	unsigned long rate;
+
+	if (mx27_revision() >= CHIP_REV_2_0)
+		div = (CSCR() & CCM_CSCR_ARM_MASK) >> CCM_CSCR_ARM_OFFSET;
+	else
+		div = (CSCR() & CCM_CSCR_PRESC_MASK) >> CCM_CSCR_PRESC_OFFSET;
+
+	rate = clk_get_rate(clk->parent);
+	return rate / (div + 1);
+}
+
+static struct clk cpu_clk = {
+	.name = "cpu_clk",
+	.parent = &mpll_main_clk[1],
+	.set_parent = _clk_cpu_set_parent,
+	.round_rate = _clk_cpu_round_rate,
+	.get_rate = get_cpu_clk,
+	.set_rate = _clk_cpu_set_rate,
+};
+
+static unsigned long get_ahb_clk(struct clk *clk)
+{
+	unsigned long rate;
+	unsigned long bclk_pdf;
+
+	if (mx27_revision() >= CHIP_REV_2_0)
+		bclk_pdf = (CSCR() & CCM_CSCR_AHB_MASK)
+					>> CCM_CSCR_AHB_OFFSET;
+	else
+		bclk_pdf = (CSCR() & CCM_CSCR_BCLK_MASK)
+					>> CCM_CSCR_BCLK_OFFSET;
+
+	rate = clk_get_rate(clk->parent);
+	return rate / (bclk_pdf + 1);
+}
+
+static struct clk ahb_clk = {
+	.name = "ahb_clk",
+	.parent = &mpll_main_clk[1],
+	.get_rate = get_ahb_clk,
+};
+
+static unsigned long get_ipg_clk(struct clk *clk)
+{
+	unsigned long rate;
+	unsigned long ipg_pdf;
+
+	if (mx27_revision() >= CHIP_REV_2_0)
+		return clk_get_rate(clk->parent);
+	else
+		ipg_pdf = (CSCR() & CCM_CSCR_IPDIV) >> CCM_CSCR_IPDIV_OFFSET;
+
+	rate = clk_get_rate(clk->parent);
+	return rate / (ipg_pdf + 1);
+}
+
+static struct clk ipg_clk = {
+	.name = "ipg_clk",
+	.parent = &ahb_clk,
+	.get_rate = get_ipg_clk,
+};
+
+static unsigned long _clk_perclkx_recalc(struct clk *clk)
+{
+	unsigned long perclk_pdf;
+	unsigned long parent_rate;
+
+	parent_rate = clk_get_rate(clk->parent);
+
+	if (clk->id < 0 || clk->id > 3)
+		return 0;
+
+	perclk_pdf = (PCDR1() >> (clk->id << 3)) & CCM_PCDR1_PERDIV1_MASK;
+
+	return parent_rate / (perclk_pdf + 1);
+}
+
+static struct clk per_clk[] = {
+	{
+		.name = "per_clk",
+		.id = 0,
+		.parent = &mpll_main_clk[1],
+		.get_rate = _clk_perclkx_recalc,
+		.enable = _clk_enable,
+		.enable_reg = CCM_PCCR1,
+		.enable_shift = CCM_PCCR1_PERCLK1_OFFSET,
+		.disable = _clk_disable,
+	}, {
+		.name = "per_clk",
+		.id = 1,
+		.parent = &mpll_main_clk[1],
+		.get_rate = _clk_perclkx_recalc,
+		.enable = _clk_enable,
+		.enable_reg = CCM_PCCR1,
+		.enable_shift = CCM_PCCR1_PERCLK2_OFFSET,
+		.disable = _clk_disable,
+	}, {
+		.name = "per_clk",
+		.id = 2,
+		.parent = &mpll_main_clk[1],
+		.round_rate = _clk_perclkx_round_rate,
+		.set_rate = _clk_perclkx_set_rate,
+		.get_rate = _clk_perclkx_recalc,
+		.enable = _clk_enable,
+		.enable_reg = CCM_PCCR1,
+		.enable_shift = CCM_PCCR1_PERCLK3_OFFSET,
+		.disable = _clk_disable,
+	}, {
+		.name = "per_clk",
+		.id = 3,
+		.parent = &mpll_main_clk[1],
+		.round_rate = _clk_perclkx_round_rate,
+		.set_rate = _clk_perclkx_set_rate,
+		.get_rate = _clk_perclkx_recalc,
+		.enable = _clk_enable,
+		.enable_reg = CCM_PCCR1,
+		.enable_shift = CCM_PCCR1_PERCLK4_OFFSET,
+		.disable = _clk_disable,
+	},
+};
+
+struct clk uart1_clk[] = {
+	{
+		.name = "uart_clk",
+		.id = 0,
+		.parent = &per_clk[0],
+		.secondary = &uart1_clk[1],
+	}, {
+		.name = "uart_ipg_clk",
+		.id = 0,
+		.parent = &ipg_clk,
+		.enable = _clk_enable,
+		.enable_reg = CCM_PCCR1,
+		.enable_shift = CCM_PCCR1_UART1_OFFSET,
+		.disable = _clk_disable,
+	},
+};
+
+struct clk uart2_clk[] = {
+	{
+		.name = "uart_clk",
+		.id = 1,
+		.parent = &per_clk[0],
+		.secondary = &uart2_clk[1],
+	}, {
+		.name = "uart_ipg_clk",
+		.id = 1,
+		.parent = &ipg_clk,
+		.enable = _clk_enable,
+		.enable_reg = CCM_PCCR1,
+		.enable_shift = CCM_PCCR1_UART2_OFFSET,
+		.disable = _clk_disable,
+	},
+};
+
+struct clk uart3_clk[] = {
+	{
+		.name = "uart_clk",
+		.id = 2,
+		.parent = &per_clk[0],
+		.secondary = &uart3_clk[1],
+	}, {
+		.name = "uart_ipg_clk",
+		.id = 2,
+		.parent = &ipg_clk,
+		.enable = _clk_enable,
+		.enable_reg = CCM_PCCR1,
+		.enable_shift = CCM_PCCR1_UART3_OFFSET,
+		.disable = _clk_disable,
+	},
+};
+
+struct clk uart4_clk[] = {
+	{
+		.name = "uart_clk",
+		.id = 3,
+		.parent = &per_clk[0],
+		.secondary = &uart4_clk[1],
+	}, {
+		.name = "uart_ipg_clk",
+		.id = 3,
+		.parent = &ipg_clk,
+		.enable = _clk_enable,
+		.enable_reg = CCM_PCCR1,
+		.enable_shift = CCM_PCCR1_UART4_OFFSET,
+		.disable = _clk_disable,
+	},
+};
+
+struct clk uart5_clk[] = {
+	{
+		.name = "uart_clk",
+		.id = 4,
+		.parent = &per_clk[0],
+		.secondary = &uart5_clk[1],
+	}, {
+		.name = "uart_ipg_clk",
+		.id = 4,
+		.parent = &ipg_clk,
+		.enable = _clk_enable,
+		.enable_reg = CCM_PCCR1,
+		.enable_shift = CCM_PCCR1_UART5_OFFSET,
+		.disable = _clk_disable,
+	},
+};
+
+struct clk uart6_clk[] = {
+	{
+		.name = "uart_clk",
+		.id = 5,
+		.parent = &per_clk[0],
+		.secondary = &uart6_clk[1],
+	}, {
+		.name = "uart_ipg_clk",
+		.id = 5,
+		.parent = &ipg_clk,
+		.enable = _clk_enable,
+		.enable_reg = CCM_PCCR1,
+		.enable_shift = CCM_PCCR1_UART6_OFFSET,
+		.disable = _clk_disable,
+	},
+};
+
+static struct clk gpt1_clk[] = {
+	{
+		.name = "gpt_clk",
+		.id = 0,
+		.parent = &per_clk[0],
+		.secondary = &gpt1_clk[1],
+	}, {
+		.name = "gpt_ipg_clk",
+		.id = 0,
+		.parent = &ipg_clk,
+		.enable = _clk_enable,
+		.enable_reg = CCM_PCCR0,
+		.enable_shift = CCM_PCCR0_GPT1_OFFSET,
+		.disable = _clk_disable,
+	},
+};
+
+static struct clk gpt2_clk[] = {
+	{
+		.name = "gpt_clk",
+		.id = 1,
+		.parent = &per_clk[0],
+		.secondary = &gpt2_clk[1],
+	}, {
+		.name = "gpt_ipg_clk",
+		.id = 1,
+		.parent = &ipg_clk,
+		.enable = _clk_enable,
+		.enable_reg = CCM_PCCR0,
+		.enable_shift = CCM_PCCR0_GPT2_OFFSET,
+		.disable = _clk_disable,
+	},
+};
+
+static struct clk gpt3_clk[] = {
+	{
+		.name = "gpt_clk",
+		.id = 2,
+		.parent = &per_clk[0],
+		.secondary = &gpt3_clk[1],
+	}, {
+		.name = "gpt_ipg_clk",
+		.id = 2,
+		.parent = &ipg_clk,
+		.enable = _clk_enable,
+		.enable_reg = CCM_PCCR0,
+		.enable_shift = CCM_PCCR0_GPT3_OFFSET,
+		.disable = _clk_disable,
+	},
+};
+
+static struct clk gpt4_clk[] = {
+	{
+		.name = "gpt_clk",
+		.id = 3,
+		.parent = &per_clk[0],
+		.secondary = &gpt4_clk[1],
+	}, {
+		.name = "gpt_ipg_clk",
+		.id = 3,
+		.parent = &ipg_clk,
+		.enable = _clk_enable,
+		.enable_reg = CCM_PCCR0,
+		.enable_shift = CCM_PCCR0_GPT4_OFFSET,
+		.disable = _clk_disable,
+	},
+};
+
+static struct clk gpt5_clk[] = {
+	{
+		.name = "gpt_clk",
+		.id = 4,
+		.parent = &per_clk[0],
+		.secondary = &gpt5_clk[1],
+	}, {
+		.name = "gpt_ipg_clk",
+		.id = 4,
+		.parent = &ipg_clk,
+		.enable = _clk_enable,
+		.enable_reg = CCM_PCCR0,
+		.enable_shift = CCM_PCCR0_GPT5_OFFSET,
+		.disable = _clk_disable,
+	},
+};
+
+static struct clk gpt6_clk[] = {
+	{
+		.name = "gpt_clk",
+		.id = 5,
+		.parent = &per_clk[0],
+		.secondary = &gpt6_clk[1],
+	}, {
+		.name = "gpt_ipg_clk",
+		.id = 5,
+		.parent = &ipg_clk,
+		.enable = _clk_enable,
+		.enable_reg = CCM_PCCR0,
+		.enable_shift = CCM_PCCR0_GPT6_OFFSET,
+		.disable = _clk_disable,
+	},
+};
+
+static struct clk pwm_clk[] = {
+	{
+		.name = "pwm_clk",
+		.parent = &per_clk[0],
+		.secondary = &pwm_clk[1],
+	}, {
+		.name = "pwm_clk",
+		.parent = &ipg_clk,
+		.enable = _clk_enable,
+		.enable_reg = CCM_PCCR0,
+		.enable_shift = CCM_PCCR0_PWM_OFFSET,
+		.disable = _clk_disable,
+	},
+};
+
+static struct clk sdhc1_clk[] = {
+	{
+		.name = "sdhc_clk",
+		.id = 0,
+		.parent = &per_clk[1],
+		.secondary = &sdhc1_clk[1],
+	}, {
+		.name = "sdhc_ipg_clk",
+		.id = 0,
+		.parent = &ipg_clk,
+		.enable = _clk_enable,
+		.enable_reg = CCM_PCCR0,
+		.enable_shift = CCM_PCCR0_SDHC1_OFFSET,
+		.disable = _clk_disable,
+	},
+};
+
+static struct clk sdhc2_clk[] = {
+	{
+		.name = "sdhc_clk",
+		.id = 1,
+		.parent = &per_clk[1],
+		.secondary = &sdhc2_clk[1],
+	}, {
+		.name = "sdhc_ipg_clk",
+		.id = 1,
+		.parent = &ipg_clk,
+		.enable = _clk_enable,
+		.enable_reg = CCM_PCCR0,
+		.enable_shift = CCM_PCCR0_SDHC2_OFFSET,
+		.disable = _clk_disable,
+	},
+};
+
+static struct clk sdhc3_clk[] = {
+	{
+		.name = "sdhc_clk",
+		.id = 2,
+		.parent = &per_clk[1],
+		.secondary = &sdhc3_clk[1],
+	}, {
+		.name = "sdhc_ipg_clk",
+		.id = 2,
+		.parent = &ipg_clk,
+		.enable = _clk_enable,
+		.enable_reg = CCM_PCCR0,
+		.enable_shift = CCM_PCCR0_SDHC3_OFFSET,
+		.disable = _clk_disable,
+	},
+};
+
+static struct clk cspi1_clk[] = {
+	{
+		.name = "cspi_clk",
+		.id = 0,
+		.parent = &per_clk[1],
+		.secondary = &cspi1_clk[1],
+	}, {
+		.name = "cspi_ipg_clk",
+		.id = 0,
+		.parent = &ipg_clk,
+		.enable = _clk_enable,
+		.enable_reg = CCM_PCCR0,
+		.enable_shift = CCM_PCCR0_CSPI1_OFFSET,
+		.disable = _clk_disable,
+	},
+};
+
+static struct clk cspi2_clk[] = {
+	{
+		.name = "cspi_clk",
+		.id = 1,
+		.parent = &per_clk[1],
+		.secondary = &cspi2_clk[1],
+	}, {
+		.name = "cspi_ipg_clk",
+		.id = 1,
+		.parent = &ipg_clk,
+		.enable = _clk_enable,
+		.enable_reg = CCM_PCCR0,
+		.enable_shift = CCM_PCCR0_CSPI2_OFFSET,
+		.disable = _clk_disable,
+	},
+};
+
+static struct clk cspi3_clk[] = {
+	{
+		.name = "cspi_clk",
+		.id = 2,
+		.parent = &per_clk[1],
+		.secondary = &cspi3_clk[1],
+	}, {
+		.name = "cspi_ipg_clk",
+		.id = 2,
+		.parent = &ipg_clk,
+		.enable = _clk_enable,
+		.enable_reg = CCM_PCCR0,
+		.enable_shift = CCM_PCCR0_CSPI3_OFFSET,
+		.disable = _clk_disable,
+	},
+};
+
+static struct clk lcdc_clk[] = {
+	{
+		.name = "lcdc_clk",
+		.parent = &per_clk[2],
+		.secondary = &lcdc_clk[1],
+		.round_rate = _clk_parent_round_rate,
+		.set_rate = _clk_parent_set_rate,
+	}, {
+		.name = "lcdc_ipg_clk",
+		.parent = &ipg_clk,
+		.secondary = &lcdc_clk[2],
+		.enable = _clk_enable,
+		.enable_reg = CCM_PCCR0,
+		.enable_shift = CCM_PCCR0_LCDC_OFFSET,
+		.disable = _clk_disable,
+	}, {
+		.name = "lcdc_ahb_clk",
+		.parent = &ahb_clk,
+		.enable = _clk_enable,
+		.enable_reg = CCM_PCCR1,
+		.enable_shift = CCM_PCCR1_HCLK_LCDC_OFFSET,
+		.disable = _clk_disable,
+	},
+};
+
+static struct clk csi_clk[] = {
+	{
+		.name = "csi_perclk",
+		.parent = &per_clk[3],
+		.secondary = &csi_clk[1],
+		.round_rate = _clk_parent_round_rate,
+		.set_rate = _clk_parent_set_rate,
+	}, {
+		.name = "csi_ahb_clk",
+		.parent = &ahb_clk,
+		.enable = _clk_enable,
+		.enable_reg = CCM_PCCR1,
+		.enable_shift = CCM_PCCR1_HCLK_CSI_OFFSET,
+		.disable = _clk_disable,
+	},
+};
+
+static struct clk usb_clk[] = {
+	{
+		.name = "usb_clk",
+		.parent = &spll_clk,
+		.get_rate = _clk_usb_recalc,
+		.enable = _clk_enable,
+		.enable_reg = CCM_PCCR1,
+		.enable_shift = CCM_PCCR1_USBOTG_OFFSET,
+		.disable = _clk_disable,
+	}, {
+		.name = "usb_ahb_clk",
+		.parent = &ahb_clk,
+		.enable = _clk_enable,
+		.enable_reg = CCM_PCCR1,
+		.enable_shift = CCM_PCCR1_HCLK_USBOTG_OFFSET,
+		.disable = _clk_disable,
+	}
+};
+
+static struct clk ssi1_clk[] = {
+	{
+		.name = "ssi_clk",
+		.id = 0,
+		.parent = &mpll_main_clk[1],
+		.secondary = &ssi1_clk[1],
+		.get_rate = _clk_ssi1_recalc,
+		.enable = _clk_enable,
+		.enable_reg = CCM_PCCR1,
+		.enable_shift = CCM_PCCR1_SSI1_BAUD_OFFSET,
+		.disable = _clk_disable,
+	}, {
+		.name = "ssi_ipg_clk",
+		.id = 0,
+		.parent = &ipg_clk,
+		.enable = _clk_enable,
+		.enable_reg = CCM_PCCR0,
+		.enable_shift = CCM_PCCR0_SSI1_IPG_OFFSET,
+		.disable = _clk_disable,
+	},
+};
+
+static struct clk ssi2_clk[] = {
+	{
+		.name = "ssi_clk",
+		.id = 1,
+		.parent = &mpll_main_clk[1],
+		.secondary = &ssi2_clk[1],
+		.get_rate = _clk_ssi2_recalc,
+		.enable = _clk_enable,
+		.enable_reg = CCM_PCCR1,
+		.enable_shift = CCM_PCCR1_SSI2_BAUD_OFFSET,
+		.disable = _clk_disable,
+	}, {
+		.name = "ssi_ipg_clk",
+		.id = 1,
+		.parent = &ipg_clk,
+		.enable = _clk_enable,
+		.enable_reg = CCM_PCCR0,
+		.enable_shift = CCM_PCCR0_SSI2_IPG_OFFSET,
+		.disable = _clk_disable,
+	},
+};
+
+static struct clk nfc_clk = {
+	.name = "nfc_clk",
+	.parent = &cpu_clk,
+	.get_rate = _clk_nfc_recalc,
+	.enable = _clk_enable,
+	.enable_reg = CCM_PCCR1,
+	.enable_shift = CCM_PCCR1_NFC_BAUD_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk vpu_clk = {
+	.name = "vpu_clk",
+	.parent = &mpll_main_clk[1],
+	.get_rate = _clk_vpu_recalc,
+	.enable = _clk_vpu_enable,
+	.disable = _clk_vpu_disable,
+};
+
+static struct clk dma_clk = {
+	.name = "dma_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_dma_enable,
+	.disable = _clk_dma_disable,
+};
+
+static struct clk rtic_clk = {
+	.name = "rtic_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_rtic_enable,
+	.disable = _clk_rtic_disable,
+};
+
+static struct clk brom_clk = {
+	.name = "brom_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_enable,
+	.enable_reg = CCM_PCCR1,
+	.enable_shift = CCM_PCCR1_HCLK_BROM_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk emma_clk = {
+	.name = "emma_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_emma_enable,
+	.disable = _clk_emma_disable,
+};
+
+static struct clk slcdc_clk = {
+	.name = "slcdc_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_slcdc_enable,
+	.disable = _clk_slcdc_disable,
+};
+
+static struct clk fec_clk = {
+	.name = "fec_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_fec_enable,
+	.disable = _clk_fec_disable,
+};
+
+static struct clk emi_clk = {
+	.name = "emi_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_enable,
+	.enable_reg = CCM_PCCR1,
+	.enable_shift = CCM_PCCR1_HCLK_EMI_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk sahara2_clk = {
+	.name = "sahara_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_sahara2_enable,
+	.disable = _clk_sahara2_disable,
+};
+
+static struct clk ata_clk = {
+	.name = "ata_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_enable,
+	.enable_reg = CCM_PCCR1,
+	.enable_shift = CCM_PCCR1_HCLK_ATA_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk mstick1_clk = {
+	.name = "mstick1_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_mstick1_enable,
+	.disable = _clk_mstick1_disable,
+};
+
+static struct clk wdog_clk = {
+	.name = "wdog_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = CCM_PCCR1,
+	.enable_shift = CCM_PCCR1_WDT_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk gpio_clk = {
+	.name = "gpio_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = CCM_PCCR1,
+	.enable_shift = CCM_PCCR0_GPIO_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk i2c_clk[] = {
+	{
+		.name = "i2c_clk",
+		.id = 0,
+		.parent = &ipg_clk,
+		.enable = _clk_enable,
+		.enable_reg = CCM_PCCR0,
+		.enable_shift = CCM_PCCR0_I2C1_OFFSET,
+		.disable = _clk_disable,
+	}, {
+		.name = "i2c_clk",
+		.id = 1,
+		.parent = &ipg_clk,
+		.enable = _clk_enable,
+		.enable_reg = CCM_PCCR0,
+		.enable_shift = CCM_PCCR0_I2C2_OFFSET,
+		.disable = _clk_disable,
+	},
+};
+
+static struct clk iim_clk = {
+	.name = "iim_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = CCM_PCCR0,
+	.enable_shift = CCM_PCCR0_IIM_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk kpp_clk = {
+	.name = "kpp_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = CCM_PCCR0,
+	.enable_shift = CCM_PCCR0_KPP_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk owire_clk = {
+	.name = "owire_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = CCM_PCCR0,
+	.enable_shift = CCM_PCCR0_OWIRE_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk rtc_clk = {
+	.name = "rtc_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = CCM_PCCR0,
+	.enable_shift = CCM_PCCR0_RTC_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk scc_clk = {
+	.name = "scc_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = CCM_PCCR0,
+	.enable_shift = CCM_PCCR0_SCC_OFFSET,
+	.disable = _clk_disable,
+};
+
+static unsigned long _clk_clko_round_rate(struct clk *clk, unsigned long rate)
+{
+	u32 div;
+	unsigned long parent_rate;
+
+	parent_rate = clk_get_rate(clk->parent);
+	div = parent_rate / rate;
+	if (parent_rate % rate)
+		div++;
+
+	if (div > 8)
+		div = 8;
+
+	return parent_rate / div;
+}
+
+static int _clk_clko_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	u32 div;
+	unsigned long parent_rate;
+
+	parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+
+	if (div > 8 || div < 1 || ((parent_rate / div) != rate))
+		return -EINVAL;
+	div--;
+
+	reg = __raw_readl(CCM_PCDR0) & ~CCM_PCDR0_CLKODIV_MASK;
+	reg |= div << CCM_PCDR0_CLKODIV_OFFSET;
+	__raw_writel(reg, CCM_PCDR0);
+
+	return 0;
+}
+
+static unsigned long _clk_clko_recalc(struct clk *clk)
+{
+	u32 div;
+	unsigned long parent_rate;
+
+	parent_rate = clk_get_rate(clk->parent);
+
+	div = __raw_readl(CCM_PCDR0) & CCM_PCDR0_CLKODIV_MASK >>
+		CCM_PCDR0_CLKODIV_OFFSET;
+	div++;
+
+	return parent_rate / div;
+}
+
+static int _clk_clko_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	reg = __raw_readl(CCM_CCSR) & ~CCM_CCSR_CLKOSEL_MASK;
+
+	if (parent == &ckil_clk)
+		reg |= 0 << CCM_CCSR_CLKOSEL_OFFSET;
+	else if (parent == &ckih_clk)
+		reg |= 2 << CCM_CCSR_CLKOSEL_OFFSET;
+	else if (parent == mpll_clk.parent)
+		reg |= 3 << CCM_CCSR_CLKOSEL_OFFSET;
+	else if (parent == spll_clk.parent)
+		reg |= 4 << CCM_CCSR_CLKOSEL_OFFSET;
+	else if (parent == &mpll_clk)
+		reg |= 5 << CCM_CCSR_CLKOSEL_OFFSET;
+	else if (parent == &spll_clk)
+		reg |= 6 << CCM_CCSR_CLKOSEL_OFFSET;
+	else if (parent == &cpu_clk)
+		reg |= 7 << CCM_CCSR_CLKOSEL_OFFSET;
+	else if (parent == &ahb_clk)
+		reg |= 8 << CCM_CCSR_CLKOSEL_OFFSET;
+	else if (parent == &ipg_clk)
+		reg |= 9 << CCM_CCSR_CLKOSEL_OFFSET;
+	else if (parent == &per_clk[0])
+		reg |= 0xA << CCM_CCSR_CLKOSEL_OFFSET;
+	else if (parent == &per_clk[1])
+		reg |= 0xB << CCM_CCSR_CLKOSEL_OFFSET;
+	else if (parent == &per_clk[2])
+		reg |= 0xC << CCM_CCSR_CLKOSEL_OFFSET;
+	else if (parent == &per_clk[3])
+		reg |= 0xD << CCM_CCSR_CLKOSEL_OFFSET;
+	else if (parent == &ssi1_clk[0])
+		reg |= 0xE << CCM_CCSR_CLKOSEL_OFFSET;
+	else if (parent == &ssi2_clk[0])
+		reg |= 0xF << CCM_CCSR_CLKOSEL_OFFSET;
+	else if (parent == &nfc_clk)
+		reg |= 0x10 << CCM_CCSR_CLKOSEL_OFFSET;
+	else if (parent == &mstick1_clk)
+		reg |= 0x11 << CCM_CCSR_CLKOSEL_OFFSET;
+	else if (parent == &vpu_clk)
+		reg |= 0x12 << CCM_CCSR_CLKOSEL_OFFSET;
+	else if (parent == &usb_clk[0])
+		reg |= 0x15 << CCM_CCSR_CLKOSEL_OFFSET;
+	else
+		return -EINVAL;
+
+	__raw_writel(reg, CCM_CCSR);
+
+	return 0;
+}
+
+static int _clk_clko_enable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(CCM_PCDR0) | CCM_PCDR0_CLKO_EN;
+	__raw_writel(reg, CCM_PCDR0);
+
+	return 0;
+}
+
+static void _clk_clko_disable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(CCM_PCDR0) & ~CCM_PCDR0_CLKO_EN;
+	__raw_writel(reg, CCM_PCDR0);
+}
+
+static struct clk clko_clk = {
+	.name = "clko_clk",
+	.get_rate = _clk_clko_recalc,
+	.set_rate = _clk_clko_set_rate,
+	.round_rate = _clk_clko_round_rate,
+	.set_parent = _clk_clko_set_parent,
+	.enable = _clk_clko_enable,
+	.disable = _clk_clko_disable,
+};
+
+static struct clk *mxc_clks[] = {
+	&ckih_clk,
+	&ckil_clk,
+	&mpll_clk,
+	&mpll_main_clk[0],
+	&mpll_main_clk[1],
+	&spll_clk,
+	&cpu_clk,
+	&ahb_clk,
+	&ipg_clk,
+	&per_clk[0],
+	&per_clk[1],
+	&per_clk[2],
+	&per_clk[3],
+	&clko_clk,
+	&uart1_clk[0],
+	&uart1_clk[1],
+	&uart2_clk[0],
+	&uart2_clk[1],
+	&uart3_clk[0],
+	&uart3_clk[1],
+	&uart4_clk[0],
+	&uart4_clk[1],
+	&uart5_clk[0],
+	&uart5_clk[1],
+	&uart6_clk[0],
+	&uart6_clk[1],
+	&gpt1_clk[0],
+	&gpt1_clk[1],
+	&gpt2_clk[0],
+	&gpt2_clk[1],
+	&gpt3_clk[0],
+	&gpt3_clk[1],
+	&gpt4_clk[0],
+	&gpt4_clk[1],
+	&gpt5_clk[0],
+	&gpt5_clk[1],
+	&gpt6_clk[0],
+	&gpt6_clk[1],
+	&pwm_clk[0],
+	&pwm_clk[1],
+	&sdhc1_clk[0],
+	&sdhc1_clk[1],
+	&sdhc2_clk[0],
+	&sdhc2_clk[1],
+	&sdhc3_clk[0],
+	&sdhc3_clk[1],
+	&cspi1_clk[0],
+	&cspi1_clk[1],
+	&cspi2_clk[0],
+	&cspi2_clk[1],
+	&cspi3_clk[0],
+	&cspi3_clk[1],
+	&lcdc_clk[0],
+	&lcdc_clk[1],
+	&lcdc_clk[2],
+	&csi_clk[0],
+	&csi_clk[1],
+	&usb_clk[0],
+	&usb_clk[1],
+	&ssi1_clk[0],
+	&ssi1_clk[1],
+	&ssi2_clk[0],
+	&ssi2_clk[1],
+	&nfc_clk,
+	&vpu_clk,
+	&dma_clk,
+	&rtic_clk,
+	&brom_clk,
+	&emma_clk,
+	&slcdc_clk,
+	&fec_clk,
+	&emi_clk,
+	&sahara2_clk,
+	&ata_clk,
+	&mstick1_clk,
+	&wdog_clk,
+	&gpio_clk,
+	&i2c_clk[0],
+	&i2c_clk[1],
+	&iim_clk,
+	&kpp_clk,
+	&owire_clk,
+	&rtc_clk,
+	&scc_clk,
+};
+
+void __init change_external_low_reference(unsigned long new_ref)
+{
+	external_low_reference = new_ref;
+}
+
+unsigned long __init clk_early_get_timer_rate(void)
+{
+	return clk_get_rate(&per_clk[0]);
+}
+
+static void __init probe_mxc_clocks(void)
+{
+	int i;
+
+	if (mx27_revision() >= CHIP_REV_2_0) {
+		if (CSCR() & 0x8000)
+			cpu_clk.parent = &mpll_main_clk[0];
+
+		if (!(CSCR() & 0x00800000))
+			ssi2_clk[0].parent = &spll_clk;
+
+		if (!(CSCR() & 0x00400000))
+			ssi1_clk[0].parent = &spll_clk;
+
+		if (!(CSCR() & 0x00200000))
+			vpu_clk.parent = &spll_clk;
+	} else {
+		cpu_clk.parent = &mpll_clk;
+		cpu_clk.set_parent = NULL;
+		cpu_clk.round_rate = NULL;
+		cpu_clk.set_rate = NULL;
+		ahb_clk.parent = &mpll_clk;
+
+		for (i = 0; i < sizeof(per_clk) / sizeof(per_clk[0]); i++)
+			per_clk[i].parent = &mpll_clk;
+
+		ssi1_clk[0].parent = &mpll_clk;
+		ssi2_clk[0].parent = &mpll_clk;
+
+		vpu_clk.parent = &mpll_clk;
+	}
+}
+
+/*
+ * must be called very early to get information about the
+ * available clock rate when the timer framework starts
+ */
+int __init mxc_clocks_init(unsigned long fref)
+{
+	u32 cscr;
+	struct clk **clkp;
+
+	external_high_reference = fref;
+
+	/* detect clock reference for both system PLL */
+	cscr = CSCR();
+	if (cscr & CCM_CSCR_MCU)
+		mpll_clk.parent = &ckih_clk;
+	else
+		mpll_clk.parent = &ckil_clk;
+
+	if (cscr & CCM_CSCR_SP)
+		spll_clk.parent = &ckih_clk;
+	else
+		spll_clk.parent = &ckil_clk;
+
+	probe_mxc_clocks();
+
+	per_clk[0].enable(&per_clk[0]);
+	gpt1_clk[1].enable(&gpt1_clk[1]);
+
+	for (clkp = mxc_clks; clkp < mxc_clks + ARRAY_SIZE(mxc_clks); clkp++)
+		clk_register(*clkp);
+
+	/* Turn off all possible clocks */
+	__raw_writel(CCM_PCCR0_GPT1_MASK, CCM_PCCR0);
+	__raw_writel(CCM_PCCR1_PERCLK1_MASK | CCM_PCCR1_HCLK_EMI_MASK,
+		     CCM_PCCR1);
+	spll_clk.disable(&spll_clk);
+
+	/* This will propagate to all children and init all the clock rates */
+
+	clk_enable(&emi_clk);
+	clk_enable(&gpio_clk);
+	clk_enable(&iim_clk);
+	clk_enable(&gpt1_clk[0]);
+#ifdef CONFIG_DEBUG_LL_CONSOLE
+	clk_enable(&uart1_clk[0]);
+#endif
+	return 0;
+}
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx2/cpu_imx27.c ipipe-2.6.26-mxc/arch/arm/mach-mx2/cpu_imx27.c
--- adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx2/cpu_imx27.c	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/arch/arm/mach-mx2/cpu_imx27.c	2008-10-19 15:15:34.000000000 +0200
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ */
+
+/*
+ * i.MX27 specific CPU detection code
+ */
+
+#include <linux/io.h>
+#include <linux/module.h>
+
+#include <asm/hardware.h>
+
+#include "crm_regs.h"
+
+static int cpu_silicon_rev = -1;
+static int cpu_partnumber;
+
+static void query_silicon_parameter(void)
+{
+	u32 val;
+	/*
+	 * now we have access to the IO registers. As we need
+	 * the silicon revision very early we read it here to
+	 * avoid any further hooks
+	*/
+	val = __raw_readl(IO_ADDRESS(SYSCTRL_BASE_ADDR) + SYS_CHIP_ID);
+
+	cpu_silicon_rev = (int)(val >> 28);
+	cpu_partnumber = (int)((val >> 12) & 0xFFFF);
+}
+
+/*
+ * Returns:
+ *	the silicon revision of the cpu
+ *	-EINVAL - not a mx27
+ */
+int mx27_revision(void)
+{
+	if (cpu_silicon_rev == -1)
+		query_silicon_parameter();
+
+	if (cpu_partnumber != 0x8821)
+		return -EINVAL;
+
+	return cpu_silicon_rev;
+}
+EXPORT_SYMBOL(mx27_revision);
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx2/crm_regs.h ipipe-2.6.26-mxc/arch/arm/mach-mx2/crm_regs.h
--- adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx2/crm_regs.h	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/arch/arm/mach-mx2/crm_regs.h	2008-10-19 15:15:34.000000000 +0200
@@ -0,0 +1,273 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ */
+
+#ifndef __ARCH_ARM_MACH_MX2_CRM_REGS_H__
+#define __ARCH_ARM_MACH_MX2_CRM_REGS_H__
+
+#include <asm/arch/hardware.h>
+
+/* Register offsets */
+#define CCM_CSCR                (IO_ADDRESS(CCM_BASE_ADDR) + 0x0)
+#define CCM_MPCTL0              (IO_ADDRESS(CCM_BASE_ADDR) + 0x4)
+#define CCM_MPCTL1              (IO_ADDRESS(CCM_BASE_ADDR) + 0x8)
+#define CCM_SPCTL0              (IO_ADDRESS(CCM_BASE_ADDR) + 0xC)
+#define CCM_SPCTL1              (IO_ADDRESS(CCM_BASE_ADDR) + 0x10)
+#define CCM_OSC26MCTL           (IO_ADDRESS(CCM_BASE_ADDR) + 0x14)
+#define CCM_PCDR0               (IO_ADDRESS(CCM_BASE_ADDR) + 0x18)
+#define CCM_PCDR1               (IO_ADDRESS(CCM_BASE_ADDR) + 0x1c)
+#define CCM_PCCR0               (IO_ADDRESS(CCM_BASE_ADDR) + 0x20)
+#define CCM_PCCR1               (IO_ADDRESS(CCM_BASE_ADDR) + 0x24)
+#define CCM_CCSR                (IO_ADDRESS(CCM_BASE_ADDR) + 0x28)
+#define CCM_PMCTL               (IO_ADDRESS(CCM_BASE_ADDR) + 0x2c)
+#define CCM_PMCOUNT             (IO_ADDRESS(CCM_BASE_ADDR) + 0x30)
+#define CCM_WKGDCTL             (IO_ADDRESS(CCM_BASE_ADDR) + 0x34)
+
+#define CCM_CSCR_USB_OFFSET     28
+#define CCM_CSCR_USB_MASK       (0x7 << 28)
+#define CCM_CSCR_SD_OFFSET      24
+#define CCM_CSCR_SD_MASK        (0x3 << 24)
+#define CCM_CSCR_SSI2           (1 << 23)
+#define CCM_CSCR_SSI2_OFFSET    23
+#define CCM_CSCR_SSI1           (1 << 22)
+#define CCM_CSCR_SSI1_OFFSET    22
+#define CCM_CSCR_VPU           (1 << 21)
+#define CCM_CSCR_VPU_OFFSET    21
+#define CCM_CSCR_MSHC           (1 << 20)
+#define CCM_CSCR_SPLLRES        (1 << 19)
+#define CCM_CSCR_MPLLRES        (1 << 18)
+#define CCM_CSCR_SP             (1 << 17)
+#define CCM_CSCR_MCU            (1 << 16)
+/* CCM_CSCR_ARM_xxx just be avaliable on i.MX27 TO2*/
+#define CCM_CSCR_ARM_SRC        (1 << 15)
+#define CCM_CSCR_ARM_OFFSET     12
+#define CCM_CSCR_ARM_MASK       (0x3 << 12)
+/* CCM_CSCR_ARM_xxx just be avaliable on i.MX27 TO2*/
+#define CCM_CSCR_PRESC_OFFSET   13
+#define CCM_CSCR_PRESC_MASK     (0x7 << 13)
+#define CCM_CSCR_BCLK_OFFSET    9
+#define CCM_CSCR_BCLK_MASK      (0xf << 9)
+#define CCM_CSCR_IPDIV_OFFSET   8
+#define CCM_CSCR_IPDIV          (1 << 8)
+/* CCM_CSCR_AHB_xxx just be avaliable on i.MX27 TO2*/
+#define CCM_CSCR_AHB_OFFSET     8
+#define CCM_CSCR_AHB_MASK       (0x3 << 8)
+/* CCM_CSCR_AHB_xxx just be avaliable on i.MX27 TO2*/
+#define CCM_CSCR_OSC26MDIV      (1 << 4)
+#define CCM_CSCR_OSC26M         (1 << 3)
+#define CCM_CSCR_FPM            (1 << 2)
+#define CCM_CSCR_SPEN           (1 << 1)
+#define CCM_CSCR_MPEN           1
+
+#define CCM_MPCTL0_CPLM         (1 << 31)
+#define CCM_MPCTL0_PD_OFFSET    26
+#define CCM_MPCTL0_PD_MASK      (0xf << 26)
+#define CCM_MPCTL0_MFD_OFFSET   16
+#define CCM_MPCTL0_MFD_MASK     (0x3ff << 16)
+#define CCM_MPCTL0_MFI_OFFSET   10
+#define CCM_MPCTL0_MFI_MASK     (0xf << 10)
+#define CCM_MPCTL0_MFN_OFFSET   0
+#define CCM_MPCTL0_MFN_MASK     0x3ff
+
+#define CCM_MPCTL1_LF           (1 << 15)
+#define CCM_MPCTL1_BRMO         (1 << 6)
+
+#define CCM_SPCTL0_CPLM         (1 << 31)
+#define CCM_SPCTL0_PD_OFFSET    26
+#define CCM_SPCTL0_PD_MASK      (0xf << 26)
+#define CCM_SPCTL0_MFD_OFFSET   16
+#define CCM_SPCTL0_MFD_MASK     (0x3ff << 16)
+#define CCM_SPCTL0_MFI_OFFSET   10
+#define CCM_SPCTL0_MFI_MASK     (0xf << 10)
+#define CCM_SPCTL0_MFN_OFFSET   0
+#define CCM_SPCTL0_MFN_MASK     0x3ff
+
+#define CCM_SPCTL1_LF           (1 << 15)
+#define CCM_SPCTL1_BRMO         (1 << 6)
+
+#define CCM_OSC26MCTL_PEAK_OFFSET       16
+#define CCM_OSC26MCTL_PEAK_MASK         (0x3 << 16)
+#define CCM_OSC26MCTL_AGC_OFFSET        8
+#define CCM_OSC26MCTL_AGC_MASK          (0x3f << 8)
+#define CCM_OSC26MCTL_ANATEST_OFFSET    0
+#define CCM_OSC26MCTL_ANATEST_MASK      0x3f
+
+#define CCM_PCDR0_SSI2BAUDDIV_OFFSET    26
+#define CCM_PCDR0_SSI2BAUDDIV_MASK      (0x3f << 26)
+#define CCM_PCDR0_CLKO_EN               25
+#define CCM_PCDR0_CLKODIV_OFFSET        22
+#define CCM_PCDR0_CLKODIV_MASK          (0x7 << 22)
+#define CCM_PCDR0_SSI1BAUDDIV_OFFSET    16
+#define CCM_PCDR0_SSI1BAUDDIV_MASK      (0x3f << 16)
+/*The difinition for i.MX27 TO2*/
+#define CCM_PCDR0_VPUDIV2_OFFSET        10
+#define CCM_PCDR0_VPUDIV2_MASK          (0x3f << 10)
+#define CCM_PCDR0_NFCDIV2_OFFSET         6
+#define CCM_PCDR0_NFCDIV2_MASK           (0xf << 6)
+#define CCM_PCDR0_MSHCDIV2_MASK          0x3f
+/*The difinition for i.MX27 TO2*/
+#define CCM_PCDR0_NFCDIV_OFFSET         12
+#define CCM_PCDR0_NFCDIV_MASK           (0xf << 12)
+#define CCM_PCDR0_VPUDIV_OFFSET        8
+#define CCM_PCDR0_VPUDIV_MASK          (0xf << 8)
+#define CCM_PCDR0_MSHCDIV_OFFSET        0
+#define CCM_PCDR0_MSHCDIV_MASK          0x1f
+
+#define CCM_PCDR1_PERDIV4_OFFSET        24
+#define CCM_PCDR1_PERDIV4_MASK          (0x3f << 24)
+#define CCM_PCDR1_PERDIV3_OFFSET        16
+#define CCM_PCDR1_PERDIV3_MASK          (0x3f << 16)
+#define CCM_PCDR1_PERDIV2_OFFSET        8
+#define CCM_PCDR1_PERDIV2_MASK          (0x3f << 8)
+#define CCM_PCDR1_PERDIV1_OFFSET        0
+#define CCM_PCDR1_PERDIV1_MASK          0x3f
+
+#define CCM_PCCR0_CSPI1_OFFSET          31
+#define CCM_PCCR0_CSPI1_MASK            (1 << 31)
+#define CCM_PCCR0_CSPI2_OFFSET          30
+#define CCM_PCCR0_CSPI2_MASK            (1 << 30)
+#define CCM_PCCR0_CSPI3_OFFSET          29
+#define CCM_PCCR0_CSPI3_MASK            (1 << 29)
+#define CCM_PCCR0_DMA_OFFSET            28
+#define CCM_PCCR0_DMA_MASK              (1 << 28)
+#define CCM_PCCR0_EMMA_OFFSET           27
+#define CCM_PCCR0_EMMA_MASK             (1 << 27)
+#define CCM_PCCR0_FEC_OFFSET            26
+#define CCM_PCCR0_FEC_MASK              (1 << 26)
+#define CCM_PCCR0_GPIO_OFFSET           25
+#define CCM_PCCR0_GPIO_MASK             (1 << 25)
+#define CCM_PCCR0_GPT1_OFFSET           24
+#define CCM_PCCR0_GPT1_MASK             (1 << 24)
+#define CCM_PCCR0_GPT2_OFFSET           23
+#define CCM_PCCR0_GPT2_MASK             (1 << 23)
+#define CCM_PCCR0_GPT3_OFFSET           22
+#define CCM_PCCR0_GPT3_MASK             (1 << 22)
+#define CCM_PCCR0_GPT4_OFFSET           21
+#define CCM_PCCR0_GPT4_MASK             (1 << 21)
+#define CCM_PCCR0_GPT5_OFFSET           20
+#define CCM_PCCR0_GPT5_MASK             (1 << 20)
+#define CCM_PCCR0_GPT6_OFFSET           19
+#define CCM_PCCR0_GPT6_MASK             (1 << 19)
+#define CCM_PCCR0_I2C1_OFFSET           18
+#define CCM_PCCR0_I2C1_MASK             (1 << 18)
+#define CCM_PCCR0_I2C2_OFFSET           17
+#define CCM_PCCR0_I2C2_MASK             (1 << 17)
+#define CCM_PCCR0_IIM_OFFSET            16
+#define CCM_PCCR0_IIM_MASK              (1 << 16)
+#define CCM_PCCR0_KPP_OFFSET            15
+#define CCM_PCCR0_KPP_MASK              (1 << 15)
+#define CCM_PCCR0_LCDC_OFFSET           14
+#define CCM_PCCR0_LCDC_MASK             (1 << 14)
+#define CCM_PCCR0_MSHC_OFFSET           13
+#define CCM_PCCR0_MSHC_MASK             (1 << 13)
+#define CCM_PCCR0_OWIRE_OFFSET          12
+#define CCM_PCCR0_OWIRE_MASK            (1 << 12)
+#define CCM_PCCR0_PWM_OFFSET            11
+#define CCM_PCCR0_PWM_MASK              (1 << 11)
+#define CCM_PCCR0_RTC_OFFSET            9
+#define CCM_PCCR0_RTC_MASK              (1 << 9)
+#define CCM_PCCR0_RTIC_OFFSET           8
+#define CCM_PCCR0_RTIC_MASK             (1 << 8)
+#define CCM_PCCR0_SAHARA_OFFSET         7
+#define CCM_PCCR0_SAHARA_MASK           (1 << 7)
+#define CCM_PCCR0_SCC_OFFSET            6
+#define CCM_PCCR0_SCC_MASK              (1 << 6)
+#define CCM_PCCR0_SDHC1_OFFSET          5
+#define CCM_PCCR0_SDHC1_MASK            (1 << 5)
+#define CCM_PCCR0_SDHC2_OFFSET          4
+#define CCM_PCCR0_SDHC2_MASK            (1 << 4)
+#define CCM_PCCR0_SDHC3_OFFSET          3
+#define CCM_PCCR0_SDHC3_MASK            (1 << 3)
+#define CCM_PCCR0_SLCDC_OFFSET          2
+#define CCM_PCCR0_SLCDC_MASK            (1 << 2)
+#define CCM_PCCR0_SSI1_IPG_OFFSET       1
+#define CCM_PCCR0_SSI1_IPG_MASK         (1 << 1)
+#define CCM_PCCR0_SSI2_IPG_OFFSET       0
+#define CCM_PCCR0_SSI2_IPG_MASK         (1 << 0)
+
+#define CCM_PCCR1_UART1_OFFSET          31
+#define CCM_PCCR1_UART1_MASK            (1 << 31)
+#define CCM_PCCR1_UART2_OFFSET          30
+#define CCM_PCCR1_UART2_MASK            (1 << 30)
+#define CCM_PCCR1_UART3_OFFSET          29
+#define CCM_PCCR1_UART3_MASK            (1 << 29)
+#define CCM_PCCR1_UART4_OFFSET          28
+#define CCM_PCCR1_UART4_MASK            (1 << 28)
+#define CCM_PCCR1_UART5_OFFSET          27
+#define CCM_PCCR1_UART5_MASK            (1 << 27)
+#define CCM_PCCR1_UART6_OFFSET          26
+#define CCM_PCCR1_UART6_MASK            (1 << 26)
+#define CCM_PCCR1_USBOTG_OFFSET         25
+#define CCM_PCCR1_USBOTG_MASK           (1 << 25)
+#define CCM_PCCR1_WDT_OFFSET            24
+#define CCM_PCCR1_WDT_MASK              (1 << 24)
+#define CCM_PCCR1_HCLK_ATA_OFFSET       23
+#define CCM_PCCR1_HCLK_ATA_MASK         (1 << 23)
+#define CCM_PCCR1_HCLK_BROM_OFFSET      22
+#define CCM_PCCR1_HCLK_BROM_MASK        (1 << 22)
+#define CCM_PCCR1_HCLK_CSI_OFFSET       21
+#define CCM_PCCR1_HCLK_CSI_MASK         (1 << 21)
+#define CCM_PCCR1_HCLK_DMA_OFFSET       20
+#define CCM_PCCR1_HCLK_DMA_MASK         (1 << 20)
+#define CCM_PCCR1_HCLK_EMI_OFFSET       19
+#define CCM_PCCR1_HCLK_EMI_MASK         (1 << 19)
+#define CCM_PCCR1_HCLK_EMMA_OFFSET      18
+#define CCM_PCCR1_HCLK_EMMA_MASK        (1 << 18)
+#define CCM_PCCR1_HCLK_FEC_OFFSET       17
+#define CCM_PCCR1_HCLK_FEC_MASK         (1 << 17)
+#define CCM_PCCR1_HCLK_VPU_OFFSET       16
+#define CCM_PCCR1_HCLK_VPU_MASK         (1 << 16)
+#define CCM_PCCR1_HCLK_LCDC_OFFSET      15
+#define CCM_PCCR1_HCLK_LCDC_MASK        (1 << 15)
+#define CCM_PCCR1_HCLK_RTIC_OFFSET      14
+#define CCM_PCCR1_HCLK_RTIC_MASK        (1 << 14)
+#define CCM_PCCR1_HCLK_SAHARA_OFFSET    13
+#define CCM_PCCR1_HCLK_SAHARA_MASK      (1 << 13)
+#define CCM_PCCR1_HCLK_SLCDC_OFFSET     12
+#define CCM_PCCR1_HCLK_SLCDC_MASK       (1 << 12)
+#define CCM_PCCR1_HCLK_USBOTG_OFFSET    11
+#define CCM_PCCR1_HCLK_USBOTG_MASK      (1 << 11)
+#define CCM_PCCR1_PERCLK1_OFFSET        10
+#define CCM_PCCR1_PERCLK1_MASK          (1 << 10)
+#define CCM_PCCR1_PERCLK2_OFFSET        9
+#define CCM_PCCR1_PERCLK2_MASK          (1 << 9)
+#define CCM_PCCR1_PERCLK3_OFFSET        8
+#define CCM_PCCR1_PERCLK3_MASK          (1 << 8)
+#define CCM_PCCR1_PERCLK4_OFFSET        7
+#define CCM_PCCR1_PERCLK4_MASK          (1 << 7)
+#define CCM_PCCR1_VPU_BAUD_OFFSET       6
+#define CCM_PCCR1_VPU_BAUD_MASK         (1 << 6)
+#define CCM_PCCR1_SSI1_BAUD_OFFSET      5
+#define CCM_PCCR1_SSI1_BAUD_MASK        (1 << 5)
+#define CCM_PCCR1_SSI2_BAUD_OFFSET      4
+#define CCM_PCCR1_SSI2_BAUD_MASK        (1 << 4)
+#define CCM_PCCR1_NFC_BAUD_OFFSET       3
+#define CCM_PCCR1_NFC_BAUD_MASK         (1 << 3)
+#define CCM_PCCR1_MSHC_BAUD_OFFSET      2
+#define CCM_PCCR1_MSHC_BAUD_MASK        (1 << 2)
+
+#define CCM_CCSR_32KSR          (1 << 15)
+#define CCM_CCSR_CLKMODE1       (1 << 9)
+#define CCM_CCSR_CLKMODE0       (1 << 8)
+#define CCM_CCSR_CLKOSEL_OFFSET 0
+#define CCM_CCSR_CLKOSEL_MASK   0x1f
+
+#define SYS_FMCR                0x14	/*  Functional Muxing Control Reg */
+#define SYS_CHIP_ID             0x00	/* The offset of CHIP ID register */
+
+#endif /* __ARCH_ARM_MACH_MX2_CRM_REGS_H__ */
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx2/devices.c ipipe-2.6.26-mxc/arch/arm/mach-mx2/devices.c
--- adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx2/devices.c	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/arch/arm/mach-mx2/devices.c	2008-10-19 15:15:34.000000000 +0200
@@ -0,0 +1,231 @@
+/*
+ * Author: MontaVista Software, Inc.
+ *       <source@mvista.com>
+ *
+ * Based on the OMAP devices.c
+ *
+ * 2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Copyright 2006-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+
+#include <asm/hardware.h>
+
+/*
+ * Resource definition for the MXC IrDA
+ */
+static struct resource mxc_irda_resources[] = {
+	[0] = {
+		.start   = UART3_BASE_ADDR,
+		.end     = UART3_BASE_ADDR + SZ_4K - 1,
+		.flags   = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start   = MXC_INT_UART3,
+		.end     = MXC_INT_UART3,
+		.flags   = IORESOURCE_IRQ,
+	},
+};
+
+/* Platform Data for MXC IrDA */
+struct platform_device mxc_irda_device = {
+	.name = "mxc_irda",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(mxc_irda_resources),
+	.resource = mxc_irda_resources,
+};
+
+/*
+ * General Purpose Timer
+ * - i.MX1: 2 timer (slighly different register handling)
+ * - i.MX21: 3 timer
+ * - i.MX27: 6 timer
+ */
+
+/* We use gpt0 as system timer, so do not add a device for this one */
+
+static struct resource timer1_resources[] = {
+	[0] = {
+		.start	= GPT2_BASE_ADDR,
+		.end	= GPT2_BASE_ADDR + 0x17,
+		.flags	= IORESOURCE_MEM
+	},
+	[1] = {
+		.start   = MXC_INT_GPT2,
+		.end     = MXC_INT_GPT2,
+		.flags   = IORESOURCE_IRQ,
+	}
+};
+
+struct platform_device mxc_gpt1 = {
+	.name = "imx_gpt",
+	.id = 1,
+	.num_resources = ARRAY_SIZE(timer1_resources),
+	.resource = timer1_resources
+};
+
+static struct resource timer2_resources[] = {
+	[0] = {
+		.start	= GPT3_BASE_ADDR,
+		.end	= GPT3_BASE_ADDR + 0x17,
+		.flags	= IORESOURCE_MEM
+	},
+	[1] = {
+		.start   = MXC_INT_GPT3,
+		.end     = MXC_INT_GPT3,
+		.flags   = IORESOURCE_IRQ,
+	}
+};
+
+struct platform_device mxc_gpt2 = {
+	.name = "imx_gpt",
+	.id = 2,
+	.num_resources = ARRAY_SIZE(timer2_resources),
+	.resource = timer2_resources
+};
+
+#ifdef CONFIG_MACH_MX27
+static struct resource timer3_resources[] = {
+	[0] = {
+		.start	= GPT4_BASE_ADDR,
+		.end	= GPT4_BASE_ADDR + 0x17,
+		.flags	= IORESOURCE_MEM
+	},
+	[1] = {
+		.start   = MXC_INT_GPT4,
+		.end     = MXC_INT_GPT4,
+		.flags   = IORESOURCE_IRQ,
+	}
+};
+
+struct platform_device mxc_gpt3 = {
+	.name = "imx_gpt",
+	.id = 3,
+	.num_resources = ARRAY_SIZE(timer3_resources),
+	.resource = timer3_resources
+};
+
+static struct resource timer4_resources[] = {
+	[0] = {
+		.start	= GPT5_BASE_ADDR,
+		.end	= GPT5_BASE_ADDR + 0x17,
+		.flags	= IORESOURCE_MEM
+	},
+	[1] = {
+		.start   = MXC_INT_GPT5,
+		.end     = MXC_INT_GPT5,
+		.flags   = IORESOURCE_IRQ,
+	}
+};
+
+struct platform_device mxc_gpt4 = {
+	.name = "imx_gpt",
+	.id = 4,
+	.num_resources = ARRAY_SIZE(timer4_resources),
+	.resource = timer4_resources
+};
+
+static struct resource timer5_resources[] = {
+	[0] = {
+		.start	= GPT6_BASE_ADDR,
+		.end	= GPT6_BASE_ADDR + 0x17,
+		.flags	= IORESOURCE_MEM
+	},
+	[1] = {
+		.start   = MXC_INT_GPT6,
+		.end     = MXC_INT_GPT6,
+		.flags   = IORESOURCE_IRQ,
+	}
+};
+
+struct platform_device mxc_gpt5 = {
+	.name = "imx_gpt",
+	.id = 5,
+	.num_resources = ARRAY_SIZE(timer5_resources),
+	.resource = timer5_resources
+};
+#endif
+
+/*
+ * Watchdog:
+ * - i.MX1
+ * - i.MX21
+ * - i.MX27
+ */
+static struct resource mxc_wdt_resources[] = {
+	{
+		.start	= WDOG_BASE_ADDR,
+		.end	= WDOG_BASE_ADDR + 0x30,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+struct platform_device mxc_wdt = {
+	.name = "mxc_wdt",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(mxc_wdt_resources),
+	.resource = mxc_wdt_resources,
+};
+
+/* GPIO port description */
+static struct mxc_gpio_port imx_gpio_ports[] = {
+	[0] = {
+		.chip.label = "gpio-0",
+		.irq = MXC_INT_GPIO,
+		.base = (void*)(AIPI_BASE_ADDR_VIRT + 0x15000 + 0x100 * 0),
+		.virtual_irq_start = MXC_MAX_INT_LINES,
+	},
+	[1] = {
+		.chip.label = "gpio-1",
+		.base = (void*)(AIPI_BASE_ADDR_VIRT + 0x15000 + 0x100 * 1),
+		.virtual_irq_start = MXC_MAX_INT_LINES + 32,
+	},
+	[2] = {
+		.chip.label = "gpio-2",
+		.base = (void*)(AIPI_BASE_ADDR_VIRT + 0x15000 + 0x100 * 2),
+		.virtual_irq_start = MXC_MAX_INT_LINES + 64,
+	},
+	[3] = {
+		.chip.label = "gpio-3",
+		.base = (void*)(AIPI_BASE_ADDR_VIRT + 0x15000 + 0x100 * 3),
+		.virtual_irq_start = MXC_MAX_INT_LINES + 96,
+	},
+	[4] = {
+		.chip.label = "gpio-4",
+		.base = (void*)(AIPI_BASE_ADDR_VIRT + 0x15000 + 0x100 * 4),
+		.virtual_irq_start = MXC_MAX_INT_LINES + 128,
+	},
+	[5] = {
+		.chip.label = "gpio-5",
+		.base = (void*)(AIPI_BASE_ADDR_VIRT + 0x15000 + 0x100 * 5),
+		.virtual_irq_start = MXC_MAX_INT_LINES + 160,
+	}
+};
+
+int __init mxc_register_gpios(void)
+{
+	return mxc_gpio_init(imx_gpio_ports, ARRAY_SIZE(imx_gpio_ports));
+}
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx2/generic.c ipipe-2.6.26-mxc/arch/arm/mach-mx2/generic.c
--- adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx2/generic.c	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/arch/arm/mach-mx2/generic.c	2008-10-19 15:15:34.000000000 +0200
@@ -0,0 +1,74 @@
+/*
+ * generic.c
+ *
+ * Copyright (C) 2008 Juergen Beisert (kernel@pengutronix.de)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ */
+
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <asm/hardware.h>
+#include <asm/pgtable.h>
+#include <asm/mach/map.h>
+
+/* MX27 memory map definition */
+static struct map_desc mxc_io_desc[] __initdata = {
+	/*
+	 * this fixed mapping covers:
+	 * - AIPI1
+	 * - AIPI2
+	 * - AITC
+	 * - ROM Patch
+	 * - and some reserved space
+	 */
+	{
+		.virtual = AIPI_BASE_ADDR_VIRT,
+		.pfn = __phys_to_pfn(AIPI_BASE_ADDR),
+		.length = AIPI_SIZE,
+		.type = MT_DEVICE
+	},
+	/*
+	 * this fixed mapping covers:
+	 * - CSI
+	 * - ATA
+	 */
+	{
+		.virtual = SAHB1_BASE_ADDR_VIRT,
+		.pfn = __phys_to_pfn(SAHB1_BASE_ADDR),
+		.length = SAHB1_SIZE,
+		.type = MT_DEVICE
+	},
+	/*
+	 * this fixed mapping covers:
+	 * - EMI
+	 */
+	{
+		.virtual = X_MEMC_BASE_ADDR_VIRT,
+		.pfn = __phys_to_pfn(X_MEMC_BASE_ADDR),
+		.length = X_MEMC_SIZE,
+		.type = MT_DEVICE
+	}
+};
+
+/*
+ * Initialize the memory map. It is called during the
+ * system startup to create static physical to virtual
+ * memory map for the IO modules.
+ */
+void __init mxc_map_io(void)
+{
+	iotable_init(mxc_io_desc, ARRAY_SIZE(mxc_io_desc));
+}
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx2/Kconfig ipipe-2.6.26-mxc/arch/arm/mach-mx2/Kconfig
--- adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx2/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/arch/arm/mach-mx2/Kconfig	2008-10-19 15:15:34.000000000 +0200
@@ -0,0 +1,39 @@
+comment "MX2 family CPU support"
+	depends on ARCH_MX2
+
+config MACH_MX27
+	bool "i.MX27 support"
+	depends on ARCH_MX2
+	help
+	  This enables support for Freescale's MX2 based i.MX27 processor.
+
+comment "MX2 Platforms"
+	depends on ARCH_MX2
+
+config MACH_MX27ADS
+	bool "MX27ADS platform"
+	depends on MACH_MX27
+	help
+	  Include support for MX27ADS platform. This includes specific
+	  configurations for the board and its peripherals.
+
+config MACH_PCM038
+	bool "Phytec phyCORE-i.MX27 CPU module (pcm038)"
+	depends on MACH_MX27
+	help
+	  Include support for phyCORE-i.MX27 (aka pcm038) platform. This
+	  includes specific configurations for the module and its peripherals.
+
+choice
+	prompt "Baseboard"
+	depends on MACH_PCM038
+	default MACH_PCM970_BASEBOARD
+
+config MACH_PCM970_BASEBOARD
+	prompt "PHYTEC PCM970 development board"
+	bool
+	help
+	  This adds board specific devices that can be found on Phytec's
+	  PCM970 evaluation board.
+
+endchoice
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx2/Makefile ipipe-2.6.26-mxc/arch/arm/mach-mx2/Makefile
--- adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx2/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/arch/arm/mach-mx2/Makefile	2008-10-19 15:15:34.000000000 +0200
@@ -0,0 +1,14 @@
+#
+# Makefile for the linux kernel.
+#
+
+# Object file lists.
+
+obj-y	:=  system.o generic.o devices.o serial.o
+
+obj-$(CONFIG_MACH_MX27) += cpu_imx27.o
+obj-$(CONFIG_MACH_MX27) += clock_imx27.o
+
+obj-$(CONFIG_MACH_MX27ADS) += mx27ads.o
+obj-$(CONFIG_MACH_PCM038) += pcm038.o
+obj-$(CONFIG_MACH_PCM970_BASEBOARD) += pcm970-baseboard.o
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx2/Makefile.boot ipipe-2.6.26-mxc/arch/arm/mach-mx2/Makefile.boot
--- adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx2/Makefile.boot	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/arch/arm/mach-mx2/Makefile.boot	2008-10-19 15:15:34.000000000 +0200
@@ -0,0 +1,3 @@
+   zreladdr-y	:= 0xA0008000
+params_phys-y	:= 0xA0000100
+initrd_phys-y	:= 0xA0800000
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx2/mx27ads.c ipipe-2.6.26-mxc/arch/arm/mach-mx2/mx27ads.c
--- adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx2/mx27ads.c	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/arch/arm/mach-mx2/mx27ads.c	2008-10-19 15:15:34.000000000 +0200
@@ -0,0 +1,304 @@
+/*
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd
+ *  Copyright (C) 2002 Shane Nay (shane@minirl.com)
+ *  Copyright 2006-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/physmap.h>
+#include <asm/arch/common.h>
+#include <asm/hardware.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/time.h>
+#include <asm/mach/map.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/imx-uart.h>
+#include <asm/arch/iomux-mx1-mx2.h>
+#include <asm/arch/board-mx27ads.h>
+
+/* ADS's NOR flash */
+static struct physmap_flash_data mx27ads_flash_data = {
+	.width = 2,
+};
+
+static struct resource mx27ads_flash_resource = {
+	.start = 0xc0000000,
+	.end = 0xc0000000 + 0x02000000 - 1,
+	.flags = IORESOURCE_MEM,
+
+};
+
+static struct platform_device mx27ads_nor_mtd_device = {
+	.name = "physmap-flash",
+	.id = 0,
+	.dev = {
+		.platform_data = &mx27ads_flash_data,
+	},
+	.num_resources = 1,
+	.resource = &mx27ads_flash_resource,
+};
+
+static int mxc_uart0_pins[] = {
+	PE12_PF_UART1_TXD,
+	PE13_PF_UART1_RXD,
+	PE14_PF_UART1_CTS,
+	PE15_PF_UART1_RTS
+};
+
+static int uart_mxc_port0_init(struct platform_device *pdev)
+{
+	return mxc_gpio_setup_multiple_pins(mxc_uart0_pins,
+			ARRAY_SIZE(mxc_uart0_pins),
+			MXC_GPIO_ALLOC_MODE_NORMAL, "UART0");
+}
+
+static int uart_mxc_port0_exit(struct platform_device *pdev)
+{
+	return mxc_gpio_setup_multiple_pins(mxc_uart0_pins,
+			ARRAY_SIZE(mxc_uart0_pins),
+			MXC_GPIO_ALLOC_MODE_RELEASE, "UART0");
+}
+
+static int mxc_uart1_pins[] = {
+	PE3_PF_UART2_CTS,
+	PE4_PF_UART2_RTS,
+	PE6_PF_UART2_TXD,
+	PE7_PF_UART2_RXD
+};
+
+static int uart_mxc_port1_init(struct platform_device *pdev)
+{
+	return mxc_gpio_setup_multiple_pins(mxc_uart1_pins,
+			ARRAY_SIZE(mxc_uart1_pins),
+			MXC_GPIO_ALLOC_MODE_NORMAL, "UART1");
+}
+
+static int uart_mxc_port1_exit(struct platform_device *pdev)
+{
+	return mxc_gpio_setup_multiple_pins(mxc_uart1_pins,
+			ARRAY_SIZE(mxc_uart1_pins),
+			MXC_GPIO_ALLOC_MODE_RELEASE, "UART1");
+}
+
+static int mxc_uart2_pins[] = {
+	PE8_PF_UART3_TXD,
+	PE9_PF_UART3_RXD,
+	PE10_PF_UART3_CTS,
+	PE11_PF_UART3_RTS
+};
+
+static int uart_mxc_port2_init(struct platform_device *pdev)
+{
+	return mxc_gpio_setup_multiple_pins(mxc_uart2_pins,
+			ARRAY_SIZE(mxc_uart2_pins),
+			MXC_GPIO_ALLOC_MODE_NORMAL, "UART2");
+}
+
+static int uart_mxc_port2_exit(struct platform_device *pdev)
+{
+	return mxc_gpio_setup_multiple_pins(mxc_uart2_pins,
+			ARRAY_SIZE(mxc_uart2_pins),
+			MXC_GPIO_ALLOC_MODE_RELEASE, "UART2");
+}
+
+static int mxc_uart3_pins[] = {
+	PB26_AF_UART4_RTS,
+	PB28_AF_UART4_TXD,
+	PB29_AF_UART4_CTS,
+	PB31_AF_UART4_RXD
+};
+
+static int uart_mxc_port3_init(struct platform_device *pdev)
+{
+	return mxc_gpio_setup_multiple_pins(mxc_uart3_pins,
+			ARRAY_SIZE(mxc_uart3_pins),
+			MXC_GPIO_ALLOC_MODE_NORMAL, "UART3");
+}
+
+static int uart_mxc_port3_exit(struct platform_device *pdev)
+{
+	return mxc_gpio_setup_multiple_pins(mxc_uart3_pins,
+			ARRAY_SIZE(mxc_uart3_pins),
+			MXC_GPIO_ALLOC_MODE_RELEASE, "UART3");
+}
+
+static int mxc_uart4_pins[] = {
+	PB18_AF_UART5_TXD,
+	PB19_AF_UART5_RXD,
+	PB20_AF_UART5_CTS,
+	PB21_AF_UART5_RTS
+};
+
+static int uart_mxc_port4_init(struct platform_device *pdev)
+{
+	return mxc_gpio_setup_multiple_pins(mxc_uart4_pins,
+			ARRAY_SIZE(mxc_uart4_pins),
+			MXC_GPIO_ALLOC_MODE_NORMAL, "UART4");
+}
+
+static int uart_mxc_port4_exit(struct platform_device *pdev)
+{
+	return mxc_gpio_setup_multiple_pins(mxc_uart4_pins,
+			ARRAY_SIZE(mxc_uart4_pins),
+			MXC_GPIO_ALLOC_MODE_RELEASE, "UART4");
+}
+
+static int mxc_uart5_pins[] = {
+	PB10_AF_UART6_TXD,
+	PB12_AF_UART6_CTS,
+	PB11_AF_UART6_RXD,
+	PB13_AF_UART6_RTS
+};
+
+static int uart_mxc_port5_init(struct platform_device *pdev)
+{
+	return mxc_gpio_setup_multiple_pins(mxc_uart5_pins,
+			ARRAY_SIZE(mxc_uart5_pins),
+			MXC_GPIO_ALLOC_MODE_NORMAL, "UART5");
+}
+
+static int uart_mxc_port5_exit(struct platform_device *pdev)
+{
+	return mxc_gpio_setup_multiple_pins(mxc_uart5_pins,
+			ARRAY_SIZE(mxc_uart5_pins),
+			MXC_GPIO_ALLOC_MODE_RELEASE, "UART5");
+}
+
+static struct platform_device *platform_devices[] __initdata = {
+	&mx27ads_nor_mtd_device,
+};
+
+static int mxc_fec_pins[] = {
+	PD0_AIN_FEC_TXD0,
+	PD1_AIN_FEC_TXD1,
+	PD2_AIN_FEC_TXD2,
+	PD3_AIN_FEC_TXD3,
+	PD4_AOUT_FEC_RX_ER,
+	PD5_AOUT_FEC_RXD1,
+	PD6_AOUT_FEC_RXD2,
+	PD7_AOUT_FEC_RXD3,
+	PD8_AF_FEC_MDIO,
+	PD9_AIN_FEC_MDC,
+	PD10_AOUT_FEC_CRS,
+	PD11_AOUT_FEC_TX_CLK,
+	PD12_AOUT_FEC_RXD0,
+	PD13_AOUT_FEC_RX_DV,
+	PD14_AOUT_FEC_CLR,
+	PD15_AOUT_FEC_COL,
+	PD16_AIN_FEC_TX_ER,
+	PF23_AIN_FEC_TX_EN
+};
+
+static void gpio_fec_active(void)
+{
+	mxc_gpio_setup_multiple_pins(mxc_fec_pins,
+			ARRAY_SIZE(mxc_fec_pins),
+			MXC_GPIO_ALLOC_MODE_NORMAL, "FEC");
+}
+
+static void gpio_fec_inactive(void)
+{
+	mxc_gpio_setup_multiple_pins(mxc_fec_pins,
+			ARRAY_SIZE(mxc_fec_pins),
+			MXC_GPIO_ALLOC_MODE_RELEASE, "FEC");
+}
+
+static struct imxuart_platform_data uart_pdata[] = {
+	{
+		.init = uart_mxc_port0_init,
+		.exit = uart_mxc_port0_exit,
+		.flags = IMXUART_HAVE_RTSCTS,
+	}, {
+		.init = uart_mxc_port1_init,
+		.exit = uart_mxc_port1_exit,
+		.flags = IMXUART_HAVE_RTSCTS,
+	}, {
+		.init = uart_mxc_port2_init,
+		.exit = uart_mxc_port2_exit,
+		.flags = IMXUART_HAVE_RTSCTS,
+	}, {
+		.init = uart_mxc_port3_init,
+		.exit = uart_mxc_port3_exit,
+		.flags = IMXUART_HAVE_RTSCTS,
+	}, {
+		.init = uart_mxc_port4_init,
+		.exit = uart_mxc_port4_exit,
+		.flags = IMXUART_HAVE_RTSCTS,
+	}, {
+		.init = uart_mxc_port5_init,
+		.exit = uart_mxc_port5_exit,
+		.flags = IMXUART_HAVE_RTSCTS,
+	},
+};
+
+static void __init mx27ads_board_init(void)
+{
+	int i;
+
+	gpio_fec_active();
+
+	for (i = 0; i < 6; i++)
+		imx_init_uart(i, &uart_pdata[i]);
+
+	platform_add_devices(platform_devices, ARRAY_SIZE(platform_devices));
+}
+
+static void __init mx27ads_timer_init(void)
+{
+	unsigned long fref = 26000000;
+
+	if ((__raw_readw(PBC_VERSION_REG) & CKIH_27MHZ_BIT_SET) == 0)
+		fref = 27000000;
+
+	mxc_clocks_init(fref);
+	mxc_timer_init("gpt_clk.0");
+}
+
+struct sys_timer mx27ads_timer = {
+	.init	= mx27ads_timer_init,
+};
+
+static struct map_desc mx27ads_io_desc[] __initdata = {
+	{
+		.virtual = PBC_BASE_ADDRESS,
+		.pfn = __phys_to_pfn(CS4_BASE_ADDR),
+		.length = SZ_1M,
+		.type = MT_DEVICE,
+	},
+};
+
+void __init mx27ads_map_io(void)
+{
+	mxc_map_io();
+	iotable_init(mx27ads_io_desc, ARRAY_SIZE(mx27ads_io_desc));
+}
+
+MACHINE_START(MX27ADS, "Freescale i.MX27ADS")
+	/* maintainer: Freescale Semiconductor, Inc. */
+	.phys_io        = AIPI_BASE_ADDR,
+	.io_pg_offst    = ((AIPI_BASE_ADDR_VIRT) >> 18) & 0xfffc,
+	.boot_params    = PHYS_OFFSET + 0x100,
+	.map_io         = mx27ads_map_io,
+	.init_irq       = mxc_init_irq,
+	.init_machine   = mx27ads_board_init,
+	.timer          = &mx27ads_timer,
+MACHINE_END
+
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx2/pcm038.c ipipe-2.6.26-mxc/arch/arm/mach-mx2/pcm038.c
--- adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx2/pcm038.c	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/arch/arm/mach-mx2/pcm038.c	2008-10-19 15:15:34.000000000 +0200
@@ -0,0 +1,204 @@
+/*
+ * Copyright 2007 Robert Schwebel <r.schwebel@pengutronix.de>, Pengutronix
+ * Copyright (C) 2008 Juergen Beisert (kernel@pengutronix.de)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/mtd/physmap.h>
+#include <asm/mach/arch.h>
+#include <asm/mach-types.h>
+#include <asm/arch/common.h>
+#include <asm/hardware.h>
+#include <asm/arch/iomux-mx1-mx2.h>
+#include <asm/mach/time.h>
+#include <asm/arch/imx-uart.h>
+#include <asm/arch/board-pcm038.h>
+
+/*
+ * Phytec's phyCORE-i.MX27 comes with 32MiB flash,
+ * 16 bit width
+ */
+static struct physmap_flash_data pcm038_flash_data = {
+	.width = 2,
+};
+
+static struct resource pcm038_flash_resource = {
+	.start = 0xc0000000,
+	.end   = 0xc1ffffff,
+	.flags = IORESOURCE_MEM,
+};
+
+static struct platform_device pcm038_nor_mtd_device = {
+	.name = "physmap-flash",
+	.id = 0,
+	.dev = {
+		.platform_data = &pcm038_flash_data,
+	},
+	.num_resources = 1,
+	.resource = &pcm038_flash_resource,
+};
+
+static int mxc_uart0_pins[] = {
+	PE12_PF_UART1_TXD,
+	PE13_PF_UART1_RXD,
+	PE14_PF_UART1_CTS,
+	PE15_PF_UART1_RTS
+};
+
+static int uart_mxc_port0_init(struct platform_device *pdev)
+{
+	return mxc_gpio_setup_multiple_pins(mxc_uart0_pins,
+			ARRAY_SIZE(mxc_uart0_pins),
+			MXC_GPIO_ALLOC_MODE_NORMAL, "UART0");
+}
+
+static int uart_mxc_port0_exit(struct platform_device *pdev)
+{
+	return mxc_gpio_setup_multiple_pins(mxc_uart0_pins,
+			ARRAY_SIZE(mxc_uart0_pins),
+			MXC_GPIO_ALLOC_MODE_RELEASE, "UART0");
+}
+
+static int mxc_uart1_pins[] = {
+	PE3_PF_UART2_CTS,
+	PE4_PF_UART2_RTS,
+	PE6_PF_UART2_TXD,
+	PE7_PF_UART2_RXD
+};
+
+static int uart_mxc_port1_init(struct platform_device *pdev)
+{
+	return mxc_gpio_setup_multiple_pins(mxc_uart1_pins,
+			ARRAY_SIZE(mxc_uart1_pins),
+			MXC_GPIO_ALLOC_MODE_NORMAL, "UART1");
+}
+
+static int uart_mxc_port1_exit(struct platform_device *pdev)
+{
+	return mxc_gpio_setup_multiple_pins(mxc_uart1_pins,
+			ARRAY_SIZE(mxc_uart1_pins),
+			MXC_GPIO_ALLOC_MODE_RELEASE, "UART1");
+}
+
+static int mxc_uart2_pins[] = { PE10_PF_UART3_CTS,
+				PE9_PF_UART3_RXD,
+				PE10_PF_UART3_CTS,
+				PE9_PF_UART3_RXD };
+
+static int uart_mxc_port2_init(struct platform_device *pdev)
+{
+	return mxc_gpio_setup_multiple_pins(mxc_uart2_pins,
+			ARRAY_SIZE(mxc_uart2_pins),
+			MXC_GPIO_ALLOC_MODE_NORMAL, "UART2");
+}
+
+static int uart_mxc_port2_exit(struct platform_device *pdev)
+{
+	return mxc_gpio_setup_multiple_pins(mxc_uart2_pins,
+			ARRAY_SIZE(mxc_uart2_pins),
+			MXC_GPIO_ALLOC_MODE_RELEASE, "UART2");
+}
+
+static struct imxuart_platform_data uart_pdata[] = {
+	{
+		.init = uart_mxc_port0_init,
+		.exit = uart_mxc_port0_exit,
+		.flags = IMXUART_HAVE_RTSCTS,
+	}, {
+		.init = uart_mxc_port1_init,
+		.exit = uart_mxc_port1_exit,
+		.flags = IMXUART_HAVE_RTSCTS,
+	}, {
+		.init = uart_mxc_port2_init,
+		.exit = uart_mxc_port2_exit,
+		.flags = IMXUART_HAVE_RTSCTS,
+	},
+};
+
+static int mxc_fec_pins[] = {
+	PD0_AIN_FEC_TXD0,
+	PD1_AIN_FEC_TXD1,
+	PD2_AIN_FEC_TXD2,
+	PD3_AIN_FEC_TXD3,
+	PD4_AOUT_FEC_RX_ER,
+	PD5_AOUT_FEC_RXD1,
+	PD6_AOUT_FEC_RXD2,
+	PD7_AOUT_FEC_RXD3,
+	PD8_AF_FEC_MDIO,
+	PD9_AIN_FEC_MDC,
+	PD10_AOUT_FEC_CRS,
+	PD11_AOUT_FEC_TX_CLK,
+	PD12_AOUT_FEC_RXD0,
+	PD13_AOUT_FEC_RX_DV,
+	PD14_AOUT_FEC_CLR,
+	PD15_AOUT_FEC_COL,
+	PD16_AIN_FEC_TX_ER,
+	PF23_AIN_FEC_TX_EN
+};
+
+static void gpio_fec_active(void)
+{
+	mxc_gpio_setup_multiple_pins(mxc_fec_pins,
+			ARRAY_SIZE(mxc_fec_pins),
+			MXC_GPIO_ALLOC_MODE_NORMAL, "FEC");
+}
+
+static void gpio_fec_inactive(void)
+{
+	mxc_gpio_setup_multiple_pins(mxc_fec_pins,
+			ARRAY_SIZE(mxc_fec_pins),
+			MXC_GPIO_ALLOC_MODE_RELEASE, "FEC");
+}
+
+static struct platform_device *platform_devices[] __initdata = {
+	&pcm038_nor_mtd_device,
+};
+
+static void __init pcm038_init(void)
+{
+	int i;
+	gpio_fec_active();
+
+	for (i = 0; i < 3; i++)
+		imx_init_uart(i, &uart_pdata[i]);
+
+	platform_add_devices(platform_devices, ARRAY_SIZE(platform_devices));
+
+#ifdef CONFIG_MACH_PCM970_BASEBOARD
+	pcm970_baseboard_init();
+#endif
+}
+
+static void __init pcm038_timer_init(void)
+{
+	mxc_clocks_init(26000000);
+	mxc_timer_init("gpt_clk.0");
+}
+
+struct sys_timer pcm038_timer = {
+	.init = pcm038_timer_init,
+};
+
+MACHINE_START(PCM038, "phyCORE-i.MX27")
+	.phys_io        = AIPI_BASE_ADDR,
+	.io_pg_offst    = ((AIPI_BASE_ADDR_VIRT) >> 18) & 0xfffc,
+	.boot_params    = PHYS_OFFSET + 0x100,
+	.map_io         = mxc_map_io,
+	.init_irq       = mxc_init_irq,
+	.init_machine   = pcm038_init,
+	.timer          = &pcm038_timer,
+MACHINE_END
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx2/pcm970-baseboard.c ipipe-2.6.26-mxc/arch/arm/mach-mx2/pcm970-baseboard.c
--- adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx2/pcm970-baseboard.c	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/arch/arm/mach-mx2/pcm970-baseboard.c	2008-10-19 15:15:34.000000000 +0200
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2008 Juergen Beisert (kernel@pengutronix.de)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ */
+
+#include <linux/platform_device.h>
+#include <asm/hardware.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+
+/*
+ * system init for baseboard usage. Will be called by pcm038 init.
+ *
+ * Add platform devices present on this baseboard and init
+ * them from CPU side as far as required to use them later on
+ */
+void __init pcm970_baseboard_init(void)
+{
+}
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx2/serial.c ipipe-2.6.26-mxc/arch/arm/mach-mx2/serial.c
--- adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx2/serial.c	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/arch/arm/mach-mx2/serial.c	2008-10-19 15:15:34.000000000 +0200
@@ -0,0 +1,177 @@
+/*
+ * Copyright 2006-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/serial.h>
+#include <asm/hardware.h>
+#include <asm/arch/imx-uart.h>
+
+static struct resource uart0[] = {
+	{
+		.start = UART1_BASE_ADDR,
+		.end = UART1_BASE_ADDR + 0x0B5,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = MXC_INT_UART1,
+		.end = MXC_INT_UART1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mxc_uart_device0 = {
+	.name = "imx-uart",
+	.id = 0,
+	.resource = uart0,
+	.num_resources = ARRAY_SIZE(uart0),
+};
+
+static struct resource uart1[] = {
+	{
+		.start = UART2_BASE_ADDR,
+		.end = UART2_BASE_ADDR + 0x0B5,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = MXC_INT_UART2,
+		.end = MXC_INT_UART2,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mxc_uart_device1 = {
+	.name = "imx-uart",
+	.id = 1,
+	.resource = uart1,
+	.num_resources = ARRAY_SIZE(uart1),
+};
+
+static struct resource uart2[] = {
+	{
+		.start = UART3_BASE_ADDR,
+		.end = UART3_BASE_ADDR + 0x0B5,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = MXC_INT_UART3,
+		.end = MXC_INT_UART3,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mxc_uart_device2 = {
+	.name = "imx-uart",
+	.id = 2,
+	.resource = uart2,
+	.num_resources = ARRAY_SIZE(uart2),
+};
+
+static struct resource uart3[] = {
+	{
+		.start = UART4_BASE_ADDR,
+		.end = UART4_BASE_ADDR + 0x0B5,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = MXC_INT_UART4,
+		.end = MXC_INT_UART4,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mxc_uart_device3 = {
+	.name = "imx-uart",
+	.id = 3,
+	.resource = uart3,
+	.num_resources = ARRAY_SIZE(uart3),
+};
+
+static struct resource uart4[] = {
+	{
+		.start = UART5_BASE_ADDR,
+		.end = UART5_BASE_ADDR + 0x0B5,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = MXC_INT_UART5,
+		.end = MXC_INT_UART5,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mxc_uart_device4 = {
+	.name = "imx-uart",
+	.id = 4,
+	.resource = uart4,
+	.num_resources = ARRAY_SIZE(uart4),
+};
+
+static struct resource uart5[] = {
+	{
+		.start = UART6_BASE_ADDR,
+		.end = UART6_BASE_ADDR + 0x0B5,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = MXC_INT_UART6,
+		.end = MXC_INT_UART6,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mxc_uart_device5 = {
+	.name = "imx-uart",
+	.id = 5,
+	.resource = uart5,
+	.num_resources = ARRAY_SIZE(uart5),
+};
+
+/*
+ * Register only those UARTs that physically exists
+ */
+int __init imx_init_uart(int uart_no, struct imxuart_platform_data *pdata)
+{
+	switch (uart_no) {
+	case 0:
+		mxc_uart_device0.dev.platform_data = pdata;
+		platform_device_register(&mxc_uart_device0);
+		break;
+	case 1:
+		mxc_uart_device1.dev.platform_data = pdata;
+		platform_device_register(&mxc_uart_device1);
+		break;
+#ifndef CONFIG_MXC_IRDA
+	case 2:
+		mxc_uart_device2.dev.platform_data = pdata;
+		platform_device_register(&mxc_uart_device2);
+		break;
+#endif
+	case 3:
+		mxc_uart_device3.dev.platform_data = pdata;
+		platform_device_register(&mxc_uart_device3);
+		break;
+	case 4:
+		mxc_uart_device4.dev.platform_data = pdata;
+		platform_device_register(&mxc_uart_device4);
+		break;
+	case 5:
+		mxc_uart_device5.dev.platform_data = pdata;
+		platform_device_register(&mxc_uart_device5);
+		break;
+	default:
+		return -ENODEV;
+	}
+
+	return 0;
+}
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx2/system.c ipipe-2.6.26-mxc/arch/arm/mach-mx2/system.c
--- adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx2/system.c	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/arch/arm/mach-mx2/system.c	2008-10-19 15:15:34.000000000 +0200
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 1999 ARM Limited
+ * Copyright (C) 2000 Deep Blue Solutions Ltd
+ * Copyright 2006-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+
+#include <asm/arch/hardware.h>
+#include <asm/proc-fns.h>
+#include <asm/system.h>
+
+/*
+ * Put the CPU into idle mode. It is called by default_idle()
+ * in process.c file.
+ */
+void arch_idle(void)
+{
+	/*
+	 * This should do all the clock switching
+	 * and wait for interrupt tricks.
+	 */
+	cpu_do_idle();
+}
+
+#define WDOG_WCR_REG                    IO_ADDRESS(WDOG_BASE_ADDR)
+#define WDOG_WCR_SRS                    (1 << 4)
+
+/*
+ * Reset the system. It is called by machine_restart().
+ */
+void arch_reset(char mode)
+{
+	struct clk *clk;
+
+	clk = clk_get(NULL, "wdog_clk");
+	if (!clk) {
+		printk(KERN_ERR"Cannot activate the watchdog. Giving up\n");
+		return;
+	}
+
+	clk_enable(clk);
+
+	/* Assert SRS signal */
+	__raw_writew(__raw_readw(WDOG_WCR_REG) & ~WDOG_WCR_SRS, WDOG_WCR_REG);
+}
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx3/clock.c ipipe-2.6.26-mxc/arch/arm/mach-mx3/clock.c
--- adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx3/clock.c	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/arch/arm/mach-mx3/clock.c	2008-10-19 15:15:34.000000000 +0200
@@ -0,0 +1,1147 @@
+/*
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2008 by Sascha Hauer <kernel@pengutronix.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <asm/arch/clock.h>
+#include <asm/div64.h>
+
+#include "crm_regs.h"
+
+#define PRE_DIV_MIN_FREQ    10000000 /* Minimum Frequency after Predivider */
+
+static void __calc_pre_post_dividers(u32 div, u32 *pre, u32 *post)
+{
+	u32 min_pre, temp_pre, old_err, err;
+
+	if (div >= 512) {
+		*pre = 8;
+		*post = 64;
+	} else if (div >= 64) {
+		min_pre = (div - 1) / 64 + 1;
+		old_err = 8;
+		for (temp_pre = 8; temp_pre >= min_pre; temp_pre--) {
+			err = div % temp_pre;
+			if (err == 0) {
+				*pre = temp_pre;
+				break;
+			}
+			err = temp_pre - err;
+			if (err < old_err) {
+				old_err = err;
+				*pre = temp_pre;
+			}
+		}
+		*post = (div + *pre - 1) / *pre;
+	} else if (div <= 8) {
+		*pre = div;
+		*post = 1;
+	} else {
+		*pre = 1;
+		*post = div;
+	}
+}
+
+static struct clk mcu_pll_clk;
+static struct clk mcu_main_clk;
+static struct clk usb_pll_clk;
+static struct clk serial_pll_clk;
+static struct clk ipg_clk;
+static struct clk ckih_clk;
+static struct clk ahb_clk;
+
+static int _clk_enable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(clk->enable_reg);
+	reg |= 3 << clk->enable_shift;
+	__raw_writel(reg, clk->enable_reg);
+
+	return 0;
+}
+
+static void _clk_disable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(clk->enable_reg);
+	reg &= ~(3 << clk->enable_shift);
+	__raw_writel(reg, clk->enable_reg);
+}
+
+static void _clk_emi_disable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(clk->enable_reg);
+	reg &= ~(3 << clk->enable_shift);
+	reg |= (1 << clk->enable_shift);
+	__raw_writel(reg, clk->enable_reg);
+}
+
+static int _clk_pll_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	signed long pd = 1;	/* Pre-divider */
+	signed long mfi;	/* Multiplication Factor (Integer part) */
+	signed long mfn;	/* Multiplication Factor (Integer part) */
+	signed long mfd;	/* Multiplication Factor (Denominator Part) */
+	signed long tmp;
+	u32 ref_freq = clk_get_rate(clk->parent);
+
+	while (((ref_freq / pd) * 10) > rate)
+		pd++;
+
+	if ((ref_freq / pd) < PRE_DIV_MIN_FREQ)
+		return -EINVAL;
+
+	/* the ref_freq/2 in the following is to round up */
+	mfi = (((rate / 2) * pd) + (ref_freq / 2)) / ref_freq;
+	if (mfi < 5 || mfi > 15)
+		return -EINVAL;
+
+	/* pick a mfd value that will work
+	 * then solve for mfn */
+	mfd = ref_freq / 50000;
+
+	/*
+	 *          pll_freq * pd * mfd
+	 *   mfn = --------------------  -  (mfi * mfd)
+	 *           2 * ref_freq
+	 */
+	/* the tmp/2 is for rounding */
+	tmp = ref_freq / 10000;
+	mfn =
+	    ((((((rate / 2) + (tmp / 2)) / tmp) * pd) * mfd) / 10000) -
+	    (mfi * mfd);
+
+	mfn = mfn & 0x3ff;
+	pd--;
+	mfd--;
+
+	/* Change the Pll value */
+	reg = (mfi << MXC_CCM_PCTL_MFI_OFFSET) |
+	    (mfn << MXC_CCM_PCTL_MFN_OFFSET) |
+	    (mfd << MXC_CCM_PCTL_MFD_OFFSET) | (pd << MXC_CCM_PCTL_PD_OFFSET);
+
+	if (clk == &mcu_pll_clk)
+		__raw_writel(reg, MXC_CCM_MPCTL);
+	else if (clk == &usb_pll_clk)
+		__raw_writel(reg, MXC_CCM_UPCTL);
+	else if (clk == &serial_pll_clk)
+		__raw_writel(reg, MXC_CCM_SRPCTL);
+
+	return 0;
+}
+
+static unsigned long _clk_pll_get_rate(struct clk *clk)
+{
+	long mfi, mfn, mfd, pdf, ref_clk, mfn_abs;
+	unsigned long reg, ccmr;
+	s64 temp;
+	unsigned int prcs;
+
+	ccmr = __raw_readl(MXC_CCM_CCMR);
+	prcs = (ccmr & MXC_CCM_CCMR_PRCS_MASK) >> MXC_CCM_CCMR_PRCS_OFFSET;
+	if (prcs == 0x1)
+		ref_clk = CKIL_CLK_FREQ * 1024;
+	else
+		ref_clk = clk_get_rate(&ckih_clk);
+
+	if (clk == &mcu_pll_clk) {
+		if ((ccmr & MXC_CCM_CCMR_MPE) == 0)
+			return ref_clk;
+		if ((ccmr & MXC_CCM_CCMR_MDS) != 0)
+			return ref_clk;
+		reg = __raw_readl(MXC_CCM_MPCTL);
+	} else if (clk == &usb_pll_clk)
+		reg = __raw_readl(MXC_CCM_UPCTL);
+	else if (clk == &serial_pll_clk)
+		reg = __raw_readl(MXC_CCM_SRPCTL);
+	else {
+		BUG();
+		return 0;
+	}
+
+	pdf = (reg & MXC_CCM_PCTL_PD_MASK) >> MXC_CCM_PCTL_PD_OFFSET;
+	mfd = (reg & MXC_CCM_PCTL_MFD_MASK) >> MXC_CCM_PCTL_MFD_OFFSET;
+	mfi = (reg & MXC_CCM_PCTL_MFI_MASK) >> MXC_CCM_PCTL_MFI_OFFSET;
+	mfi = (mfi <= 5) ? 5 : mfi;
+	mfn = mfn_abs = reg & MXC_CCM_PCTL_MFN_MASK;
+
+	if (mfn >= 0x200) {
+		mfn |= 0xFFFFFE00;
+		mfn_abs = -mfn;
+	}
+
+	ref_clk *= 2;
+	ref_clk /= pdf + 1;
+
+	temp = (u64) ref_clk * mfn_abs;
+	do_div(temp, mfd + 1);
+	if (mfn < 0)
+		temp = -temp;
+	temp = (ref_clk * mfi) + temp;
+
+	return temp;
+}
+
+static int _clk_usb_pll_enable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CCMR);
+	reg |= MXC_CCM_CCMR_UPE;
+	__raw_writel(reg, MXC_CCM_CCMR);
+
+	/* No lock bit on MX31, so using max time from spec */
+	udelay(80);
+
+	return 0;
+}
+
+static void _clk_usb_pll_disable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CCMR);
+	reg &= ~MXC_CCM_CCMR_UPE;
+	__raw_writel(reg, MXC_CCM_CCMR);
+}
+
+static int _clk_serial_pll_enable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CCMR);
+	reg |= MXC_CCM_CCMR_SPE;
+	__raw_writel(reg, MXC_CCM_CCMR);
+
+	/* No lock bit on MX31, so using max time from spec */
+	udelay(80);
+
+	return 0;
+}
+
+static void _clk_serial_pll_disable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CCMR);
+	reg &= ~MXC_CCM_CCMR_SPE;
+	__raw_writel(reg, MXC_CCM_CCMR);
+}
+
+#define PDR0(mask, off) ((__raw_readl(MXC_CCM_PDR0) & mask) >> off)
+#define PDR1(mask, off) ((__raw_readl(MXC_CCM_PDR1) & mask) >> off)
+#define PDR2(mask, off) ((__raw_readl(MXC_CCM_PDR2) & mask) >> off)
+
+static unsigned long _clk_mcu_main_get_rate(struct clk *clk)
+{
+	u32 pmcr0 = __raw_readl(MXC_CCM_PMCR0);
+
+	if ((pmcr0 & MXC_CCM_PMCR0_DFSUP1) == MXC_CCM_PMCR0_DFSUP1_SPLL)
+		return clk_get_rate(&serial_pll_clk);
+	else
+		return clk_get_rate(&mcu_pll_clk);
+}
+
+static unsigned long _clk_hclk_get_rate(struct clk *clk)
+{
+	unsigned long max_pdf;
+
+	max_pdf = PDR0(MXC_CCM_PDR0_MAX_PODF_MASK,
+		       MXC_CCM_PDR0_MAX_PODF_OFFSET);
+	return clk_get_rate(clk->parent) / (max_pdf + 1);
+}
+
+static unsigned long _clk_ipg_get_rate(struct clk *clk)
+{
+	unsigned long ipg_pdf;
+
+	ipg_pdf = PDR0(MXC_CCM_PDR0_IPG_PODF_MASK,
+		       MXC_CCM_PDR0_IPG_PODF_OFFSET);
+	return clk_get_rate(clk->parent) / (ipg_pdf + 1);
+}
+
+static unsigned long _clk_nfc_get_rate(struct clk *clk)
+{
+	unsigned long nfc_pdf;
+
+	nfc_pdf = PDR0(MXC_CCM_PDR0_NFC_PODF_MASK,
+		       MXC_CCM_PDR0_NFC_PODF_OFFSET);
+	return clk_get_rate(clk->parent) / (nfc_pdf + 1);
+}
+
+static unsigned long _clk_hsp_get_rate(struct clk *clk)
+{
+	unsigned long hsp_pdf;
+
+	hsp_pdf = PDR0(MXC_CCM_PDR0_HSP_PODF_MASK,
+		       MXC_CCM_PDR0_HSP_PODF_OFFSET);
+	return clk_get_rate(clk->parent) / (hsp_pdf + 1);
+}
+
+static unsigned long _clk_usb_get_rate(struct clk *clk)
+{
+	unsigned long usb_pdf, usb_prepdf;
+
+	usb_pdf = PDR1(MXC_CCM_PDR1_USB_PODF_MASK,
+		       MXC_CCM_PDR1_USB_PODF_OFFSET);
+	usb_prepdf = PDR1(MXC_CCM_PDR1_USB_PRDF_MASK,
+			  MXC_CCM_PDR1_USB_PRDF_OFFSET);
+	return clk_get_rate(clk->parent) / (usb_prepdf + 1) / (usb_pdf + 1);
+}
+
+static unsigned long _clk_csi_get_rate(struct clk *clk)
+{
+	u32 reg, pre, post;
+
+	reg = __raw_readl(MXC_CCM_PDR0);
+	pre = (reg & MXC_CCM_PDR0_CSI_PRDF_MASK) >>
+	    MXC_CCM_PDR0_CSI_PRDF_OFFSET;
+	pre++;
+	post = (reg & MXC_CCM_PDR0_CSI_PODF_MASK) >>
+	    MXC_CCM_PDR0_CSI_PODF_OFFSET;
+	post++;
+	return clk_get_rate(clk->parent) / (pre * post);
+}
+
+static unsigned long _clk_csi_round_rate(struct clk *clk, unsigned long rate)
+{
+	u32 pre, post, parent = clk_get_rate(clk->parent);
+	u32 div = parent / rate;
+
+	if (parent % rate)
+		div++;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	return parent / (pre * post);
+}
+
+static int _clk_csi_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div, pre, post, parent = clk_get_rate(clk->parent);
+
+	div = parent / rate;
+
+	if ((parent / div) != rate)
+		return -EINVAL;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	/* Set CSI clock divider */
+	reg = __raw_readl(MXC_CCM_PDR0) &
+	    ~(MXC_CCM_PDR0_CSI_PODF_MASK | MXC_CCM_PDR0_CSI_PRDF_MASK);
+	reg |= (post - 1) << MXC_CCM_PDR0_CSI_PODF_OFFSET;
+	reg |= (pre - 1) << MXC_CCM_PDR0_CSI_PRDF_OFFSET;
+	__raw_writel(reg, MXC_CCM_PDR0);
+
+	return 0;
+}
+
+static unsigned long _clk_per_get_rate(struct clk *clk)
+{
+	unsigned long per_pdf;
+
+	per_pdf = PDR0(MXC_CCM_PDR0_PER_PODF_MASK,
+		       MXC_CCM_PDR0_PER_PODF_OFFSET);
+	return clk_get_rate(clk->parent) / (per_pdf + 1);
+}
+
+static unsigned long _clk_ssi1_get_rate(struct clk *clk)
+{
+	unsigned long ssi1_pdf, ssi1_prepdf;
+
+	ssi1_pdf = PDR1(MXC_CCM_PDR1_SSI1_PODF_MASK,
+			MXC_CCM_PDR1_SSI1_PODF_OFFSET);
+	ssi1_prepdf = PDR1(MXC_CCM_PDR1_SSI1_PRE_PODF_MASK,
+			   MXC_CCM_PDR1_SSI1_PRE_PODF_OFFSET);
+	return clk_get_rate(clk->parent) / (ssi1_prepdf + 1) / (ssi1_pdf + 1);
+}
+
+static unsigned long _clk_ssi2_get_rate(struct clk *clk)
+{
+	unsigned long ssi2_pdf, ssi2_prepdf;
+
+	ssi2_pdf = PDR1(MXC_CCM_PDR1_SSI2_PODF_MASK,
+			MXC_CCM_PDR1_SSI2_PODF_OFFSET);
+	ssi2_prepdf = PDR1(MXC_CCM_PDR1_SSI2_PRE_PODF_MASK,
+			   MXC_CCM_PDR1_SSI2_PRE_PODF_OFFSET);
+	return clk_get_rate(clk->parent) / (ssi2_prepdf + 1) / (ssi2_pdf + 1);
+}
+
+static unsigned long _clk_firi_get_rate(struct clk *clk)
+{
+	unsigned long firi_pdf, firi_prepdf;
+
+	firi_pdf = PDR1(MXC_CCM_PDR1_FIRI_PODF_MASK,
+			MXC_CCM_PDR1_FIRI_PODF_OFFSET);
+	firi_prepdf = PDR1(MXC_CCM_PDR1_FIRI_PRE_PODF_MASK,
+			   MXC_CCM_PDR1_FIRI_PRE_PODF_OFFSET);
+	return clk_get_rate(clk->parent) / (firi_prepdf + 1) / (firi_pdf + 1);
+}
+
+static unsigned long _clk_firi_round_rate(struct clk *clk, unsigned long rate)
+{
+	u32 pre, post;
+	u32 parent = clk_get_rate(clk->parent);
+	u32 div = parent / rate;
+
+	if (parent % rate)
+		div++;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	return parent / (pre * post);
+
+}
+
+static int _clk_firi_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div, pre, post, parent = clk_get_rate(clk->parent);
+
+	div = parent / rate;
+
+	if ((parent / div) != rate)
+		return -EINVAL;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	/* Set FIRI clock divider */
+	reg = __raw_readl(MXC_CCM_PDR1) &
+	    ~(MXC_CCM_PDR1_FIRI_PODF_MASK | MXC_CCM_PDR1_FIRI_PRE_PODF_MASK);
+	reg |= (pre - 1) << MXC_CCM_PDR1_FIRI_PRE_PODF_OFFSET;
+	reg |= (post - 1) << MXC_CCM_PDR1_FIRI_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_PDR1);
+
+	return 0;
+}
+
+static unsigned long _clk_mbx_get_rate(struct clk *clk)
+{
+	return clk_get_rate(clk->parent) / 2;
+}
+
+static unsigned long _clk_mstick1_get_rate(struct clk *clk)
+{
+	unsigned long msti_pdf;
+
+	msti_pdf = PDR2(MXC_CCM_PDR2_MST1_PDF_MASK,
+			MXC_CCM_PDR2_MST1_PDF_OFFSET);
+	return clk_get_rate(clk->parent) / (msti_pdf + 1);
+}
+
+static unsigned long _clk_mstick2_get_rate(struct clk *clk)
+{
+	unsigned long msti_pdf;
+
+	msti_pdf = PDR2(MXC_CCM_PDR2_MST2_PDF_MASK,
+			MXC_CCM_PDR2_MST2_PDF_OFFSET);
+	return clk_get_rate(clk->parent) / (msti_pdf + 1);
+}
+
+static unsigned long ckih_rate;
+
+static unsigned long clk_ckih_get_rate(struct clk *clk)
+{
+	return ckih_rate;
+}
+
+static struct clk ckih_clk = {
+	.name = "ckih",
+	.get_rate = clk_ckih_get_rate,
+};
+
+static unsigned long clk_ckil_get_rate(struct clk *clk)
+{
+	return CKIL_CLK_FREQ;
+}
+
+static struct clk ckil_clk = {
+	.name = "ckil",
+	.get_rate = clk_ckil_get_rate,
+};
+
+static struct clk mcu_pll_clk = {
+	.name = "mcu_pll",
+	.parent = &ckih_clk,
+	.set_rate = _clk_pll_set_rate,
+	.get_rate = _clk_pll_get_rate,
+};
+
+static struct clk mcu_main_clk = {
+	.name = "mcu_main_clk",
+	.parent = &mcu_pll_clk,
+	.get_rate = _clk_mcu_main_get_rate,
+};
+
+static struct clk serial_pll_clk = {
+	.name = "serial_pll",
+	.parent = &ckih_clk,
+	.set_rate = _clk_pll_set_rate,
+	.get_rate = _clk_pll_get_rate,
+	.enable = _clk_serial_pll_enable,
+	.disable = _clk_serial_pll_disable,
+};
+
+static struct clk usb_pll_clk = {
+	.name = "usb_pll",
+	.parent = &ckih_clk,
+	.set_rate = _clk_pll_set_rate,
+	.get_rate = _clk_pll_get_rate,
+	.enable = _clk_usb_pll_enable,
+	.disable = _clk_usb_pll_disable,
+};
+
+static struct clk ahb_clk = {
+	.name = "ahb_clk",
+	.parent = &mcu_main_clk,
+	.get_rate = _clk_hclk_get_rate,
+};
+
+static struct clk per_clk = {
+	.name = "per_clk",
+	.parent = &usb_pll_clk,
+	.get_rate = _clk_per_get_rate,
+};
+
+static struct clk perclk_clk = {
+	.name = "perclk_clk",
+	.parent = &ipg_clk,
+};
+
+static struct clk cspi_clk[] = {
+	{
+	 .name = "cspi_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR2,
+	 .enable_shift = MXC_CCM_CGR2_CSPI1_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "cspi_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR2,
+	 .enable_shift = MXC_CCM_CGR2_CSPI2_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "cspi_clk",
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR0,
+	 .enable_shift = MXC_CCM_CGR0_CSPI3_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk ipg_clk = {
+	.name = "ipg_clk",
+	.parent = &ahb_clk,
+	.get_rate = _clk_ipg_get_rate,
+};
+
+static struct clk emi_clk = {
+	.name = "emi_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR2,
+	.enable_shift = MXC_CCM_CGR2_EMI_OFFSET,
+	.disable = _clk_emi_disable,
+};
+
+static struct clk gpt_clk = {
+	.name = "gpt_clk",
+	.parent = &perclk_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR0,
+	.enable_shift = MXC_CCM_CGR0_GPT_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk pwm_clk = {
+	.name = "pwm_clk",
+	.parent = &perclk_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR0,
+	.enable_shift = MXC_CCM_CGR1_PWM_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk epit_clk[] = {
+	{
+	 .name = "epit_clk",
+	 .id = 0,
+	 .parent = &perclk_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR0,
+	 .enable_shift = MXC_CCM_CGR0_EPIT1_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "epit_clk",
+	 .id = 1,
+	 .parent = &perclk_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR0,
+	 .enable_shift = MXC_CCM_CGR0_EPIT2_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk nfc_clk = {
+	.name = "nfc_clk",
+	.parent = &ahb_clk,
+	.get_rate = _clk_nfc_get_rate,
+};
+
+static struct clk scc_clk = {
+	.name = "scc_clk",
+	.parent = &ipg_clk,
+};
+
+static struct clk ipu_clk = {
+	.name = "ipu_clk",
+	.parent = &mcu_main_clk,
+	.get_rate = _clk_hsp_get_rate,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR1,
+	.enable_shift = MXC_CCM_CGR1_IPU_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk kpp_clk = {
+	.name = "kpp_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR1,
+	.enable_shift = MXC_CCM_CGR1_KPP_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk wdog_clk = {
+	.name = "wdog_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR1,
+	.enable_shift = MXC_CCM_CGR1_WDOG_OFFSET,
+	.disable = _clk_disable,
+};
+static struct clk rtc_clk = {
+	.name = "rtc_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR1,
+	.enable_shift = MXC_CCM_CGR1_RTC_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk usb_clk[] = {
+	{
+	 .name = "usb_clk",
+	 .parent = &usb_pll_clk,
+	 .get_rate = _clk_usb_get_rate,},
+	{
+	 .name = "usb_ahb_clk",
+	 .parent = &ahb_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR1,
+	 .enable_shift = MXC_CCM_CGR1_USBOTG_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk csi_clk = {
+	.name = "csi_clk",
+	.parent = &serial_pll_clk,
+	.get_rate = _clk_csi_get_rate,
+	.round_rate = _clk_csi_round_rate,
+	.set_rate = _clk_csi_set_rate,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR1,
+	.enable_shift = MXC_CCM_CGR1_CSI_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk uart_clk[] = {
+	{
+	 .name = "uart_clk",
+	 .id = 0,
+	 .parent = &perclk_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR0,
+	 .enable_shift = MXC_CCM_CGR0_UART1_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "uart_clk",
+	 .id = 1,
+	 .parent = &perclk_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR0,
+	 .enable_shift = MXC_CCM_CGR0_UART2_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "uart_clk",
+	 .id = 2,
+	 .parent = &perclk_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR1,
+	 .enable_shift = MXC_CCM_CGR1_UART3_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "uart_clk",
+	 .id = 3,
+	 .parent = &perclk_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR1,
+	 .enable_shift = MXC_CCM_CGR1_UART4_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "uart_clk",
+	 .id = 4,
+	 .parent = &perclk_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR1,
+	 .enable_shift = MXC_CCM_CGR1_UART5_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk i2c_clk[] = {
+	{
+	 .name = "i2c_clk",
+	 .id = 0,
+	 .parent = &perclk_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR0,
+	 .enable_shift = MXC_CCM_CGR0_I2C1_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "i2c_clk",
+	 .id = 1,
+	 .parent = &perclk_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR0,
+	 .enable_shift = MXC_CCM_CGR0_I2C2_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "i2c_clk",
+	 .id = 2,
+	 .parent = &perclk_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR0,
+	 .enable_shift = MXC_CCM_CGR0_I2C3_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk owire_clk = {
+	.name = "owire_clk",
+	.parent = &perclk_clk,
+	.enable_reg = MXC_CCM_CGR1,
+	.enable_shift = MXC_CCM_CGR1_OWIRE_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+};
+
+static struct clk sdhc_clk[] = {
+	{
+	 .name = "sdhc_clk",
+	 .id = 0,
+	 .parent = &perclk_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR0,
+	 .enable_shift = MXC_CCM_CGR0_SD_MMC1_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "sdhc_clk",
+	 .id = 1,
+	 .parent = &perclk_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR0,
+	 .enable_shift = MXC_CCM_CGR0_SD_MMC2_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk ssi_clk[] = {
+	{
+	 .name = "ssi_clk",
+	 .parent = &serial_pll_clk,
+	 .get_rate = _clk_ssi1_get_rate,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR0,
+	 .enable_shift = MXC_CCM_CGR0_SSI1_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "ssi_clk",
+	 .id = 1,
+	 .parent = &serial_pll_clk,
+	 .get_rate = _clk_ssi2_get_rate,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR2,
+	 .enable_shift = MXC_CCM_CGR2_SSI2_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk firi_clk = {
+	.name = "firi_clk",
+	.parent = &usb_pll_clk,
+	.round_rate = _clk_firi_round_rate,
+	.set_rate = _clk_firi_set_rate,
+	.get_rate = _clk_firi_get_rate,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR2,
+	.enable_shift = MXC_CCM_CGR2_FIRI_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk ata_clk = {
+	.name = "ata_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR0,
+	.enable_shift = MXC_CCM_CGR0_ATA_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk mbx_clk = {
+	.name = "mbx_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR2,
+	.enable_shift = MXC_CCM_CGR2_GACC_OFFSET,
+	.get_rate = _clk_mbx_get_rate,
+};
+
+static struct clk vpu_clk = {
+	.name = "vpu_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR2,
+	.enable_shift = MXC_CCM_CGR2_GACC_OFFSET,
+	.get_rate = _clk_mbx_get_rate,
+};
+
+static struct clk rtic_clk = {
+	.name = "rtic_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR2,
+	.enable_shift = MXC_CCM_CGR2_RTIC_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk rng_clk = {
+	.name = "rng_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR0,
+	.enable_shift = MXC_CCM_CGR0_RNG_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk sdma_clk[] = {
+	{
+	 .name = "sdma_ahb_clk",
+	 .parent = &ahb_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR0,
+	 .enable_shift = MXC_CCM_CGR0_SDMA_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "sdma_ipg_clk",
+	 .parent = &ipg_clk,}
+};
+
+static struct clk mpeg4_clk = {
+	.name = "mpeg4_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR1,
+	.enable_shift = MXC_CCM_CGR1_HANTRO_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk vl2cc_clk = {
+	.name = "vl2cc_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR1,
+	.enable_shift = MXC_CCM_CGR1_HANTRO_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk mstick_clk[] = {
+	{
+	 .name = "mstick_clk",
+	 .id = 0,
+	 .parent = &usb_pll_clk,
+	 .get_rate = _clk_mstick1_get_rate,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR1,
+	 .enable_shift = MXC_CCM_CGR1_MEMSTICK1_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "mstick_clk",
+	 .id = 1,
+	 .parent = &usb_pll_clk,
+	 .get_rate = _clk_mstick2_get_rate,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR1,
+	 .enable_shift = MXC_CCM_CGR1_MEMSTICK2_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk iim_clk = {
+	.name = "iim_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR0,
+	.enable_shift = MXC_CCM_CGR0_IIM_OFFSET,
+	.disable = _clk_disable,
+};
+
+static unsigned long _clk_cko1_round_rate(struct clk *clk, unsigned long rate)
+{
+	u32 div, parent = clk_get_rate(clk->parent);
+
+	div = parent / rate;
+	if (parent % rate)
+		div++;
+
+	if (div > 8)
+		div = 16;
+	else if (div > 4)
+		div = 8;
+	else if (div > 2)
+		div = 4;
+
+	return parent / div;
+}
+
+static int _clk_cko1_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div, parent = clk_get_rate(clk->parent);
+
+	div = parent / rate;
+
+	if (div == 16)
+		div = 4;
+	else if (div == 8)
+		div = 3;
+	else if (div == 4)
+		div = 2;
+	else if (div == 2)
+		div = 1;
+	else if (div == 1)
+		div = 0;
+	else
+		return -EINVAL;
+
+	reg = __raw_readl(MXC_CCM_COSR) & ~MXC_CCM_COSR_CLKOUTDIV_MASK;
+	reg |= div << MXC_CCM_COSR_CLKOUTDIV_OFFSET;
+	__raw_writel(reg, MXC_CCM_COSR);
+
+	return 0;
+}
+
+static unsigned long _clk_cko1_get_rate(struct clk *clk)
+{
+	u32 div;
+
+	div = __raw_readl(MXC_CCM_COSR) & MXC_CCM_COSR_CLKOUTDIV_MASK >>
+	    MXC_CCM_COSR_CLKOUTDIV_OFFSET;
+
+	return clk_get_rate(clk->parent) / (1 << div);
+}
+
+static int _clk_cko1_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_COSR) & ~MXC_CCM_COSR_CLKOSEL_MASK;
+
+	if (parent == &mcu_main_clk)
+		reg |= 0 << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	else if (parent == &ipg_clk)
+		reg |= 1 << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	else if (parent == &usb_pll_clk)
+		reg |= 2 << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	else if (parent == mcu_main_clk.parent)
+		reg |= 3 << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	else if (parent == &ahb_clk)
+		reg |= 5 << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	else if (parent == &serial_pll_clk)
+		reg |= 7 << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	else if (parent == &ckih_clk)
+		reg |= 8 << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	else if (parent == &emi_clk)
+		reg |= 9 << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	else if (parent == &ipu_clk)
+		reg |= 0xA << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	else if (parent == &nfc_clk)
+		reg |= 0xB << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	else if (parent == &uart_clk[0])
+		reg |= 0xC << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	else
+		return -EINVAL;
+
+	__raw_writel(reg, MXC_CCM_COSR);
+
+	return 0;
+}
+
+static int _clk_cko1_enable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_COSR) | MXC_CCM_COSR_CLKOEN;
+	__raw_writel(reg, MXC_CCM_COSR);
+
+	return 0;
+}
+
+static void _clk_cko1_disable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_COSR) & ~MXC_CCM_COSR_CLKOEN;
+	__raw_writel(reg, MXC_CCM_COSR);
+}
+
+static struct clk cko1_clk = {
+	.name = "cko1_clk",
+	.get_rate = _clk_cko1_get_rate,
+	.set_rate = _clk_cko1_set_rate,
+	.round_rate = _clk_cko1_round_rate,
+	.set_parent = _clk_cko1_set_parent,
+	.enable = _clk_cko1_enable,
+	.disable = _clk_cko1_disable,
+};
+
+static struct clk *mxc_clks[] = {
+	&ckih_clk,
+	&ckil_clk,
+	&mcu_pll_clk,
+	&usb_pll_clk,
+	&serial_pll_clk,
+	&mcu_main_clk,
+	&ahb_clk,
+	&per_clk,
+	&perclk_clk,
+	&cko1_clk,
+	&emi_clk,
+	&cspi_clk[0],
+	&cspi_clk[1],
+	&cspi_clk[2],
+	&ipg_clk,
+	&gpt_clk,
+	&pwm_clk,
+	&wdog_clk,
+	&rtc_clk,
+	&epit_clk[0],
+	&epit_clk[1],
+	&nfc_clk,
+	&ipu_clk,
+	&kpp_clk,
+	&usb_clk[0],
+	&usb_clk[1],
+	&csi_clk,
+	&uart_clk[0],
+	&uart_clk[1],
+	&uart_clk[2],
+	&uart_clk[3],
+	&uart_clk[4],
+	&i2c_clk[0],
+	&i2c_clk[1],
+	&i2c_clk[2],
+	&owire_clk,
+	&sdhc_clk[0],
+	&sdhc_clk[1],
+	&ssi_clk[0],
+	&ssi_clk[1],
+	&firi_clk,
+	&ata_clk,
+	&rtic_clk,
+	&rng_clk,
+	&sdma_clk[0],
+	&sdma_clk[1],
+	&mstick_clk[0],
+	&mstick_clk[1],
+	&scc_clk,
+	&iim_clk,
+};
+
+int __init mxc_clocks_init(unsigned long fref)
+{
+	u32 reg;
+	struct clk **clkp;
+
+	ckih_rate = fref;
+
+	for (clkp = mxc_clks; clkp < mxc_clks + ARRAY_SIZE(mxc_clks); clkp++)
+		clk_register(*clkp);
+
+	if (cpu_is_mx31()) {
+		clk_register(&mpeg4_clk);
+		clk_register(&mbx_clk);
+	} else {
+		clk_register(&vpu_clk);
+		clk_register(&vl2cc_clk);
+	}
+
+	/* Turn off all possible clocks */
+	__raw_writel(MXC_CCM_CGR0_GPT_MASK, MXC_CCM_CGR0);
+	__raw_writel(0, MXC_CCM_CGR1);
+
+	__raw_writel(MXC_CCM_CGR2_EMI_MASK |
+		     MXC_CCM_CGR2_IPMUX1_MASK |
+		     MXC_CCM_CGR2_IPMUX2_MASK |
+		     MXC_CCM_CGR2_MXCCLKENSEL_MASK |	/* for MX32 */
+		     MXC_CCM_CGR2_CHIKCAMPEN_MASK |	/* for MX32 */
+		     MXC_CCM_CGR2_OVRVPUBUSY_MASK |	/* for MX32 */
+		     1 << 27 | 1 << 28, /* Bit 27 and 28 are not defined for
+					   MX32, but still required to be set */
+		     MXC_CCM_CGR2);
+
+	clk_disable(&cko1_clk);
+	clk_disable(&usb_pll_clk);
+
+	pr_info("Clock input source is %ld\n", clk_get_rate(&ckih_clk));
+
+	clk_enable(&gpt_clk);
+	clk_enable(&emi_clk);
+	clk_enable(&iim_clk);
+
+	clk_enable(&serial_pll_clk);
+
+	if (mx31_revision() >= CHIP_REV_2_0) {
+		reg = __raw_readl(MXC_CCM_PMCR1);
+		/* No PLL restart on DVFS switch; enable auto EMI handshake */
+		reg |= MXC_CCM_PMCR1_PLLRDIS | MXC_CCM_PMCR1_EMIRQ_EN;
+		__raw_writel(reg, MXC_CCM_PMCR1);
+	}
+
+	return 0;
+}
+
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx3/crm_regs.h ipipe-2.6.26-mxc/arch/arm/mach-mx3/crm_regs.h
--- adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx3/crm_regs.h	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/arch/arm/mach-mx3/crm_regs.h	2008-10-19 15:15:34.000000000 +0200
@@ -0,0 +1,401 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2008 by Sascha Hauer <kernel@pengutronix.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ */
+
+#ifndef __ARCH_ARM_MACH_MX3_CRM_REGS_H__
+#define __ARCH_ARM_MACH_MX3_CRM_REGS_H__
+
+#define CKIH_CLK_FREQ           26000000
+#define CKIH_CLK_FREQ_27MHZ     27000000
+#define CKIL_CLK_FREQ           32768
+
+#define MXC_CCM_BASE		IO_ADDRESS(CCM_BASE_ADDR)
+
+/* Register addresses */
+#define MXC_CCM_CCMR		(MXC_CCM_BASE + 0x00)
+#define MXC_CCM_PDR0		(MXC_CCM_BASE + 0x04)
+#define MXC_CCM_PDR1		(MXC_CCM_BASE + 0x08)
+#define MXC_CCM_RCSR		(MXC_CCM_BASE + 0x0C)
+#define MXC_CCM_MPCTL		(MXC_CCM_BASE + 0x10)
+#define MXC_CCM_UPCTL		(MXC_CCM_BASE + 0x14)
+#define MXC_CCM_SRPCTL		(MXC_CCM_BASE + 0x18)
+#define MXC_CCM_COSR		(MXC_CCM_BASE + 0x1C)
+#define MXC_CCM_CGR0		(MXC_CCM_BASE + 0x20)
+#define MXC_CCM_CGR1		(MXC_CCM_BASE + 0x24)
+#define MXC_CCM_CGR2		(MXC_CCM_BASE + 0x28)
+#define MXC_CCM_WIMR		(MXC_CCM_BASE + 0x2C)
+#define MXC_CCM_LDC		(MXC_CCM_BASE + 0x30)
+#define MXC_CCM_DCVR0		(MXC_CCM_BASE + 0x34)
+#define MXC_CCM_DCVR1		(MXC_CCM_BASE + 0x38)
+#define MXC_CCM_DCVR2		(MXC_CCM_BASE + 0x3C)
+#define MXC_CCM_DCVR3		(MXC_CCM_BASE + 0x40)
+#define MXC_CCM_LTR0		(MXC_CCM_BASE + 0x44)
+#define MXC_CCM_LTR1		(MXC_CCM_BASE + 0x48)
+#define MXC_CCM_LTR2		(MXC_CCM_BASE + 0x4C)
+#define MXC_CCM_LTR3		(MXC_CCM_BASE + 0x50)
+#define MXC_CCM_LTBR0		(MXC_CCM_BASE + 0x54)
+#define MXC_CCM_LTBR1		(MXC_CCM_BASE + 0x58)
+#define MXC_CCM_PMCR0		(MXC_CCM_BASE + 0x5C)
+#define MXC_CCM_PMCR1		(MXC_CCM_BASE + 0x60)
+#define MXC_CCM_PDR2		(MXC_CCM_BASE + 0x64)
+
+/* Register bit definitions */
+#define MXC_CCM_CCMR_WBEN                       (1 << 27)
+#define MXC_CCM_CCMR_CSCS                       (1 << 25)
+#define MXC_CCM_CCMR_PERCS                      (1 << 24)
+#define MXC_CCM_CCMR_SSI1S_OFFSET               18
+#define MXC_CCM_CCMR_SSI1S_MASK                 (0x3 << 18)
+#define MXC_CCM_CCMR_SSI2S_OFFSET               21
+#define MXC_CCM_CCMR_SSI2S_MASK                 (0x3 << 21)
+#define MXC_CCM_CCMR_LPM_OFFSET                 14
+#define MXC_CCM_CCMR_LPM_MASK                   (0x3 << 14)
+#define MXC_CCM_CCMR_FIRS_OFFSET                11
+#define MXC_CCM_CCMR_FIRS_MASK                  (0x3 << 11)
+#define MXC_CCM_CCMR_UPE                        (1 << 9)
+#define MXC_CCM_CCMR_SPE                        (1 << 8)
+#define MXC_CCM_CCMR_MDS                        (1 << 7)
+#define MXC_CCM_CCMR_SBYCS                      (1 << 4)
+#define MXC_CCM_CCMR_MPE                        (1 << 3)
+#define MXC_CCM_CCMR_PRCS_OFFSET                1
+#define MXC_CCM_CCMR_PRCS_MASK                  (0x3 << 1)
+
+#define MXC_CCM_PDR0_CSI_PODF_OFFSET            26
+#define MXC_CCM_PDR0_CSI_PODF_MASK              (0x3F << 26)
+#define MXC_CCM_PDR0_CSI_PRDF_OFFSET            23
+#define MXC_CCM_PDR0_CSI_PRDF_MASK              (0x7 << 23)
+#define MXC_CCM_PDR0_PER_PODF_OFFSET            16
+#define MXC_CCM_PDR0_PER_PODF_MASK              (0x1F << 16)
+#define MXC_CCM_PDR0_HSP_PODF_OFFSET            11
+#define MXC_CCM_PDR0_HSP_PODF_MASK              (0x7 << 11)
+#define MXC_CCM_PDR0_NFC_PODF_OFFSET            8
+#define MXC_CCM_PDR0_NFC_PODF_MASK              (0x7 << 8)
+#define MXC_CCM_PDR0_IPG_PODF_OFFSET            6
+#define MXC_CCM_PDR0_IPG_PODF_MASK              (0x3 << 6)
+#define MXC_CCM_PDR0_MAX_PODF_OFFSET            3
+#define MXC_CCM_PDR0_MAX_PODF_MASK              (0x7 << 3)
+#define MXC_CCM_PDR0_MCU_PODF_OFFSET            0
+#define MXC_CCM_PDR0_MCU_PODF_MASK              0x7
+
+#define MXC_CCM_PDR0_HSP_DIV_1                  (0x0 << 11)
+#define MXC_CCM_PDR0_HSP_DIV_2                  (0x1 << 11)
+#define MXC_CCM_PDR0_HSP_DIV_3                  (0x2 << 11)
+#define MXC_CCM_PDR0_HSP_DIV_4                  (0x3 << 11)
+#define MXC_CCM_PDR0_HSP_DIV_5                  (0x4 << 11)
+#define MXC_CCM_PDR0_HSP_DIV_6                  (0x5 << 11)
+#define MXC_CCM_PDR0_HSP_DIV_7                  (0x6 << 11)
+#define MXC_CCM_PDR0_HSP_DIV_8                  (0x7 << 11)
+
+#define MXC_CCM_PDR0_IPG_DIV_1                  (0x0 << 6)
+#define MXC_CCM_PDR0_IPG_DIV_2                  (0x1 << 6)
+#define MXC_CCM_PDR0_IPG_DIV_3                  (0x2 << 6)
+#define MXC_CCM_PDR0_IPG_DIV_4                  (0x3 << 6)
+
+#define MXC_CCM_PDR0_MAX_DIV_1                  (0x0 << 3)
+#define MXC_CCM_PDR0_MAX_DIV_2                  (0x1 << 3)
+#define MXC_CCM_PDR0_MAX_DIV_3                  (0x2 << 3)
+#define MXC_CCM_PDR0_MAX_DIV_4                  (0x3 << 3)
+#define MXC_CCM_PDR0_MAX_DIV_5                  (0x4 << 3)
+#define MXC_CCM_PDR0_MAX_DIV_6                  (0x5 << 3)
+#define MXC_CCM_PDR0_MAX_DIV_7                  (0x6 << 3)
+#define MXC_CCM_PDR0_MAX_DIV_8                  (0x7 << 3)
+
+#define MXC_CCM_PDR0_NFC_DIV_1                  (0x0 << 8)
+#define MXC_CCM_PDR0_NFC_DIV_2                  (0x1 << 8)
+#define MXC_CCM_PDR0_NFC_DIV_3                  (0x2 << 8)
+#define MXC_CCM_PDR0_NFC_DIV_4                  (0x3 << 8)
+#define MXC_CCM_PDR0_NFC_DIV_5                  (0x4 << 8)
+#define MXC_CCM_PDR0_NFC_DIV_6                  (0x5 << 8)
+#define MXC_CCM_PDR0_NFC_DIV_7                  (0x6 << 8)
+#define MXC_CCM_PDR0_NFC_DIV_8                  (0x7 << 8)
+
+#define MXC_CCM_PDR0_MCU_DIV_1                  0x0
+#define MXC_CCM_PDR0_MCU_DIV_2                  0x1
+#define MXC_CCM_PDR0_MCU_DIV_3                  0x2
+#define MXC_CCM_PDR0_MCU_DIV_4                  0x3
+#define MXC_CCM_PDR0_MCU_DIV_5                  0x4
+#define MXC_CCM_PDR0_MCU_DIV_6                  0x5
+#define MXC_CCM_PDR0_MCU_DIV_7                  0x6
+#define MXC_CCM_PDR0_MCU_DIV_8                  0x7
+
+#define MXC_CCM_PDR1_USB_PRDF_OFFSET            30
+#define MXC_CCM_PDR1_USB_PRDF_MASK              (0x3 << 30)
+#define MXC_CCM_PDR1_USB_PODF_OFFSET            27
+#define MXC_CCM_PDR1_USB_PODF_MASK              (0x7 << 27)
+#define MXC_CCM_PDR1_FIRI_PRE_PODF_OFFSET       24
+#define MXC_CCM_PDR1_FIRI_PRE_PODF_MASK         (0x7 << 24)
+#define MXC_CCM_PDR1_FIRI_PODF_OFFSET           18
+#define MXC_CCM_PDR1_FIRI_PODF_MASK             (0x3F << 18)
+#define MXC_CCM_PDR1_SSI2_PRE_PODF_OFFSET       15
+#define MXC_CCM_PDR1_SSI2_PRE_PODF_MASK         (0x7 << 15)
+#define MXC_CCM_PDR1_SSI2_PODF_OFFSET           9
+#define MXC_CCM_PDR1_SSI2_PODF_MASK             (0x3F << 9)
+#define MXC_CCM_PDR1_SSI1_PRE_PODF_OFFSET       6
+#define MXC_CCM_PDR1_SSI1_PRE_PODF_MASK         (0x7 << 6)
+#define MXC_CCM_PDR1_SSI1_PODF_OFFSET           0
+#define MXC_CCM_PDR1_SSI1_PODF_MASK             0x3F
+
+/* Bit definitions for RCSR */
+#define MXC_CCM_RCSR_NF16B			0x80000000
+
+/* Bit definitions for both MCU, USB and SR PLL control registers */
+#define MXC_CCM_PCTL_BRM                        0x80000000
+#define MXC_CCM_PCTL_PD_OFFSET                  26
+#define MXC_CCM_PCTL_PD_MASK                    (0xF << 26)
+#define MXC_CCM_PCTL_MFD_OFFSET                 16
+#define MXC_CCM_PCTL_MFD_MASK                   (0x3FF << 16)
+#define MXC_CCM_PCTL_MFI_OFFSET                 10
+#define MXC_CCM_PCTL_MFI_MASK                   (0xF << 10)
+#define MXC_CCM_PCTL_MFN_OFFSET                 0
+#define MXC_CCM_PCTL_MFN_MASK                   0x3FF
+
+#define MXC_CCM_CGR0_SD_MMC1_OFFSET             0
+#define MXC_CCM_CGR0_SD_MMC1_MASK               (0x3 << 0)
+#define MXC_CCM_CGR0_SD_MMC2_OFFSET             2
+#define MXC_CCM_CGR0_SD_MMC2_MASK               (0x3 << 2)
+#define MXC_CCM_CGR0_GPT_OFFSET                 4
+#define MXC_CCM_CGR0_GPT_MASK                   (0x3 << 4)
+#define MXC_CCM_CGR0_EPIT1_OFFSET               6
+#define MXC_CCM_CGR0_EPIT1_MASK                 (0x3 << 6)
+#define MXC_CCM_CGR0_EPIT2_OFFSET               8
+#define MXC_CCM_CGR0_EPIT2_MASK                 (0x3 << 8)
+#define MXC_CCM_CGR0_IIM_OFFSET                 10
+#define MXC_CCM_CGR0_IIM_MASK                   (0x3 << 10)
+#define MXC_CCM_CGR0_ATA_OFFSET                 12
+#define MXC_CCM_CGR0_ATA_MASK                   (0x3 << 12)
+#define MXC_CCM_CGR0_SDMA_OFFSET                14
+#define MXC_CCM_CGR0_SDMA_MASK                  (0x3 << 14)
+#define MXC_CCM_CGR0_CSPI3_OFFSET               16
+#define MXC_CCM_CGR0_CSPI3_MASK                 (0x3 << 16)
+#define MXC_CCM_CGR0_RNG_OFFSET                 18
+#define MXC_CCM_CGR0_RNG_MASK                   (0x3 << 18)
+#define MXC_CCM_CGR0_UART1_OFFSET               20
+#define MXC_CCM_CGR0_UART1_MASK                 (0x3 << 20)
+#define MXC_CCM_CGR0_UART2_OFFSET               22
+#define MXC_CCM_CGR0_UART2_MASK                 (0x3 << 22)
+#define MXC_CCM_CGR0_SSI1_OFFSET                24
+#define MXC_CCM_CGR0_SSI1_MASK                  (0x3 << 24)
+#define MXC_CCM_CGR0_I2C1_OFFSET                26
+#define MXC_CCM_CGR0_I2C1_MASK                  (0x3 << 26)
+#define MXC_CCM_CGR0_I2C2_OFFSET                28
+#define MXC_CCM_CGR0_I2C2_MASK                  (0x3 << 28)
+#define MXC_CCM_CGR0_I2C3_OFFSET                30
+#define MXC_CCM_CGR0_I2C3_MASK                  (0x3 << 30)
+
+#define MXC_CCM_CGR1_HANTRO_OFFSET              0
+#define MXC_CCM_CGR1_HANTRO_MASK                (0x3 << 0)
+#define MXC_CCM_CGR1_MEMSTICK1_OFFSET           2
+#define MXC_CCM_CGR1_MEMSTICK1_MASK             (0x3 << 2)
+#define MXC_CCM_CGR1_MEMSTICK2_OFFSET           4
+#define MXC_CCM_CGR1_MEMSTICK2_MASK             (0x3 << 4)
+#define MXC_CCM_CGR1_CSI_OFFSET                 6
+#define MXC_CCM_CGR1_CSI_MASK                   (0x3 << 6)
+#define MXC_CCM_CGR1_RTC_OFFSET                 8
+#define MXC_CCM_CGR1_RTC_MASK                   (0x3 << 8)
+#define MXC_CCM_CGR1_WDOG_OFFSET                10
+#define MXC_CCM_CGR1_WDOG_MASK                  (0x3 << 10)
+#define MXC_CCM_CGR1_PWM_OFFSET                 12
+#define MXC_CCM_CGR1_PWM_MASK                   (0x3 << 12)
+#define MXC_CCM_CGR1_SIM_OFFSET                 14
+#define MXC_CCM_CGR1_SIM_MASK                   (0x3 << 14)
+#define MXC_CCM_CGR1_ECT_OFFSET                 16
+#define MXC_CCM_CGR1_ECT_MASK                   (0x3 << 16)
+#define MXC_CCM_CGR1_USBOTG_OFFSET              18
+#define MXC_CCM_CGR1_USBOTG_MASK                (0x3 << 18)
+#define MXC_CCM_CGR1_KPP_OFFSET                 20
+#define MXC_CCM_CGR1_KPP_MASK                   (0x3 << 20)
+#define MXC_CCM_CGR1_IPU_OFFSET                 22
+#define MXC_CCM_CGR1_IPU_MASK                   (0x3 << 22)
+#define MXC_CCM_CGR1_UART3_OFFSET               24
+#define MXC_CCM_CGR1_UART3_MASK                 (0x3 << 24)
+#define MXC_CCM_CGR1_UART4_OFFSET               26
+#define MXC_CCM_CGR1_UART4_MASK                 (0x3 << 26)
+#define MXC_CCM_CGR1_UART5_OFFSET               28
+#define MXC_CCM_CGR1_UART5_MASK                 (0x3 << 28)
+#define MXC_CCM_CGR1_OWIRE_OFFSET               30
+#define MXC_CCM_CGR1_OWIRE_MASK                 (0x3 << 30)
+
+#define MXC_CCM_CGR2_SSI2_OFFSET                0
+#define MXC_CCM_CGR2_SSI2_MASK                  (0x3 << 0)
+#define MXC_CCM_CGR2_CSPI1_OFFSET               2
+#define MXC_CCM_CGR2_CSPI1_MASK                 (0x3 << 2)
+#define MXC_CCM_CGR2_CSPI2_OFFSET               4
+#define MXC_CCM_CGR2_CSPI2_MASK                 (0x3 << 4)
+#define MXC_CCM_CGR2_GACC_OFFSET                6
+#define MXC_CCM_CGR2_GACC_MASK                  (0x3 << 6)
+#define MXC_CCM_CGR2_EMI_OFFSET                 8
+#define MXC_CCM_CGR2_EMI_MASK                   (0x3 << 8)
+#define MXC_CCM_CGR2_RTIC_OFFSET                10
+#define MXC_CCM_CGR2_RTIC_MASK                  (0x3 << 10)
+#define MXC_CCM_CGR2_FIRI_OFFSET                12
+#define MXC_CCM_CGR2_FIRI_MASK                  (0x3 << 12)
+#define MXC_CCM_CGR2_IPMUX1_OFFSET              14
+#define MXC_CCM_CGR2_IPMUX1_MASK                (0x3 << 14)
+#define MXC_CCM_CGR2_IPMUX2_OFFSET              16
+#define MXC_CCM_CGR2_IPMUX2_MASK                (0x3 << 16)
+
+/* These new CGR2 bits are added in MX32 */
+#define MXC_CCM_CGR2_APMSYSCLKSEL_OFFSET	18
+#define MXC_CCM_CGR2_APMSYSCLKSEL_MASK		(0x3 << 18)
+#define MXC_CCM_CGR2_APMSSICLKSEL_OFFSET	20
+#define MXC_CCM_CGR2_APMSSICLKSEL_MASK		(0x3 << 20)
+#define MXC_CCM_CGR2_APMPERCLKSEL_OFFSET	22
+#define MXC_CCM_CGR2_APMPERCLKSEL_MASK		(0x3 << 22)
+#define MXC_CCM_CGR2_MXCCLKENSEL_OFFSET		24
+#define MXC_CCM_CGR2_MXCCLKENSEL_MASK		(0x1 << 24)
+#define MXC_CCM_CGR2_CHIKCAMPEN_OFFSET		25
+#define MXC_CCM_CGR2_CHIKCAMPEN_MASK		(0x1 << 25)
+#define MXC_CCM_CGR2_OVRVPUBUSY_OFFSET		26
+#define MXC_CCM_CGR2_OVRVPUBUSY_MASK		(0x1 << 26)
+#define MXC_CCM_CGR2_APMENA_OFFSET		30
+#define MXC_CCM_CGR2_AOMENA_MASK		(0x1 << 30)
+
+/*
+ * LTR0 register offsets
+ */
+#define MXC_CCM_LTR0_DIV3CK_OFFSET              1
+#define MXC_CCM_LTR0_DIV3CK_MASK                (0x3 << 1)
+#define MXC_CCM_LTR0_DNTHR_OFFSET               16
+#define MXC_CCM_LTR0_DNTHR_MASK                 (0x3F << 16)
+#define MXC_CCM_LTR0_UPTHR_OFFSET               22
+#define MXC_CCM_LTR0_UPTHR_MASK                 (0x3F << 22)
+
+/*
+ * LTR1 register offsets
+ */
+#define MXC_CCM_LTR1_PNCTHR_OFFSET              0
+#define MXC_CCM_LTR1_PNCTHR_MASK                0x3F
+#define MXC_CCM_LTR1_UPCNT_OFFSET               6
+#define MXC_CCM_LTR1_UPCNT_MASK                 (0xFF << 6)
+#define MXC_CCM_LTR1_DNCNT_OFFSET               14
+#define MXC_CCM_LTR1_DNCNT_MASK                 (0xFF << 14)
+#define MXC_CCM_LTR1_LTBRSR_MASK                0x400000
+#define MXC_CCM_LTR1_LTBRSR_OFFSET              22
+#define MXC_CCM_LTR1_LTBRSR                     0x400000
+#define MXC_CCM_LTR1_LTBRSH                     0x800000
+
+/*
+ * LTR2 bit definitions. x ranges from 0 for WSW9 to 6 for WSW15
+ */
+#define MXC_CCM_LTR2_WSW_OFFSET(x)              (11 + (x) * 3)
+#define MXC_CCM_LTR2_WSW_MASK(x)                (0x7 << \
+					MXC_CCM_LTR2_WSW_OFFSET((x)))
+#define MXC_CCM_LTR2_EMAC_OFFSET                0
+#define MXC_CCM_LTR2_EMAC_MASK                  0x1FF
+
+/*
+ * LTR3 bit definitions. x ranges from 0 for WSW0 to 8 for WSW8
+ */
+#define MXC_CCM_LTR3_WSW_OFFSET(x)              (5 + (x) * 3)
+#define MXC_CCM_LTR3_WSW_MASK(x)                (0x7 << \
+					MXC_CCM_LTR3_WSW_OFFSET((x)))
+
+#define MXC_CCM_PMCR0_DFSUP1                    0x80000000
+#define MXC_CCM_PMCR0_DFSUP1_SPLL               (0 << 31)
+#define MXC_CCM_PMCR0_DFSUP1_MPLL               (1 << 31)
+#define MXC_CCM_PMCR0_DFSUP0                    0x40000000
+#define MXC_CCM_PMCR0_DFSUP0_PLL                (0 << 30)
+#define MXC_CCM_PMCR0_DFSUP0_PDR                (1 << 30)
+#define MXC_CCM_PMCR0_DFSUP_MASK                (0x3 << 30)
+
+#define DVSUP_TURBO				0
+#define DVSUP_HIGH				1
+#define DVSUP_MEDIUM				2
+#define DVSUP_LOW				3
+#define MXC_CCM_PMCR0_DVSUP_TURBO               (DVSUP_TURBO << 28)
+#define MXC_CCM_PMCR0_DVSUP_HIGH                (DVSUP_HIGH << 28)
+#define MXC_CCM_PMCR0_DVSUP_MEDIUM              (DVSUP_MEDIUM << 28)
+#define MXC_CCM_PMCR0_DVSUP_LOW                 (DVSUP_LOW << 28)
+#define MXC_CCM_PMCR0_DVSUP_OFFSET              28
+#define MXC_CCM_PMCR0_DVSUP_MASK                (0x3 << 28)
+#define MXC_CCM_PMCR0_UDSC                      0x08000000
+#define MXC_CCM_PMCR0_UDSC_MASK                 (1 << 27)
+#define MXC_CCM_PMCR0_UDSC_UP                   (1 << 27)
+#define MXC_CCM_PMCR0_UDSC_DOWN                 (0 << 27)
+
+#define MXC_CCM_PMCR0_VSCNT_1                   (0x0 << 24)
+#define MXC_CCM_PMCR0_VSCNT_2                   (0x1 << 24)
+#define MXC_CCM_PMCR0_VSCNT_3                   (0x2 << 24)
+#define MXC_CCM_PMCR0_VSCNT_4                   (0x3 << 24)
+#define MXC_CCM_PMCR0_VSCNT_5                   (0x4 << 24)
+#define MXC_CCM_PMCR0_VSCNT_6                   (0x5 << 24)
+#define MXC_CCM_PMCR0_VSCNT_7                   (0x6 << 24)
+#define MXC_CCM_PMCR0_VSCNT_8                   (0x7 << 24)
+#define MXC_CCM_PMCR0_VSCNT_OFFSET              24
+#define MXC_CCM_PMCR0_VSCNT_MASK                (0x7 << 24)
+#define MXC_CCM_PMCR0_DVFEV                     0x00800000
+#define MXC_CCM_PMCR0_DVFIS                     0x00400000
+#define MXC_CCM_PMCR0_LBMI                      0x00200000
+#define MXC_CCM_PMCR0_LBFL                      0x00100000
+#define MXC_CCM_PMCR0_LBCF_4                    (0x0 << 18)
+#define MXC_CCM_PMCR0_LBCF_8                    (0x1 << 18)
+#define MXC_CCM_PMCR0_LBCF_12                   (0x2 << 18)
+#define MXC_CCM_PMCR0_LBCF_16                   (0x3 << 18)
+#define MXC_CCM_PMCR0_LBCF_OFFSET               18
+#define MXC_CCM_PMCR0_LBCF_MASK                 (0x3 << 18)
+#define MXC_CCM_PMCR0_PTVIS                     0x00020000
+#define MXC_CCM_PMCR0_UPDTEN                    0x00010000
+#define MXC_CCM_PMCR0_UPDTEN_MASK               (0x1 << 16)
+#define MXC_CCM_PMCR0_FSVAIM                    0x00008000
+#define MXC_CCM_PMCR0_FSVAI_OFFSET              13
+#define MXC_CCM_PMCR0_FSVAI_MASK                (0x3 << 13)
+#define MXC_CCM_PMCR0_DPVCR                     0x00001000
+#define MXC_CCM_PMCR0_DPVV                      0x00000800
+#define MXC_CCM_PMCR0_WFIM                      0x00000400
+#define MXC_CCM_PMCR0_DRCE3                     0x00000200
+#define MXC_CCM_PMCR0_DRCE2                     0x00000100
+#define MXC_CCM_PMCR0_DRCE1                     0x00000080
+#define MXC_CCM_PMCR0_DRCE0                     0x00000040
+#define MXC_CCM_PMCR0_DCR                       0x00000020
+#define MXC_CCM_PMCR0_DVFEN                     0x00000010
+#define MXC_CCM_PMCR0_PTVAIM                    0x00000008
+#define MXC_CCM_PMCR0_PTVAI_OFFSET              1
+#define MXC_CCM_PMCR0_PTVAI_MASK                (0x3 << 1)
+#define MXC_CCM_PMCR0_DPTEN                     0x00000001
+
+#define MXC_CCM_PMCR1_DVGP_OFFSET               0
+#define MXC_CCM_PMCR1_DVGP_MASK                 (0xF)
+
+#define MXC_CCM_PMCR1_PLLRDIS                      (0x1 << 7)
+#define MXC_CCM_PMCR1_EMIRQ_EN                      (0x1 << 8)
+
+#define MXC_CCM_DCVR_ULV_MASK                   (0x3FF << 22)
+#define MXC_CCM_DCVR_ULV_OFFSET                 22
+#define MXC_CCM_DCVR_LLV_MASK                   (0x3FF << 12)
+#define MXC_CCM_DCVR_LLV_OFFSET                 12
+#define MXC_CCM_DCVR_ELV_MASK                   (0x3FF << 2)
+#define MXC_CCM_DCVR_ELV_OFFSET                 2
+
+#define MXC_CCM_PDR2_MST2_PDF_MASK              (0x3F << 7)
+#define MXC_CCM_PDR2_MST2_PDF_OFFSET            7
+#define MXC_CCM_PDR2_MST1_PDF_MASK              0x3F
+#define MXC_CCM_PDR2_MST1_PDF_OFFSET            0
+
+#define MXC_CCM_COSR_CLKOSEL_MASK               0x0F
+#define MXC_CCM_COSR_CLKOSEL_OFFSET             0
+#define MXC_CCM_COSR_CLKOUTDIV_MASK             (0x07 << 6)
+#define MXC_CCM_COSR_CLKOUTDIV_OFFSET           6
+#define MXC_CCM_COSR_CLKOEN                     (1 << 9)
+
+/*
+ * PMCR0 register offsets
+ */
+#define MXC_CCM_PMCR0_LBFL_OFFSET   20
+#define MXC_CCM_PMCR0_DFSUP0_OFFSET 30
+#define MXC_CCM_PMCR0_DFSUP1_OFFSET 31
+
+#endif				/* __ARCH_ARM_MACH_MX3_CRM_REGS_H__ */
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx3/devices.c ipipe-2.6.26-mxc/arch/arm/mach-mx3/devices.c
--- adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx3/devices.c	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/arch/arm/mach-mx3/devices.c	2008-10-19 15:15:34.000000000 +0200
@@ -0,0 +1,180 @@
+/*
+ * Copyright 2006-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 Sascha Hauer, kernel@pengutronix.de
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/serial.h>
+#include <linux/gpio.h>
+#include <asm/hardware.h>
+#include <asm/arch/imx-uart.h>
+
+static struct resource uart0[] = {
+	{
+		.start = UART1_BASE_ADDR,
+		.end = UART1_BASE_ADDR + 0x0B5,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = MXC_INT_UART1,
+		.end = MXC_INT_UART1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mxc_uart_device0 = {
+	.name = "imx-uart",
+	.id = 0,
+	.resource = uart0,
+	.num_resources = ARRAY_SIZE(uart0),
+};
+
+static struct resource uart1[] = {
+	{
+		.start = UART2_BASE_ADDR,
+		.end = UART2_BASE_ADDR + 0x0B5,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = MXC_INT_UART2,
+		.end = MXC_INT_UART2,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mxc_uart_device1 = {
+	.name = "imx-uart",
+	.id = 1,
+	.resource = uart1,
+	.num_resources = ARRAY_SIZE(uart1),
+};
+
+static struct resource uart2[] = {
+	{
+		.start = UART3_BASE_ADDR,
+		.end = UART3_BASE_ADDR + 0x0B5,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = MXC_INT_UART3,
+		.end = MXC_INT_UART3,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mxc_uart_device2 = {
+	.name = "imx-uart",
+	.id = 2,
+	.resource = uart2,
+	.num_resources = ARRAY_SIZE(uart2),
+};
+
+static struct resource uart3[] = {
+	{
+		.start = UART4_BASE_ADDR,
+		.end = UART4_BASE_ADDR + 0x0B5,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = MXC_INT_UART4,
+		.end = MXC_INT_UART4,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mxc_uart_device3 = {
+	.name = "imx-uart",
+	.id = 3,
+	.resource = uart3,
+	.num_resources = ARRAY_SIZE(uart3),
+};
+
+static struct resource uart4[] = {
+	{
+		.start = UART5_BASE_ADDR,
+		.end = UART5_BASE_ADDR + 0x0B5,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = MXC_INT_UART5,
+		.end = MXC_INT_UART5,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mxc_uart_device4 = {
+	.name = "imx-uart",
+	.id = 4,
+	.resource = uart4,
+	.num_resources = ARRAY_SIZE(uart4),
+};
+
+/*
+ * Register only those UARTs that physically exist
+ */
+int __init imx_init_uart(int uart_no, struct imxuart_platform_data *pdata)
+{
+	switch (uart_no) {
+	case 0:
+		mxc_uart_device0.dev.platform_data = pdata;
+		platform_device_register(&mxc_uart_device0);
+		break;
+	case 1:
+		mxc_uart_device1.dev.platform_data = pdata;
+		platform_device_register(&mxc_uart_device1);
+		break;
+	case 2:
+		mxc_uart_device2.dev.platform_data = pdata;
+		platform_device_register(&mxc_uart_device2);
+		break;
+	case 3:
+		mxc_uart_device3.dev.platform_data = pdata;
+		platform_device_register(&mxc_uart_device3);
+		break;
+	case 4:
+		mxc_uart_device4.dev.platform_data = pdata;
+		platform_device_register(&mxc_uart_device4);
+		break;
+	default:
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+/* GPIO port description */
+static struct mxc_gpio_port imx_gpio_ports[] = {
+	[0] = {
+		.chip.label = "gpio-0",
+		.base = IO_ADDRESS(GPIO1_BASE_ADDR),
+		.irq = MXC_INT_GPIO1,
+		.virtual_irq_start = MXC_GPIO_INT_BASE
+	},
+	[1] = {
+		.chip.label = "gpio-1",
+		.base = IO_ADDRESS(GPIO2_BASE_ADDR),
+		.irq = MXC_INT_GPIO2,
+		.virtual_irq_start = MXC_GPIO_INT_BASE + GPIO_NUM_PIN
+	},
+	[2] = {
+		.chip.label = "gpio-2",
+		.base = IO_ADDRESS(GPIO3_BASE_ADDR),
+		.irq = MXC_INT_GPIO3,
+		.virtual_irq_start = MXC_GPIO_INT_BASE + GPIO_NUM_PIN * 2
+	}
+};
+
+int __init mxc_register_gpios(void)
+{
+	return mxc_gpio_init(imx_gpio_ports, ARRAY_SIZE(imx_gpio_ports));
+}
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx3/iomux.c ipipe-2.6.26-mxc/arch/arm/mach-mx3/iomux.c
--- adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx3/iomux.c	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/arch/arm/mach-mx3/iomux.c	2008-10-19 15:15:34.000000000 +0200
@@ -0,0 +1,111 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2008 by Sascha Hauer <kernel@pengutronix.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/io.h>
+#include <linux/gpio.h>
+#include <asm/hardware.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/iomux-mx3.h>
+
+/*
+ * IOMUX register (base) addresses
+ */
+#define IOMUX_BASE	IO_ADDRESS(IOMUXC_BASE_ADDR)
+#define IOMUXINT_OBS1	(IOMUX_BASE + 0x000)
+#define IOMUXINT_OBS2	(IOMUX_BASE + 0x004)
+#define IOMUXGPR	(IOMUX_BASE + 0x008)
+#define IOMUXSW_MUX_CTL	(IOMUX_BASE + 0x00C)
+#define IOMUXSW_PAD_CTL	(IOMUX_BASE + 0x154)
+
+static DEFINE_SPINLOCK(gpio_mux_lock);
+
+#define IOMUX_REG_MASK (IOMUX_PADNUM_MASK & ~0x3)
+/*
+ * set the mode for a IOMUX pin.
+ */
+int mxc_iomux_mode(unsigned int pin_mode)
+{
+	u32 reg, field, l, mode, ret = 0;
+
+	reg = IOMUXSW_MUX_CTL + (pin_mode & IOMUX_REG_MASK);
+	field = pin_mode & 0x3;
+	mode = (pin_mode & IOMUX_MODE_MASK) >> IOMUX_MODE_SHIFT;
+
+	pr_debug("%s: reg offset = 0x%x field = %d mode = 0x%02x\n",
+			__func__, (pin_mode & IOMUX_REG_MASK), field, mode);
+
+	spin_lock(&gpio_mux_lock);
+
+	l = __raw_readl(reg);
+	l &= ~(0xff << (field * 8));
+	l |= mode << (field * 8);
+	__raw_writel(l, reg);
+
+	spin_unlock(&gpio_mux_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL(mxc_iomux_mode);
+
+/*
+ * This function configures the pad value for a IOMUX pin.
+ */
+void mxc_iomux_set_pad(enum iomux_pins pin, u32 config)
+{
+	u32 reg, field, l;
+
+	reg = IOMUXSW_PAD_CTL + (pin + 2) / 3;
+	field = (pin + 2) % 3;
+
+	pr_debug("%s: reg offset = 0x%x field = %d\n",
+			__func__, (pin + 2) / 3, field);
+
+	spin_lock(&gpio_mux_lock);
+
+	l = __raw_readl(reg);
+	l &= ~(0x1ff << (field * 9));
+	l |= config << (field * 9);
+	__raw_writel(l, reg);
+
+	spin_unlock(&gpio_mux_lock);
+}
+EXPORT_SYMBOL(mxc_iomux_set_pad);
+
+/*
+ * This function enables/disables the general purpose function for a particular
+ * signal.
+ */
+void mxc_iomux_set_gpr(enum iomux_gp_func gp, bool en)
+{
+	u32 l;
+
+	spin_lock(&gpio_mux_lock);
+	l = __raw_readl(IOMUXGPR);
+	if (en)
+		l |= gp;
+	else
+		l &= ~gp;
+
+	__raw_writel(l, IOMUXGPR);
+	spin_unlock(&gpio_mux_lock);
+}
+EXPORT_SYMBOL(mxc_iomux_set_gpr);
+
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx3/Kconfig ipipe-2.6.26-mxc/arch/arm/mach-mx3/Kconfig
--- adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx3/Kconfig	2007-10-22 21:48:38.000000000 +0200
+++ ipipe-2.6.26-mxc/arch/arm/mach-mx3/Kconfig	2008-10-19 15:15:34.000000000 +0200
@@ -8,5 +8,18 @@ config MACH_MX31ADS
 	  Include support for MX31ADS platform. This includes specific
 	  configurations for the board and its peripherals.
 
+config MACH_PCM037
+	bool "Support Phytec pcm037 platforms"
+	help
+	  Include support for Phytec pcm037 platform. This includes
+	  specific configurations for the board and its peripherals.
+
+config MACH_MX31LITE
+	bool "Support MX31 LITEKIT (LogicPD)"
+	default n
+	help
+	  Include support for MX31 LITEKIT platform. This includes specific
+	  configurations for the board and its peripherals.
+
 endmenu
 
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx3/Makefile ipipe-2.6.26-mxc/arch/arm/mach-mx3/Makefile
--- adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx3/Makefile	2007-10-22 21:48:38.000000000 +0200
+++ ipipe-2.6.26-mxc/arch/arm/mach-mx3/Makefile	2008-10-19 15:15:34.000000000 +0200
@@ -4,5 +4,7 @@
 
 # Object file lists.
 
-obj-y			:= mm.o time.o
+obj-y			:= mm.o clock.o devices.o iomux.o
 obj-$(CONFIG_MACH_MX31ADS)	+= mx31ads.o
+obj-$(CONFIG_MACH_MX31LITE)	+= mx31lite.o
+obj-$(CONFIG_MACH_PCM037)	+= pcm037.o
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx3/mx31ads.c ipipe-2.6.26-mxc/arch/arm/mach-mx3/mx31ads.c
--- adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx3/mx31ads.c	2007-10-22 21:48:38.000000000 +0200
+++ ipipe-2.6.26-mxc/arch/arm/mach-mx3/mx31ads.c	2008-10-19 15:15:34.000000000 +0200
@@ -22,13 +22,18 @@
 #include <linux/init.h>
 #include <linux/clk.h>
 #include <linux/serial_8250.h>
+#include <linux/irq.h>
 
 #include <asm/hardware.h>
 #include <asm/mach-types.h>
 #include <asm/mach/arch.h>
+#include <asm/mach/time.h>
 #include <asm/memory.h>
 #include <asm/mach/map.h>
 #include <asm/arch/common.h>
+#include <asm/arch/board-mx31ads.h>
+#include <asm/arch/imx-uart.h>
+#include <asm/arch/iomux-mx3.h>
 
 /*!
  * @file mx31ads.c
@@ -82,6 +87,26 @@ static inline int mxc_init_extuart(void)
 }
 #endif
 
+#if defined(CONFIG_SERIAL_IMX) || defined(CONFIG_SERIAL_IMX_MODULE)
+static struct imxuart_platform_data uart_pdata = {
+	.flags = IMXUART_HAVE_RTSCTS,
+};
+
+static inline void mxc_init_imx_uart(void)
+{
+	mxc_iomux_mode(MX31_PIN_CTS1__CTS1);
+	mxc_iomux_mode(MX31_PIN_RTS1__RTS1);
+	mxc_iomux_mode(MX31_PIN_TXD1__TXD1);
+	mxc_iomux_mode(MX31_PIN_RXD1__RXD1);
+
+	imx_init_uart(0, &uart_pdata);
+}
+#else /* !SERIAL_IMX */
+static inline void mxc_init_imx_uart(void)
+{
+}
+#endif /* !SERIAL_IMX */
+
 /*!
  * This structure defines static mappings for the i.MX31ADS board.
  */
@@ -109,6 +134,107 @@ static struct map_desc mx31ads_io_desc[]
 	},
 };
 
+static void mx31ads_expio_irq_handler(u32 irq, struct irq_desc *desc)
+{
+	u32 imr_val;
+	u32 int_valid;
+	u32 expio_irq;
+
+	imr_val = __raw_readw(PBC_INTMASK_SET_REG);
+	int_valid = __raw_readw(PBC_INTSTATUS_REG) & imr_val;
+
+	expio_irq = MXC_EXP_IO_BASE;
+	for (; int_valid != 0; int_valid >>= 1, expio_irq++) {
+		if ((int_valid & 1) == 0)
+			continue;
+
+		generic_handle_irq(expio_irq);
+	}
+}
+
+#ifdef CONFIG_IPIPE
+void mx31ads_demux_expio(u32 irq, struct pt_regs *regs)
+{
+        u32 imr_val;
+        u32 int_valid;
+        u32 expio_irq;
+
+        imr_val = __raw_readw(PBC_INTMASK_SET_REG);
+        int_valid = __raw_readw(PBC_INTSTATUS_REG) & imr_val;
+
+        expio_irq = MXC_EXP_IO_BASE;
+        for (; int_valid != 0; int_valid >>= 1, expio_irq++) {
+                if ((int_valid & 1) == 0)
+                        continue;
+                __ipipe_handle_irq(expio_irq, regs);
+        }
+}
+#endif /* CONFIG_IPIPE */
+
+/*
+ * Disable an expio pin's interrupt by setting the bit in the imr.
+ * @param irq           an expio virtual irq number
+ */
+static void expio_mask_irq(u32 irq)
+{
+	u32 expio = MXC_IRQ_TO_EXPIO(irq);
+	/* mask the interrupt */
+	__raw_writew(1 << expio, PBC_INTMASK_CLEAR_REG);
+	__raw_readw(PBC_INTMASK_CLEAR_REG);
+}
+
+/*
+ * Acknowledge an expanded io pin's interrupt by clearing the bit in the isr.
+ * @param irq           an expanded io virtual irq number
+ */
+static void expio_ack_irq(u32 irq)
+{
+	u32 expio = MXC_IRQ_TO_EXPIO(irq);
+	/* clear the interrupt status */
+	__raw_writew(1 << expio, PBC_INTSTATUS_REG);
+}
+
+/*
+ * Enable a expio pin's interrupt by clearing the bit in the imr.
+ * @param irq           a expio virtual irq number
+ */
+static void expio_unmask_irq(u32 irq)
+{
+	u32 expio = MXC_IRQ_TO_EXPIO(irq);
+	/* unmask the interrupt */
+	__raw_writew(1 << expio, PBC_INTMASK_SET_REG);
+}
+
+static struct irq_chip expio_irq_chip = {
+	.ack = expio_ack_irq,
+	.mask = expio_mask_irq,
+	.unmask = expio_unmask_irq,
+};
+
+static void __init mx31ads_init_expio(void)
+{
+	int i;
+
+	printk(KERN_INFO "MX31ADS EXPIO(CPLD) hardware\n");
+
+	/*
+	 * Configure INT line as GPIO input
+	 */
+	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_GPIO1_4, IOMUX_CONFIG_GPIO));
+
+	/* disable the interrupt and clear the status */
+	__raw_writew(0xFFFF, PBC_INTMASK_CLEAR_REG);
+	__raw_writew(0xFFFF, PBC_INTSTATUS_REG);
+	for (i = MXC_EXP_IO_BASE; i < (MXC_EXP_IO_BASE + MXC_MAX_EXP_IO_LINES);
+	     i++) {
+		set_irq_chip(i, &expio_irq_chip);
+		set_irq_handler(i, handle_level_irq);
+		set_irq_flags(i, IRQF_VALID);
+	}
+	set_irq_type(EXPIO_PARENT_INT, IRQ_TYPE_LEVEL_HIGH);
+	set_irq_chained_handler(EXPIO_PARENT_INT, mx31ads_expio_irq_handler);
+}
+
 /*!
  * Set up static virtual mappings.
  */
@@ -118,14 +244,31 @@ void __init mx31ads_map_io(void)
 	iotable_init(mx31ads_io_desc, ARRAY_SIZE(mx31ads_io_desc));
 }
 
+void __init mx31ads_init_irq(void)
+{
+	mxc_init_irq();
+	mx31ads_init_expio();
+}
+
 /*!
  * Board specific initialization.
  */
 static void __init mxc_board_init(void)
 {
 	mxc_init_extuart();
+	mxc_init_imx_uart();
+}
+
+static void __init mx31ads_timer_init(void)
+{
+	mxc_clocks_init(26000000);
+	mxc_timer_init("ipg_clk.0");
 }
 
+struct sys_timer mx31ads_timer = {
+	.init	= mx31ads_timer_init,
+};
+
 /*
  * The following uses standard kernel macros defined in arch.h in order to
  * initialize __mach_desc_MX31ADS data structure.
@@ -136,7 +279,7 @@ MACHINE_START(MX31ADS, "Freescale MX31AD
 	.io_pg_offst	= ((AIPS1_BASE_ADDR_VIRT) >> 18) & 0xfffc,
 	.boot_params    = PHYS_OFFSET + 0x100,
 	.map_io         = mx31ads_map_io,
-	.init_irq       = mxc_init_irq,
+	.init_irq       = mx31ads_init_irq,
 	.init_machine   = mxc_board_init,
-	.timer          = &mxc_timer,
+	.timer          = &mx31ads_timer,
 MACHINE_END
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx3/mx31lite.c ipipe-2.6.26-mxc/arch/arm/mach-mx3/mx31lite.c
--- adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx3/mx31lite.c	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/arch/arm/mach-mx3/mx31lite.c	2008-10-19 15:15:34.000000000 +0200
@@ -0,0 +1,107 @@
+/*
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd
+ *  Copyright (C) 2002 Shane Nay (shane@minirl.com)
+ *  Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/memory.h>
+
+#include <asm/hardware.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/time.h>
+#include <asm/mach/map.h>
+#include <asm/arch/common.h>
+#include <asm/page.h>
+#include <asm/setup.h>
+#include <asm/arch/board-mx31lite.h>
+
+/*
+ * This file contains the board-specific initialization routines.
+ */
+
+/*
+ * This structure defines the MX31 memory map.
+ */
+static struct map_desc mx31lite_io_desc[] __initdata = {
+	{
+		.virtual = AIPS1_BASE_ADDR_VIRT,
+		.pfn = __phys_to_pfn(AIPS1_BASE_ADDR),
+		.length = AIPS1_SIZE,
+		.type = MT_NONSHARED_DEVICE
+	}, {
+		.virtual = SPBA0_BASE_ADDR_VIRT,
+		.pfn = __phys_to_pfn(SPBA0_BASE_ADDR),
+		.length = SPBA0_SIZE,
+		.type = MT_NONSHARED_DEVICE
+	}, {
+		.virtual = AIPS2_BASE_ADDR_VIRT,
+		.pfn = __phys_to_pfn(AIPS2_BASE_ADDR),
+		.length = AIPS2_SIZE,
+		.type = MT_NONSHARED_DEVICE
+	}, {
+		.virtual = CS4_BASE_ADDR_VIRT,
+		.pfn = __phys_to_pfn(CS4_BASE_ADDR),
+		.length = CS4_SIZE,
+		.type = MT_DEVICE
+	}
+};
+
+/*
+ * Set up static virtual mappings.
+ */
+void __init mx31lite_map_io(void)
+{
+	mxc_map_io();
+	iotable_init(mx31lite_io_desc, ARRAY_SIZE(mx31lite_io_desc));
+}
+
+/*
+ * Board specific initialization.
+ */
+static void __init mxc_board_init(void)
+{
+}
+
+static void __init mx31lite_timer_init(void)
+{
+	mxc_clocks_init(26000000);
+	mxc_timer_init("ipg_clk.0");
+}
+
+struct sys_timer mx31lite_timer = {
+	.init	= mx31lite_timer_init,
+};
+
+/*
+ * The following uses standard kernel macros defined in arch.h in order to
+ * initialize __mach_desc_MX31LITE data structure.
+ */
+
+MACHINE_START(MX31LITE, "LogicPD MX31 LITEKIT")
+	/* Maintainer: Freescale Semiconductor, Inc. */
+	.phys_io        = AIPS1_BASE_ADDR,
+	.io_pg_offst    = ((AIPS1_BASE_ADDR_VIRT) >> 18) & 0xfffc,
+	.boot_params    = PHYS_OFFSET + 0x100,
+	.map_io         = mx31lite_map_io,
+	.init_irq       = mxc_init_irq,
+	.init_machine   = mxc_board_init,
+	.timer          = &mx31lite_timer,
+MACHINE_END
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx3/pcm037.c ipipe-2.6.26-mxc/arch/arm/mach-mx3/pcm037.c
--- adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx3/pcm037.c	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/arch/arm/mach-mx3/pcm037.c	2008-10-19 15:15:34.000000000 +0200
@@ -0,0 +1,130 @@
+/*
+ *  Copyright (C) 2008 Sascha Hauer, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+
+#include <linux/platform_device.h>
+#include <linux/mtd/physmap.h>
+#include <linux/memory.h>
+
+#include <asm/hardware.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/time.h>
+#include <asm/mach/map.h>
+#include <asm/arch/common.h>
+#include <asm/arch/imx-uart.h>
+#include <asm/arch/iomux-mx3.h>
+#include <asm/arch/board-pcm037.h>
+
+static struct physmap_flash_data pcm037_flash_data = {
+	.width  = 2,
+};
+
+static struct resource pcm037_flash_resource = {
+	.start	= 0xa0000000,
+	.end	= 0xa1ffffff,
+	.flags	= IORESOURCE_MEM,
+};
+
+static struct platform_device pcm037_flash = {
+	.name	= "physmap-flash",
+	.id	= 0,
+	.dev	= {
+		.platform_data  = &pcm037_flash_data,
+	},
+	.resource = &pcm037_flash_resource,
+	.num_resources = 1,
+};
+
+static struct imxuart_platform_data uart_pdata = {
+	.flags = 0,
+};
+
+static struct platform_device *devices[] __initdata = {
+	&pcm037_flash,
+};
+
+/*
+ * Board specific initialization.
+ */
+static void __init mxc_board_init(void)
+{
+	platform_add_devices(devices, ARRAY_SIZE(devices));
+
+	mxc_iomux_mode(MX31_PIN_CTS1__CTS1);
+	mxc_iomux_mode(MX31_PIN_RTS1__RTS1);
+	mxc_iomux_mode(MX31_PIN_TXD1__TXD1);
+	mxc_iomux_mode(MX31_PIN_RXD1__RXD1);
+
+	imx_init_uart(0, &uart_pdata);
+
+	mxc_iomux_mode(MX31_PIN_CSPI3_MOSI__RXD3);
+	mxc_iomux_mode(MX31_PIN_CSPI3_MISO__TXD3);
+
+	imx_init_uart(2, &uart_pdata);
+}
+
+/*
+ * This structure defines static mappings for the pcm037 board.
+ */
+static struct map_desc pcm037_io_desc[] __initdata = {
+	{
+		.virtual	= AIPS1_BASE_ADDR_VIRT,
+		.pfn		= __phys_to_pfn(AIPS1_BASE_ADDR),
+		.length		= AIPS1_SIZE,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= AIPS2_BASE_ADDR_VIRT,
+		.pfn		= __phys_to_pfn(AIPS2_BASE_ADDR),
+		.length		= AIPS2_SIZE,
+		.type		= MT_DEVICE
+	},
+};
+
+/*
+ * Set up static virtual mappings.
+ */
+void __init pcm037_map_io(void)
+{
+	mxc_map_io();
+	iotable_init(pcm037_io_desc, ARRAY_SIZE(pcm037_io_desc));
+}
+
+static void __init pcm037_timer_init(void)
+{
+	mxc_clocks_init(26000000);
+	mxc_timer_init("ipg_clk.0");
+}
+
+struct sys_timer pcm037_timer = {
+	.init	= pcm037_timer_init,
+};
+
+MACHINE_START(PCM037, "Phytec Phycore pcm037")
+	/* Maintainer: Pengutronix */
+	.phys_io	= AIPS1_BASE_ADDR,
+	.io_pg_offst	= ((AIPS1_BASE_ADDR_VIRT) >> 18) & 0xfffc,
+	.boot_params    = PHYS_OFFSET + 0x100,
+	.map_io         = pcm037_map_io,
+	.init_irq       = mxc_init_irq,
+	.init_machine   = mxc_board_init,
+	.timer          = &pcm037_timer,
+MACHINE_END
+
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx3/time.c ipipe-2.6.26-mxc/arch/arm/mach-mx3/time.c
--- adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/mach-mx3/time.c	2008-05-10 17:10:45.000000000 +0200
+++ ipipe-2.6.26-mxc/arch/arm/mach-mx3/time.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,148 +0,0 @@
-/*
- * System Timer Interrupt reconfigured to run in free-run mode.
- * Author: Vitaly Wool
- * Copyright 2004 MontaVista Software Inc.
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-/*!
- * @file time.c
- * @brief This file contains OS tick and wdog timer implementations.
- *
- * This file contains OS tick and wdog timer implementations.
- *
- * @ingroup Timers
- */
-
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <asm/hardware.h>
-#include <asm/mach/time.h>
-#include <asm/io.h>
-#include <asm/arch/common.h>
-
-/*!
- * This is the timer interrupt service routine to do required tasks.
- * It also services the WDOG timer at the frequency of twice per WDOG
- * timeout value. For example, if the WDOG's timeout value is 4 (2
- * seconds since the WDOG runs at 0.5Hz), it will be serviced once
- * every 2/2=1 second.
- *
- * @param  irq          GPT interrupt source number (not used)
- * @param  dev_id       this parameter is not used
- * @return always returns \b IRQ_HANDLED as defined in
- *         include/linux/interrupt.h.
- */
-static irqreturn_t mxc_timer_interrupt(int irq, void *dev_id)
-{
-	unsigned int next_match;
-
-	if (__raw_readl(MXC_GPT_GPTSR) & GPTSR_OF1) {
-		do {
-			timer_tick();
-			next_match = __raw_readl(MXC_GPT_GPTOCR1) + LATCH;
-			__raw_writel(GPTSR_OF1, MXC_GPT_GPTSR);
-			__raw_writel(next_match, MXC_GPT_GPTOCR1);
-		} while ((signed long)(next_match -
-				       __raw_readl(MXC_GPT_GPTCNT)) <= 0);
-	}
-
-	return IRQ_HANDLED;
-}
-
-/*!
- * This function is used to obtain the number of microseconds since the last
- * timer interrupt. Note that interrupts is disabled by do_gettimeofday().
- *
- * @return the number of microseconds since the last timer interrupt.
- */
-static unsigned long mxc_gettimeoffset(void)
-{
-	unsigned long ticks_to_match, elapsed, usec, tick_usec, i;
-
-	/* Get ticks before next timer match */
-	ticks_to_match =
-	    __raw_readl(MXC_GPT_GPTOCR1) - __raw_readl(MXC_GPT_GPTCNT);
-
-	/* We need elapsed ticks since last match */
-	elapsed = LATCH - ticks_to_match;
-
-	/* Now convert them to usec */
-	/* Insure no overflow when calculating the usec below */
-	for (i = 1, tick_usec = tick_nsec / 1000;; i *= 2) {
-		tick_usec /= i;
-		if ((0xFFFFFFFF / tick_usec) > elapsed)
-			break;
-	}
-	usec = (unsigned long)(elapsed * tick_usec) / (LATCH / i);
-
-	return usec;
-}
-
-/*!
- * The OS tick timer interrupt structure.
- */
-static struct irqaction timer_irq = {
-	.name = "MXC Timer Tick",
-	.flags = IRQF_DISABLED | IRQF_TIMER,
-	.handler = mxc_timer_interrupt
-};
-
-/*!
- * This function is used to initialize the GPT to produce an interrupt
- * based on HZ.  It is called by start_kernel() during system startup.
- */
-void __init mxc_init_time(void)
-{
-	u32 reg, v;
-	reg = __raw_readl(MXC_GPT_GPTCR);
-	reg &= ~GPTCR_ENABLE;
-	__raw_writel(reg, MXC_GPT_GPTCR);
-	reg |= GPTCR_SWR;
-	__raw_writel(reg, MXC_GPT_GPTCR);
-
-	while ((__raw_readl(MXC_GPT_GPTCR) & GPTCR_SWR) != 0)
-		cpu_relax();
-
-	reg = GPTCR_FRR | GPTCR_CLKSRC_HIGHFREQ;
-	__raw_writel(reg, MXC_GPT_GPTCR);
-
-	/* TODO: get timer rate from clk driver */
-	v = 66500000;
-
-	__raw_writel((v / CLOCK_TICK_RATE) - 1, MXC_GPT_GPTPR);
-
-	if ((v % CLOCK_TICK_RATE) != 0) {
-		pr_info("\nWARNING: Can't generate CLOCK_TICK_RATE at %d Hz\n",
-			CLOCK_TICK_RATE);
-	}
-	pr_info("Actual CLOCK_TICK_RATE is %d Hz\n",
-		v / ((__raw_readl(MXC_GPT_GPTPR) & 0xFFF) + 1));
-
-	reg = __raw_readl(MXC_GPT_GPTCNT);
-	reg += LATCH;
-	__raw_writel(reg, MXC_GPT_GPTOCR1);
-
-	setup_irq(MXC_INT_GPT, &timer_irq);
-
-	reg = __raw_readl(MXC_GPT_GPTCR);
-	reg =
-	    GPTCR_FRR | GPTCR_CLKSRC_HIGHFREQ | GPTCR_STOPEN | GPTCR_DOZEN |
-	    GPTCR_WAITEN | GPTCR_ENMOD | GPTCR_ENABLE;
-	__raw_writel(reg, MXC_GPT_GPTCR);
-
-	__raw_writel(GPTIR_OF1IE, MXC_GPT_GPTIR);
-}
-
-struct sys_timer mxc_timer = {
-	.init = mxc_init_time,
-	.offset = mxc_gettimeoffset,
-};
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/plat-mxc/clock.c ipipe-2.6.26-mxc/arch/arm/plat-mxc/clock.c
--- adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/plat-mxc/clock.c	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/arch/arm/plat-mxc/clock.c	2008-10-19 15:15:34.000000000 +0200
@@ -0,0 +1,331 @@
+/*
+ * Based on arch/arm/plat-omap/clock.c
+ *
+ * Copyright (C) 2004 - 2005 Nokia corporation
+ * Written by Tuukka Tikkanen <tuukka.tikkanen@elektrobit.com>
+ * Modified for omap shared clock framework by Tony Lindgren <tony@atomide.com>
+ * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+
+/* #define DEBUG */
+
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/proc_fs.h>
+#include <linux/semaphore.h>
+#include <linux/string.h>
+#include <linux/version.h>
+
+#include <asm/arch/clock.h>
+
+static LIST_HEAD(clocks);
+static DEFINE_MUTEX(clocks_mutex);
+
+/*-------------------------------------------------------------------------
+ * Standard clock functions defined in include/linux/clk.h
+ *-------------------------------------------------------------------------*/
+
+/*
+ * Retrieve a clock by name.
+ *
+ * Note that we first try to use device id on the bus
+ * and clock name. If this fails, we try to use "<name>.<id>". If this fails,
+ * we try to use clock name only.
+ * The reference count to the clock's module owner ref count is incremented.
+ */
+struct clk *clk_get(struct device *dev, const char *id)
+{
+	struct clk *p, *clk = ERR_PTR(-ENOENT);
+	int idno;
+	const char *str;
+
+	if (id == NULL)
+		return clk;
+
+	if (dev == NULL || dev->bus != &platform_bus_type)
+		idno = -1;
+	else
+		idno = to_platform_device(dev)->id;
+
+	mutex_lock(&clocks_mutex);
+
+	list_for_each_entry(p, &clocks, node) {
+		if (p->id == idno &&
+		    strcmp(id, p->name) == 0 && try_module_get(p->owner)) {
+			clk = p;
+			goto found;
+		}
+	}
+
+	str = strrchr(id, '.');
+	if (str) {
+		int cnt = str - id;
+		str++;
+		idno = simple_strtol(str, NULL, 10);
+		list_for_each_entry(p, &clocks, node) {
+			if (p->id == idno &&
+			    strlen(p->name) == cnt &&
+			    strncmp(id, p->name, cnt) == 0 &&
+			    try_module_get(p->owner)) {
+				clk = p;
+				goto found;
+			}
+		}
+	}
+
+	list_for_each_entry(p, &clocks, node) {
+		if (strcmp(id, p->name) == 0 && try_module_get(p->owner)) {
+			clk = p;
+			goto found;
+		}
+	}
+
+	printk(KERN_WARNING "clk: Unable to get requested clock: %s\n", id);
+
+found:
+	mutex_unlock(&clocks_mutex);
+
+	return clk;
+}
+EXPORT_SYMBOL(clk_get);
+
+static void __clk_disable(struct clk *clk)
+{
+	if (clk == NULL || IS_ERR(clk))
+		return;
+
+	__clk_disable(clk->parent);
+	__clk_disable(clk->secondary);
+
+	if (!(--clk->usecount) && clk->disable)
+		clk->disable(clk);
+}
+
+static int __clk_enable(struct clk *clk)
+{
+	if (clk == NULL || IS_ERR(clk))
+		return -EINVAL;
+
+	__clk_enable(clk->parent);
+	__clk_enable(clk->secondary);
+
+	if (clk->usecount++ == 0 && clk->enable)
+		clk->enable(clk);
+
+	return 0;
+}
+
+/* This function increments the reference count on the clock and enables the
+ * clock if not already enabled. The parent clock tree is recursively enabled
+ */
+int clk_enable(struct clk *clk)
+{
+	int ret = 0;
+
+	if (clk == NULL || IS_ERR(clk))
+		return -EINVAL;
+
+	mutex_lock(&clocks_mutex);
+	ret = __clk_enable(clk);
+	mutex_unlock(&clocks_mutex);
+
+	return ret;
+}
+EXPORT_SYMBOL(clk_enable);
+
+/* This function decrements the reference count on the clock and disables
+ * the clock when reference count is 0. The parent clock tree is
+ * recursively disabled
+ */
+void clk_disable(struct clk *clk)
+{
+	if (clk == NULL || IS_ERR(clk))
+		return;
+
+	mutex_lock(&clocks_mutex);
+	__clk_disable(clk);
+	mutex_unlock(&clocks_mutex);
+}
+EXPORT_SYMBOL(clk_disable);
+
+/* Retrieve the *current* clock rate. If the clock itself
+ * does not provide a special calculation routine, ask
+ * its parent and so on, until one is able to return
+ * a valid clock rate
+ */
+unsigned long clk_get_rate(struct clk *clk)
+{
+	if (clk == NULL || IS_ERR(clk))
+		return 0UL;
+
+	if (clk->get_rate)
+		return clk->get_rate(clk);
+
+	return clk_get_rate(clk->parent);
+}
+EXPORT_SYMBOL(clk_get_rate);
+
+/* Decrement the clock's module reference count */
+void clk_put(struct clk *clk)
+{
+	if (clk && !IS_ERR(clk))
+		module_put(clk->owner);
+}
+EXPORT_SYMBOL(clk_put);
+
+/* Round the requested clock rate to the nearest supported
+ * rate that is less than or equal to the requested rate.
+ * This is dependent on the clock's current parent.
+ */
+long clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	if (clk == NULL || IS_ERR(clk) || !clk->round_rate)
+		return 0;
+
+	return clk->round_rate(clk, rate);
+}
+EXPORT_SYMBOL(clk_round_rate);
+
+/* Set the clock to the requested clock rate. The rate must
+ * match a supported rate exactly based on what clk_round_rate returns
+ */
+int clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	int ret = -EINVAL;
+
+	if (clk == NULL || IS_ERR(clk) || clk->set_rate == NULL || rate == 0)
+		return ret;
+
+	mutex_lock(&clocks_mutex);
+	ret = clk->set_rate(clk, rate);
+	mutex_unlock(&clocks_mutex);
+
+	return ret;
+}
+EXPORT_SYMBOL(clk_set_rate);
+
+/* Set the clock's parent to another clock source */
+int clk_set_parent(struct clk *clk, struct clk *parent)
+{
+	int ret = -EINVAL;
+
+	if (clk == NULL || IS_ERR(clk) || parent == NULL ||
+	    IS_ERR(parent) || clk->set_parent == NULL)
+		return ret;
+
+	mutex_lock(&clocks_mutex);
+	ret = clk->set_parent(clk, parent);
+	if (ret == 0)
+		clk->parent = parent;
+	mutex_unlock(&clocks_mutex);
+
+	return ret;
+}
+EXPORT_SYMBOL(clk_set_parent);
+
+/* Retrieve the clock's parent clock source */
+struct clk *clk_get_parent(struct clk *clk)
+{
+	struct clk *ret = NULL;
+
+	if (clk == NULL || IS_ERR(clk))
+		return ret;
+
+	return clk->parent;
+}
+EXPORT_SYMBOL(clk_get_parent);
+
+/*
+ * Add a new clock to the clock tree.
+ */
+int clk_register(struct clk *clk)
+{
+	if (clk == NULL || IS_ERR(clk))
+		return -EINVAL;
+
+	mutex_lock(&clocks_mutex);
+	list_add(&clk->node, &clocks);
+	mutex_unlock(&clocks_mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL(clk_register);
+
+/* Remove a clock from the clock tree */
+void clk_unregister(struct clk *clk)
+{
+	if (clk == NULL || IS_ERR(clk))
+		return;
+
+	mutex_lock(&clocks_mutex);
+	list_del(&clk->node);
+	mutex_unlock(&clocks_mutex);
+}
+EXPORT_SYMBOL(clk_unregister);
+
+#ifdef CONFIG_PROC_FS
+static int mxc_clock_read_proc(char *page, char **start, off_t off,
+				int count, int *eof, void *data)
+{
+	struct clk *clkp;
+	char *p = page;
+	int len;
+
+	list_for_each_entry(clkp, &clocks, node) {
+		p += sprintf(p, "%s-%d:\t\t%lu, %d", clkp->name, clkp->id,
+				clk_get_rate(clkp), clkp->usecount);
+		if (clkp->parent)
+			p += sprintf(p, ", %s-%d\n", clkp->parent->name,
+				     clkp->parent->id);
+		else
+			p += sprintf(p, "\n");
+	}
+
+	len = (p - page) - off;
+	if (len < 0)
+		len = 0;
+
+	*eof = (len <= count) ? 1 : 0;
+	*start = page + off;
+
+	return len;
+}
+
+static int __init mxc_setup_proc_entry(void)
+{
+	struct proc_dir_entry *res;
+
+	res = create_proc_read_entry("cpu/clocks", 0, NULL,
+				     mxc_clock_read_proc, NULL);
+	if (!res) {
+		printk(KERN_ERR "Failed to create proc/cpu/clocks\n");
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+late_initcall(mxc_setup_proc_entry);
+#endif
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/plat-mxc/gpio.c ipipe-2.6.26-mxc/arch/arm/plat-mxc/gpio.c
--- adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/plat-mxc/gpio.c	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/arch/arm/plat-mxc/gpio.c	2008-10-19 15:15:34.000000000 +0200
@@ -0,0 +1,316 @@
+/*
+ * MXC GPIO support. (c) 2008 Daniel Mack <daniel@caiaq.de>
+ * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
+ *
+ * Based on code from Freescale,
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <asm/hardware.h>
+#include <asm-generic/bug.h>
+#ifdef CONFIG_IPIPE
+#include <asm/ipipe.h>
+#ifdef CONFIG_MACH_MX31ADS
+#include <asm/arch/iomux-mx3.h>
+#include <asm/arch/board-mx31ads.h>
+#endif /* CONFIG_MACH_MX31ADS */
+#endif /* CONFIG_IPIPE */
+
+static struct mxc_gpio_port *mxc_gpio_ports;
+static int gpio_table_size;
+
+/* Note: This driver assumes 32 GPIOs are handled in one register */
+
+static void _clear_gpio_irqstatus(struct mxc_gpio_port *port, u32 index)
+{
+	__raw_writel(1 << index, port->base + GPIO_ISR);
+}
+
+static void _set_gpio_irqenable(struct mxc_gpio_port *port, u32 index,
+				int enable)
+{
+	u32 l;
+
+	l = __raw_readl(port->base + GPIO_IMR);
+	l = (l & (~(1 << index))) | (!!enable << index);
+	__raw_writel(l, port->base + GPIO_IMR);
+}
+
+static void gpio_ack_irq(u32 irq)
+{
+	u32 gpio = irq_to_gpio(irq);
+	_clear_gpio_irqstatus(&mxc_gpio_ports[gpio / 32], gpio & 0x1f);
+}
+
+static void gpio_mask_irq(u32 irq)
+{
+	u32 gpio = irq_to_gpio(irq);
+	_set_gpio_irqenable(&mxc_gpio_ports[gpio / 32], gpio & 0x1f, 0);
+}
+
+static void gpio_unmask_irq(u32 irq)
+{
+	u32 gpio = irq_to_gpio(irq);
+	_set_gpio_irqenable(&mxc_gpio_ports[gpio / 32], gpio & 0x1f, 1);
+}
+
+static int gpio_set_irq_type(u32 irq, u32 type)
+{
+	u32 gpio = irq_to_gpio(irq);
+	struct mxc_gpio_port *port = &mxc_gpio_ports[gpio / 32];
+	u32 bit, val;
+	int edge;
+	void __iomem *reg = port->base;
+
+	switch (type) {
+	case IRQ_TYPE_EDGE_RISING:
+		edge = GPIO_INT_RISE_EDGE;
+		break;
+	case IRQ_TYPE_EDGE_FALLING:
+		edge = GPIO_INT_FALL_EDGE;
+		break;
+	case IRQ_TYPE_LEVEL_LOW:
+		edge = GPIO_INT_LOW_LEV;
+		break;
+	case IRQ_TYPE_LEVEL_HIGH:
+		edge = GPIO_INT_HIGH_LEV;
+		break;
+	default:	/* this includes IRQ_TYPE_EDGE_BOTH */
+		return -EINVAL;
+	}
+
+	reg += GPIO_ICR1 + ((gpio & 0x10) >> 2); /* lower or upper register */
+	bit = gpio & 0xf;
+	val = __raw_readl(reg) & ~(0x3 << (bit << 1));
+	__raw_writel(val | (edge << (bit << 1)), reg);
+	_clear_gpio_irqstatus(port, gpio & 0x1f);
+
+	return 0;
+}
+
+/* handle n interrupts in one status register */
+static void mxc_gpio_irq_handler(struct mxc_gpio_port *port, u32 irq_stat)
+{
+	u32 gpio_irq_no;
+
+	gpio_irq_no = port->virtual_irq_start;
+	for (; irq_stat != 0; irq_stat >>= 1, gpio_irq_no++) {
+
+		if ((irq_stat & 1) == 0)
+			continue;
+
+		BUG_ON(!(irq_desc[gpio_irq_no].handle_irq));
+		irq_desc[gpio_irq_no].handle_irq(gpio_irq_no,
+				&irq_desc[gpio_irq_no]);
+	}
+}
+
+#ifdef CONFIG_ARCH_MX3
+/* MX3 has one interrupt *per* gpio port */
+static void mx3_gpio_irq_handler(u32 irq, struct irq_desc *desc)
+{
+	u32 irq_stat;
+	struct mxc_gpio_port *port = (struct mxc_gpio_port *)get_irq_data(irq);
+
+	irq_stat = __raw_readl(port->base + GPIO_ISR) &
+			__raw_readl(port->base + GPIO_IMR);
+	BUG_ON(!irq_stat);
+	mxc_gpio_irq_handler(port, irq_stat);
+}
+
+#ifdef CONFIG_IPIPE
+void __ipipe_mach_demux_irq(unsigned irq, struct pt_regs *regs)
+{
+	struct mxc_gpio_port *port = (struct mxc_gpio_port *)get_irq_data(irq);
+	u32 irq_stat, gpio_irq_no;
+
+	irq_stat = __raw_readl(port->base + GPIO_ISR) &
+			__raw_readl(port->base + GPIO_IMR);
+	BUG_ON(!irq_stat);
+
+	gpio_irq_no = port->virtual_irq_start;
+ 
+	for (; irq_stat != 0; irq_stat >>= 1, gpio_irq_no++) {
+                if ((irq_stat & 1) == 0)
+                        continue;
+
+#ifdef CONFIG_MACH_MX31ADS
+		if (gpio_irq_no == EXPIO_PARENT_INT) {
+			extern void mx31ads_demux_expio(u32,
+							struct pt_regs *regs);
+			mx31ads_demux_expio(gpio_irq_no, regs);
+			continue;
+		}
+#endif /* CONFIG_MACH_MX31ADS */
+
+		__ipipe_handle_irq(gpio_irq_no, regs);
+        }
+}
+#endif /* CONFIG_IPIPE */
+#endif /* CONFIG_ARCH_MX3 */
+
+#ifdef CONFIG_ARCH_MX2
+/* MX2 has one interrupt *for all* gpio ports */
+static void mx2_gpio_irq_handler(u32 irq, struct irq_desc *desc)
+{
+	int i;
+	u32 irq_msk, irq_stat;
+	struct mxc_gpio_port *port = (struct mxc_gpio_port *)get_irq_data(irq);
+
+	/* walk through all interrupt status registers */
+	for (i = 0; i < gpio_table_size; i++) {
+		irq_msk = __raw_readl(port[i].base + GPIO_IMR);
+		if (!irq_msk)
+			continue;
+
+		irq_stat = __raw_readl(port[i].base + GPIO_ISR) & irq_msk;
+		if (irq_stat)
+			mxc_gpio_irq_handler(&port[i], irq_stat);
+	}
+}
+
+#ifdef CONFIG_IPIPE
+void __ipipe_mach_demux_irq(unsigned irq, struct pt_regs *regs)
+{
+	struct mxc_gpio_port *port = (struct mxc_gpio_port *)get_irq_data(irq);
+	u32 irq_msk, irq_stat, gpio_irq_no;
+	int i;
+
+	for (i = 0; i < gpio_table_size; i++) {
+		irq_msk = __raw_readl(port->base + GPIO_IMR);
+		if (!irq_msk)
+			continue;
+
+		irq_stat = __raw_readl(port->base + GPIO_ISR) & irq_msk;
+		
+		gpio_irq_no = port[i].virtual_irq_start;
+ 
+		for (; irq_stat != 0; irq_stat >>= 1, gpio_irq_no++) {
+			if ((irq_stat & 1) == 0)
+				continue;
+
+			__ipipe_handle_irq(gpio_irq_no, regs);
+		}
+	}
+}
+#endif /* CONFIG_IPIPE */
+#endif /* CONFIG_ARCH_MX2 */
+
+static struct irq_chip gpio_irq_chip = {
+	.ack = gpio_ack_irq,
+	.mask = gpio_mask_irq,
+	.unmask = gpio_unmask_irq,
+	.set_type = gpio_set_irq_type,
+};
+
+static void _set_gpio_direction(struct gpio_chip *chip, unsigned offset,
+				int dir)
+{
+	struct mxc_gpio_port *port =
+		container_of(chip, struct mxc_gpio_port, chip);
+	u32 l;
+
+	l = __raw_readl(port->base + GPIO_GDIR);
+	if (dir)
+		l |= 1 << offset;
+	else
+		l &= ~(1 << offset);
+	__raw_writel(l, port->base + GPIO_GDIR);
+}
+
+static void mxc_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
+{
+	struct mxc_gpio_port *port =
+		container_of(chip, struct mxc_gpio_port, chip);
+	void __iomem *reg = port->base + GPIO_DR;
+	u32 l;
+
+	l = (__raw_readl(reg) & (~(1 << offset))) | (value << offset);
+	__raw_writel(l, reg);
+}
+
+static int mxc_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	struct mxc_gpio_port *port =
+		container_of(chip, struct mxc_gpio_port, chip);
+
+	return (__raw_readl(port->base + GPIO_DR) >> offset) & 1;
+}
+
+static int mxc_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
+{
+	_set_gpio_direction(chip, offset, 0);
+	return 0;
+}
+
+static int mxc_gpio_direction_output(struct gpio_chip *chip,
+				     unsigned offset, int value)
+{
+	_set_gpio_direction(chip, offset, 1);
+	mxc_gpio_set(chip, offset, value);
+	return 0;
+}
+
+int __init mxc_gpio_init(struct mxc_gpio_port *port, int cnt)
+{
+	int i, j;
+
+	/* save for local usage */
+	mxc_gpio_ports = port;
+	gpio_table_size = cnt;
+
+	printk(KERN_INFO "MXC GPIO hardware\n");
+
+	for (i = 0; i < cnt; i++) {
+		/* disable the interrupt and clear the status */
+		__raw_writel(0, port[i].base + GPIO_IMR);
+		__raw_writel(~0, port[i].base + GPIO_ISR);
+		for (j = port[i].virtual_irq_start;
+			j < port[i].virtual_irq_start + 32; j++) {
+			set_irq_chip(j, &gpio_irq_chip);
+			set_irq_handler(j, handle_edge_irq);
+			set_irq_flags(j, IRQF_VALID);
+		}
+
+		/* register gpio chip */
+		port[i].chip.direction_input = mxc_gpio_direction_input;
+		port[i].chip.direction_output = mxc_gpio_direction_output;
+		port[i].chip.get = mxc_gpio_get;
+		port[i].chip.set = mxc_gpio_set;
+		port[i].chip.base = i * 32;
+		port[i].chip.ngpio = 32;
+
+		/* its a serious configuration bug when it fails */
+		BUG_ON( gpiochip_add(&port[i].chip) < 0 );
+
+#ifdef CONFIG_ARCH_MX3
+		/* setup one handler for each entry */
+		set_irq_chained_handler(port[i].irq, mx3_gpio_irq_handler);
+		set_irq_data(port[i].irq, &port[i]);
+#endif
+	}
+
+#ifdef CONFIG_ARCH_MX2
+	/* setup one handler for all GPIO interrupts */
+	set_irq_chained_handler(port[0].irq, mx2_gpio_irq_handler);
+	set_irq_data(port[0].irq, port);
+#endif
+	return 0;
+}
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/plat-mxc/iomux-mx1-mx2.c ipipe-2.6.26-mxc/arch/arm/plat-mxc/iomux-mx1-mx2.c
--- adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/plat-mxc/iomux-mx1-mx2.c	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/arch/arm/plat-mxc/iomux-mx1-mx2.c	2008-10-19 15:15:34.000000000 +0200
@@ -0,0 +1,156 @@
+/*
+ *  arch/arm/mach-mxc/generic.c
+ *
+ *  author: Sascha Hauer
+ *  Created: april 20th, 2004
+ *  Copyright: Synertronixx GmbH
+ *
+ *  Common code for i.MX machines
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/gpio.h>
+
+#include <asm/hardware.h>
+#include <asm/mach/map.h>
+#include <asm/arch/iomux-mx1-mx2.h>
+
+void mxc_gpio_mode(int gpio_mode)
+{
+	unsigned int pin = gpio_mode & GPIO_PIN_MASK;
+	unsigned int port = (gpio_mode & GPIO_PORT_MASK) >> GPIO_PORT_SHIFT;
+	unsigned int ocr = (gpio_mode & GPIO_OCR_MASK) >> GPIO_OCR_SHIFT;
+	unsigned int tmp;
+
+	/* Pullup enable */
+	tmp = __raw_readl(VA_GPIO_BASE + MXC_PUEN(port));
+	if (gpio_mode & GPIO_PUEN)
+		tmp |= (1 << pin);
+	else
+		tmp &= ~(1 << pin);
+	__raw_writel(tmp, VA_GPIO_BASE + MXC_PUEN(port));
+
+	/* Data direction */
+	tmp = __raw_readl(VA_GPIO_BASE + MXC_DDIR(port));
+	if (gpio_mode & GPIO_OUT)
+		tmp |= 1 << pin;
+	else
+		tmp &= ~(1 << pin);
+	__raw_writel(tmp, VA_GPIO_BASE + MXC_DDIR(port));
+
+	/* Primary / alternate function */
+	tmp = __raw_readl(VA_GPIO_BASE + MXC_GPR(port));
+	if (gpio_mode & GPIO_AF)
+		tmp |= (1 << pin);
+	else
+		tmp &= ~(1 << pin);
+	__raw_writel(tmp, VA_GPIO_BASE + MXC_GPR(port));
+
+	/* use as gpio? */
+	tmp = __raw_readl(VA_GPIO_BASE + MXC_GIUS(port));
+	if (gpio_mode & (GPIO_PF | GPIO_AF))
+		tmp &= ~(1 << pin);
+	else
+		tmp |= (1 << pin);
+	__raw_writel(tmp, VA_GPIO_BASE + MXC_GIUS(port));
+
+	if (pin < 16) {
+		tmp = __raw_readl(VA_GPIO_BASE + MXC_OCR1(port));
+		tmp &= ~(3 << (pin * 2));
+		tmp |= (ocr << (pin * 2));
+		__raw_writel(tmp, VA_GPIO_BASE + MXC_OCR1(port));
+
+		tmp = __raw_readl(VA_GPIO_BASE + MXC_ICONFA1(port));
+		tmp &= ~(3 << (pin * 2));
+		tmp |= ((gpio_mode >> GPIO_AOUT_SHIFT) & 3) << (pin * 2);
+		__raw_writel(tmp, VA_GPIO_BASE + MXC_ICONFA1(port));
+
+		tmp = __raw_readl(VA_GPIO_BASE + MXC_ICONFB1(port));
+		tmp &= ~(3 << (pin * 2));
+		tmp |= ((gpio_mode >> GPIO_BOUT_SHIFT) & 3) << (pin * 2);
+		__raw_writel(tmp, VA_GPIO_BASE + MXC_ICONFB1(port));
+	} else {
+		pin -= 16;
+
+		tmp = __raw_readl(VA_GPIO_BASE + MXC_OCR2(port));
+		tmp &= ~(3 << (pin * 2));
+		tmp |= (ocr << (pin * 2));
+		__raw_writel(tmp, VA_GPIO_BASE + MXC_OCR2(port));
+
+		tmp = __raw_readl(VA_GPIO_BASE + MXC_ICONFA2(port));
+		tmp &= ~(3 << (pin * 2));
+		tmp |= ((gpio_mode >> GPIO_AOUT_SHIFT) & 3) << (pin * 2);
+		__raw_writel(tmp, VA_GPIO_BASE + MXC_ICONFA2(port));
+
+		tmp = __raw_readl(VA_GPIO_BASE + MXC_ICONFB2(port));
+		tmp &= ~(3 << (pin * 2));
+		tmp |= ((gpio_mode >> GPIO_BOUT_SHIFT) & 3) << (pin * 2);
+		__raw_writel(tmp, VA_GPIO_BASE + MXC_ICONFB2(port));
+	}
+}
+EXPORT_SYMBOL(mxc_gpio_mode);
+
+int mxc_gpio_setup_multiple_pins(const int *pin_list, unsigned count,
+				int alloc_mode, const char *label)
+{
+	const int *p = pin_list;
+	int i;
+	unsigned gpio;
+	unsigned mode;
+
+	for (i = 0; i < count; i++) {
+		gpio = *p & (GPIO_PIN_MASK | GPIO_PORT_MASK);
+		mode = *p & ~(GPIO_PIN_MASK | GPIO_PORT_MASK);
+
+		if (gpio >= (GPIO_PORT_MAX + 1) * 32)
+			goto setup_error;
+
+		if (alloc_mode & MXC_GPIO_ALLOC_MODE_RELEASE)
+			gpio_free(gpio);
+		else if (!(alloc_mode & MXC_GPIO_ALLOC_MODE_NO_ALLOC))
+			if (gpio_request(gpio, label)
+			   && !(alloc_mode & MXC_GPIO_ALLOC_MODE_TRY_ALLOC))
+				goto setup_error;
+
+		if (!(alloc_mode & (MXC_GPIO_ALLOC_MODE_ALLOC_ONLY |
+				    MXC_GPIO_ALLOC_MODE_RELEASE)))
+			mxc_gpio_mode(gpio | mode);
+
+		p++;
+	}
+	return 0;
+
+setup_error:
+	if (alloc_mode & (MXC_GPIO_ALLOC_MODE_NO_ALLOC |
+	    MXC_GPIO_ALLOC_MODE_TRY_ALLOC))
+		return -EINVAL;
+
+	while (p != pin_list) {
+		p--;
+		gpio = *p & (GPIO_PIN_MASK | GPIO_PORT_MASK);
+		gpio_free(gpio);
+	}
+
+	return -EINVAL;
+}
+EXPORT_SYMBOL(mxc_gpio_setup_multiple_pins);
+
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/plat-mxc/irq.c ipipe-2.6.26-mxc/arch/arm/plat-mxc/irq.c
--- adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/plat-mxc/irq.c	2008-07-29 23:55:20.000000000 +0200
+++ ipipe-2.6.26-mxc/arch/arm/plat-mxc/irq.c	2008-10-19 15:15:34.000000000 +0200
@@ -1,24 +1,59 @@
 /*
- *  Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
  */
 
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/init.h>
-#include <linux/device.h>
-#include <linux/errno.h>
-#include <asm/hardware.h>
+#include <linux/irq.h>
 #include <asm/io.h>
-#include <asm/irq.h>
-#include <asm/mach/irq.h>
 #include <asm/arch/common.h>
 
+#define AVIC_BASE		IO_ADDRESS(AVIC_BASE_ADDR)
+#define AVIC_INTCNTL		(AVIC_BASE + 0x00)	/* int control reg */
+#define AVIC_NIMASK		(AVIC_BASE + 0x04)	/* int mask reg */
+#define AVIC_INTENNUM		(AVIC_BASE + 0x08)	/* int enable number reg */
+#define AVIC_INTDISNUM		(AVIC_BASE + 0x0C)	/* int disable number reg */
+#define AVIC_INTENABLEH		(AVIC_BASE + 0x10)	/* int enable reg high */
+#define AVIC_INTENABLEL		(AVIC_BASE + 0x14)	/* int enable reg low */
+#define AVIC_INTTYPEH		(AVIC_BASE + 0x18)	/* int type reg high */
+#define AVIC_INTTYPEL		(AVIC_BASE + 0x1C)	/* int type reg low */
+#define AVIC_NIPRIORITY7	(AVIC_BASE + 0x20)	/* norm int priority lvl7 */
+#define AVIC_NIPRIORITY6	(AVIC_BASE + 0x24)	/* norm int priority lvl6 */
+#define AVIC_NIPRIORITY5	(AVIC_BASE + 0x28)	/* norm int priority lvl5 */
+#define AVIC_NIPRIORITY4	(AVIC_BASE + 0x2C)	/* norm int priority lvl4 */
+#define AVIC_NIPRIORITY3	(AVIC_BASE + 0x30)	/* norm int priority lvl3 */
+#define AVIC_NIPRIORITY2	(AVIC_BASE + 0x34)	/* norm int priority lvl2 */
+#define AVIC_NIPRIORITY1	(AVIC_BASE + 0x38)	/* norm int priority lvl1 */
+#define AVIC_NIPRIORITY0	(AVIC_BASE + 0x3C)	/* norm int priority lvl0 */
+#define AVIC_NIVECSR		(AVIC_BASE + 0x40)	/* norm int vector/status */
+#define AVIC_FIVECSR		(AVIC_BASE + 0x44)	/* fast int vector/status */
+#define AVIC_INTSRCH		(AVIC_BASE + 0x48)	/* int source reg high */
+#define AVIC_INTSRCL		(AVIC_BASE + 0x4C)	/* int source reg low */
+#define AVIC_INTFRCH		(AVIC_BASE + 0x50)	/* int force reg high */
+#define AVIC_INTFRCL		(AVIC_BASE + 0x54)	/* int force reg low */
+#define AVIC_NIPNDH		(AVIC_BASE + 0x58)	/* norm int pending high */
+#define AVIC_NIPNDL		(AVIC_BASE + 0x5C)	/* norm int pending low */
+#define AVIC_FIPNDH		(AVIC_BASE + 0x60)	/* fast int pending high */
+#define AVIC_FIPNDL		(AVIC_BASE + 0x64)	/* fast int pending low */
+
+#define SYSTEM_PREV_REG		IO_ADDRESS(IIM_BASE_ADDR + 0x20)
+#define SYSTEM_SREV_REG		IO_ADDRESS(IIM_BASE_ADDR + 0x24)
+#define IIM_PROD_REV_SH		3
+#define IIM_PROD_REV_LEN	5
+
 /* Disable interrupt number "irq" in the AVIC */
 static void mxc_mask_irq(unsigned int irq)
 {
@@ -32,7 +67,10 @@ static void mxc_unmask_irq(unsigned int 
 }
 
 static struct irq_chip mxc_avic_chip = {
+#ifdef CONFIG_IPIPE
 	.mask_ack = mxc_mask_irq,
+#endif /* CONFIG_IPIPE */
+	.ack = mxc_mask_irq,
 	.mask = mxc_mask_irq,
 	.unmask = mxc_unmask_irq,
 };
@@ -71,5 +109,8 @@ void __init mxc_init_irq(void)
 	reg |= (0xF << 28);
 	__raw_writel(reg, AVIC_NIPRIORITY6);
 
+	/* init architectures chained interrupt handler */
+	mxc_register_gpios();
+
 	printk(KERN_INFO "MXC IRQ initialized\n");
 }
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/plat-mxc/Kconfig ipipe-2.6.26-mxc/arch/arm/plat-mxc/Kconfig
--- adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/plat-mxc/Kconfig	2008-07-29 23:55:20.000000000 +0200
+++ ipipe-2.6.26-mxc/arch/arm/plat-mxc/Kconfig	2008-10-19 15:15:34.000000000 +0200
@@ -3,9 +3,14 @@ if ARCH_MXC
 menu "Freescale MXC Implementations"
 
 choice
-	prompt "MXC/iMX System Type"
+	prompt "MXC/iMX Base Type"
 	default ARCH_MX3
 
+config ARCH_MX2
+	bool "MX2-based"
+	help
+	  This enables support for systems based on the Freescale i.MX2 family
+
 config ARCH_MX3
 	bool "MX3-based"
 	help
@@ -13,6 +18,7 @@ config ARCH_MX3
 
 endchoice
 
+source "arch/arm/mach-mx2/Kconfig"
 source "arch/arm/mach-mx3/Kconfig"
 
 endmenu
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/plat-mxc/Makefile ipipe-2.6.26-mxc/arch/arm/plat-mxc/Makefile
--- adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/plat-mxc/Makefile	2008-07-29 23:55:20.000000000 +0200
+++ ipipe-2.6.26-mxc/arch/arm/plat-mxc/Makefile	2008-10-19 15:15:34.000000000 +0200
@@ -3,4 +3,6 @@
 #
 
 # Common support
-obj-y := irq.o
+obj-y := irq.o clock.o gpio.o time.o
+
+obj-$(CONFIG_ARCH_MX2) += iomux-mx1-mx2.o
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/plat-mxc/time.c ipipe-2.6.26-mxc/arch/arm/plat-mxc/time.c
--- adeos-ipipe-2.6.26-arm-1.11-02/arch/arm/plat-mxc/time.c	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/arch/arm/plat-mxc/time.c	2008-10-19 15:52:12.000000000 +0200
@@ -0,0 +1,388 @@
+/*
+ *  linux/arch/arm/plat-mxc/time.c
+ *
+ *  Copyright (C) 2000-2001 Deep Blue Solutions
+ *  Copyright (C) 2002 Shane Nay (shane@minirl.com)
+ *  Copyright (C) 2006-2007 Pavel Pisa (ppisa@pikron.com)
+ *  Copyright (C) 2008 Juergen Beisert (kernel@pengutronix.de)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ */
+
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/clockchips.h>
+#include <linux/clk.h>
+
+#include <asm/hardware.h>
+#include <asm/mach/time.h>
+#include <asm/arch/common.h>
+#include <asm/arch/mxc_timer.h>
+
+#ifdef CONFIG_IPIPE
+#ifdef CONFIG_NO_IDLE_HZ
+#error "dynamic tick timer not yet supported with IPIPE"
+#endif /* CONFIG_NO_IDLE_HZ */
+int __ipipe_mach_timerint = TIMER_INTERRUPT;
+EXPORT_SYMBOL(__ipipe_mach_timerint);
+
+int __ipipe_mach_timerstolen = 0;
+EXPORT_SYMBOL(__ipipe_mach_timerstolen);
+
+unsigned int __ipipe_mach_ticks_per_jiffy = LATCH;
+EXPORT_SYMBOL(__ipipe_mach_ticks_per_jiffy);
+
+static int mxc_timer_initialized;
+static unsigned mxc_min_delay;
+
+union tsc_reg {
+#ifdef __BIG_ENDIAN
+	struct {
+		unsigned long high;
+		unsigned long low;
+	};
+#else /* __LITTLE_ENDIAN */
+	struct {
+		unsigned long low;
+		unsigned long high;
+	};
+#endif /* __LITTLE_ENDIAN */
+	unsigned long long full;
+};
+
+#ifdef CONFIG_SMP
+static union tsc_reg tsc[NR_CPUS];
+
+void __ipipe_mach_get_tscinfo(struct __ipipe_tscinfo *info)
+{
+	info->type = IPIPE_TSC_TYPE_NONE;
+}
+
+#else /* !CONFIG_SMP */
+static union tsc_reg *tsc;
+
+void __ipipe_mach_get_tscinfo(struct __ipipe_tscinfo *info)
+{
+	info->type = IPIPE_TSC_TYPE_FREERUNNING;
+#ifdef CONFIG_ARCH_IMX
+	info->u.fr.counter = (unsigned *) (TM1_BASE_ADDR + MXC_TCN);
+#elif defined(CONFIG_ARCH_MX2) || defined(CONFIG_ARCH_MX3)
+	info->u.fr.counter = (unsigned *) (GPT1_BASE_ADDR + MXC_TCN);
+#else
+#error "Unknown MXC platform"
+#endif
+	info->u.fr.mask = 0xffffffff;
+	info->u.fr.tsc = &tsc->full;
+}
+#endif /* !CONFIG_SMP */
+
+static void ipipe_mach_update_tsc(void);
+#endif /* CONFIG_IPIPE */
+
+static struct clock_event_device clockevent_mxc;
+static enum clock_event_mode clockevent_mode = CLOCK_EVT_MODE_UNUSED;
+
+/* clock source for the timer */
+static struct clk *timer_clk;
+
+/* clock source */
+
+static cycle_t mxc_get_cycles(void)
+{
+	return __raw_readl(TIMER_BASE + MXC_TCN);
+}
+
+static struct clocksource clocksource_mxc = {
+	.name 		= "mxc_timer1",
+	.rating		= 200,
+	.read		= mxc_get_cycles,
+	.mask		= CLOCKSOURCE_MASK(32),
+	.shift 		= 20,
+	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+static int __init mxc_clocksource_init(void)
+{
+	unsigned int clock;
+
+	clock = clk_get_rate(timer_clk);
+#ifdef CONFIG_IPIPE
+	__ipipe_mach_ticks_per_jiffy = (clock + HZ/2) / HZ;
+#endif /* CONFIG_IPIPE */
+
+	clocksource_mxc.mult = clocksource_hz2mult(clock,
+					clocksource_mxc.shift);
+	clocksource_register(&clocksource_mxc);
+
+	return 0;
+}
+
+/* clock event */
+
+static int mxc_set_next_event(unsigned long evt,
+			      struct clock_event_device *unused)
+{
+	unsigned long tcmp;
+
+	tcmp = __raw_readl(TIMER_BASE + MXC_TCN) + evt;
+	__raw_writel(tcmp, TIMER_BASE + MXC_TCMP);
+
+	return (int)(tcmp - __raw_readl(TIMER_BASE + MXC_TCN)) < 0 ?
+				-ETIME : 0;
+}
+
+#ifdef DEBUG
+static const char *clock_event_mode_label[] = {
+	[CLOCK_EVT_MODE_PERIODIC] = "CLOCK_EVT_MODE_PERIODIC",
+	[CLOCK_EVT_MODE_ONESHOT]  = "CLOCK_EVT_MODE_ONESHOT",
+	[CLOCK_EVT_MODE_SHUTDOWN] = "CLOCK_EVT_MODE_SHUTDOWN",
+	[CLOCK_EVT_MODE_UNUSED]   = "CLOCK_EVT_MODE_UNUSED"
+};
+#endif /* DEBUG */
+
+static void mxc_set_mode(enum clock_event_mode mode,
+				struct clock_event_device *evt)
+{
+	unsigned long flags;
+
+	/*
+	 * The timer interrupt generation is disabled at least
+	 * for enough time to call mxc_set_next_event()
+	 */
+	local_irq_save(flags);
+
+	/* Disable interrupt in GPT module */
+	gpt_irq_disable();
+
+	if (mode != clockevent_mode) {
+		/* Set event time into far-far future */
+		__raw_writel(__raw_readl(TIMER_BASE + MXC_TCN) - 3,
+				TIMER_BASE + MXC_TCMP);
+		/* Clear pending interrupt */
+		gpt_irq_acknowledge();
+	}
+
+#ifdef DEBUG
+	printk(KERN_INFO "mxc_set_mode: changing mode from %s to %s\n",
+		clock_event_mode_label[clockevent_mode],
+		clock_event_mode_label[mode]);
+#endif /* DEBUG */
+
+	/* Remember timer mode */
+	clockevent_mode = mode;
+	local_irq_restore(flags);
+
+	switch (mode) {
+	case CLOCK_EVT_MODE_PERIODIC:
+		printk(KERN_ERR"mxc_set_mode: Periodic mode is not "
+				"supported for i.MX\n");
+		break;
+	case CLOCK_EVT_MODE_ONESHOT:
+	/*
+	 * Do not put overhead of interrupt enable/disable into
+	 * mxc_set_next_event(), the core has about 4 minutes
+	 * to call mxc_set_next_event() or shutdown clock after
+	 * mode switching
+	 */
+		local_irq_save(flags);
+		gpt_irq_enable();
+		local_irq_restore(flags);
+		break;
+	case CLOCK_EVT_MODE_SHUTDOWN:
+	case CLOCK_EVT_MODE_UNUSED:
+	case CLOCK_EVT_MODE_RESUME:
+		/* Left event sources disabled, no more interrupts appear */
+		break;
+	}
+}
+
+/*
+ * IRQ handler for the timer
+ */
+static irqreturn_t mxc_timer_interrupt(int irq, void *dev_id)
+{
+	struct clock_event_device *evt = &clockevent_mxc;
+	uint32_t tstat;
+
+	tstat = __raw_readl(TIMER_BASE + MXC_TSTAT);
+
+#ifndef CONFIG_IPIPE
+	gpt_irq_acknowledge();
+#else /* !CONFIG_IPIPE */
+	ipipe_mach_update_tsc();
+#endif /* !CONFIG_IPIPE */
+
+	evt->event_handler(evt);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction mxc_timer_irq = {
+	.name		= "i.MX Timer Tick",
+	.flags		= IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
+	.handler	= mxc_timer_interrupt,
+};
+
+static struct clock_event_device clockevent_mxc = {
+	.name		= "mxc_timer1",
+	.features	= CLOCK_EVT_FEAT_ONESHOT,
+	.shift		= 32,
+	.set_mode	= mxc_set_mode,
+	.set_next_event	= mxc_set_next_event,
+	.rating		= 200,
+};
+
+static int __init mxc_clockevent_init(void)
+{
+	unsigned int clock;
+
+	clock = clk_get_rate(timer_clk);
+
+	clockevent_mxc.mult = div_sc(clock, NSEC_PER_SEC,
+					clockevent_mxc.shift);
+	clockevent_mxc.max_delta_ns =
+			clockevent_delta2ns(0xfffffffe, &clockevent_mxc);
+	clockevent_mxc.min_delta_ns =
+			clockevent_delta2ns(0xff, &clockevent_mxc);
+
+	clockevent_mxc.cpumask = cpumask_of_cpu(0);
+
+	clockevents_register_device(&clockevent_mxc);
+
+	return 0;
+}
+
+void __init mxc_timer_init(const char *clk_timer)
+{
+	timer_clk = clk_get(NULL, clk_timer);
+	if (!timer_clk) {
+		printk(KERN_ERR"Cannot determine timer clock. Giving up.\n");
+		return;
+	}
+
+	clk_enable(timer_clk);
+
+	/*
+	 * Initialise to a known state (all timers off, and timing reset)
+	 */
+	__raw_writel(0, TIMER_BASE + MXC_TCTL);
+	__raw_writel(0, TIMER_BASE + MXC_TPRER); /* see datasheet note */
+
+	__raw_writel(TCTL_FRR |	/* free running */
+		     TCTL_VAL |	/* set clocksource and arch specific bits */
+		     TCTL_TEN,	/* start the timer */
+		     TIMER_BASE + MXC_TCTL);
+
+	/* init and register the timer to the framework */
+	mxc_clocksource_init();
+	mxc_clockevent_init();
+
+	/* Make irqs happen */
+	setup_irq(TIMER_INTERRUPT, &mxc_timer_irq);
+
+#ifdef CONFIG_IPIPE
+#ifndef CONFIG_SMP
+	tsc = (union tsc_reg *) __ipipe_tsc_area;
+	barrier();
+#endif /* CONFIG_SMP */
+
+	mxc_min_delay = ((ipipe_cpu_freq() + 500000) / 1000000) ?: 1;
+	mxc_timer_initialized = 1;
+#endif /* CONFIG_IPIPE */
+}
+
+#ifdef CONFIG_IPIPE
+int __ipipe_check_tickdev(const char *devname)
+{
+	return !strcmp(devname, clockevent_mxc.name);
+}
+
+void __ipipe_mach_acktimer(void)
+{
+	gpt_irq_acknowledge();
+}
+
+static void ipipe_mach_update_tsc(void)
+{
+	union tsc_reg *local_tsc;
+	unsigned long stamp, flags;
+
+	local_irq_save_hw(flags);
+	local_tsc = &tsc[ipipe_processor_id()];
+	stamp = __raw_readl(TIMER_BASE + MXC_TCN);
+	if (unlikely(stamp < local_tsc->low))
+		/* 32 bit counter wrapped, increment high word. */
+		local_tsc->high++;
+	local_tsc->low = stamp;
+	local_irq_restore_hw(flags);
+}
+
+notrace unsigned long long __ipipe_mach_get_tsc(void)
+{
+	if (likely(mxc_timer_initialized)) {
+		union tsc_reg *local_tsc, result;
+		unsigned long stamp;
+
+		local_tsc = &tsc[ipipe_processor_id()];
+
+		__asm__ ("ldmia %1, %M0\n"
+			 : "=r"(result.full):
+			   "r"(local_tsc), "m"(*local_tsc));
+		barrier();
+		stamp = __raw_readl(TIMER_BASE + MXC_TCN);
+		if (unlikely(stamp < result.low))
+			/* 32 bit counter wrapped, increment high word. */
+			result.high++;
+		result.low = stamp;
+
+		return result.full;
+	}
+
+        return 0;
+}
+EXPORT_SYMBOL(__ipipe_mach_get_tsc);
+
+/*
+ * Reprogram the timer
+ */
+
+void __ipipe_mach_set_dec(unsigned long delay)
+{
+	if (likely(delay > mxc_min_delay)) {
+		unsigned long flags;
+
+		local_irq_save_hw(flags);
+		__raw_writel(__raw_readl(TIMER_BASE + MXC_TCN) + delay,
+			     TIMER_BASE + MXC_TCMP);
+		local_irq_restore_hw(flags);
+	} else
+		ipipe_trigger_irq(TIMER_INTERRUPT);
+}
+EXPORT_SYMBOL(__ipipe_mach_set_dec);
+
+void __ipipe_mach_release_timer(void)
+{
+	mxc_set_mode(clockevent_mxc.mode, &clockevent_mxc);
+	if (clockevent_mxc.mode == CLOCK_EVT_MODE_ONESHOT)
+		mxc_set_next_event(LATCH, &clockevent_mxc);
+}
+EXPORT_SYMBOL(__ipipe_mach_release_timer);
+
+unsigned long __ipipe_mach_get_dec(void)
+{
+	return __raw_readl(TIMER_BASE + MXC_TCMP)
+		- __raw_readl(TIMER_BASE + MXC_TCN);
+}
+#endif /* CONFIG_IPIPE */
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/drivers/net/cs89x0.c ipipe-2.6.26-mxc/drivers/net/cs89x0.c
--- adeos-ipipe-2.6.26-arm-1.11-02/drivers/net/cs89x0.c	2008-07-29 23:55:42.000000000 +0200
+++ ipipe-2.6.26-mxc/drivers/net/cs89x0.c	2008-10-19 15:15:34.000000000 +0200
@@ -194,6 +194,12 @@ static unsigned int cs8900_irq_map[] = {
 #define CIRRUS_DEFAULT_IRQ	VH_INTC_INT_NUM_CASCADED_INTERRUPT_1 /* Event inputs bank 1 - ID 35/bit 3 */
 static unsigned int netcard_portlist[] __used __initdata = {CIRRUS_DEFAULT_BASE, 0};
 static unsigned int cs8900_irq_map[] = {CIRRUS_DEFAULT_IRQ, 0, 0, 0};
+#elif defined(CONFIG_MACH_MX31ADS)
+#include <asm/arch/board-mx31ads.h>
+static unsigned int netcard_portlist[] __used __initdata = {
+	PBC_BASE_ADDRESS + PBC_CS8900A_IOBASE + 0x300, 0
+};
+static unsigned cs8900_irq_map[] = {EXPIO_INT_ENET_INT, 0, 0, 0};
 #else
 static unsigned int netcard_portlist[] __used __initdata =
    { 0x300, 0x320, 0x340, 0x360, 0x200, 0x220, 0x240, 0x260, 0x280, 0x2a0, 0x2c0, 0x2e0, 0};
@@ -802,7 +808,7 @@ cs89x0_probe1(struct net_device *dev, in
 	} else {
 		i = lp->isa_config & INT_NO_MASK;
 		if (lp->chip_type == CS8900) {
-#if defined(CONFIG_MACH_IXDP2351) || defined(CONFIG_ARCH_IXDP2X01) || defined(CONFIG_ARCH_PNX010X)
+#ifdef CONFIG_CS89x0_NONISA_IRQ
 		        i = cs8900_irq_map[0];
 #else
 			/* Translate the IRQ using the IRQ mapping table. */
@@ -1029,6 +1035,7 @@ skip_this_frame:
 
 void  __init reset_chip(struct net_device *dev)
 {
+#if !defined(CONFIG_MACH_MX31ADS)
 #if !defined(CONFIG_MACH_IXDP2351) && !defined(CONFIG_ARCH_IXDP2X01)
 	struct net_local *lp = netdev_priv(dev);
 	int ioaddr = dev->base_addr;
@@ -1057,6 +1064,7 @@ void  __init reset_chip(struct net_devic
 	reset_start_time = jiffies;
 	while( (readreg(dev, PP_SelfST) & INIT_DONE) == 0 && jiffies - reset_start_time < 2)
 		;
+#endif /* !CONFIG_MACH_MX31ADS */
 }
 
 
@@ -1304,7 +1312,7 @@ net_open(struct net_device *dev)
 	else
 #endif
 	{
-#if !defined(CONFIG_MACH_IXDP2351) && !defined(CONFIG_ARCH_IXDP2X01) && !defined(CONFIG_ARCH_PNX010X)
+#ifndef CONFIG_CS89x0_NONISA_IRQ
 		if (((1 << dev->irq) & lp->irq_map) == 0) {
 			printk(KERN_ERR "%s: IRQ %d is not in our map of allowable IRQs, which is %x\n",
                                dev->name, dev->irq, lp->irq_map);
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/drivers/net/Kconfig ipipe-2.6.26-mxc/drivers/net/Kconfig
--- adeos-ipipe-2.6.26-arm-1.11-02/drivers/net/Kconfig	2008-07-29 23:55:41.000000000 +0200
+++ ipipe-2.6.26-mxc/drivers/net/Kconfig	2008-10-19 15:15:34.000000000 +0200
@@ -1410,7 +1410,8 @@ config FORCEDETH_NAPI
 
 config CS89x0
 	tristate "CS89x0 support"
-	depends on NET_PCI && (ISA || MACH_IXDP2351 || ARCH_IXDP2X01 || ARCH_PNX010X)
+	depends on NET_ETHERNET && (ISA || EISA || MACH_IXDP2351 \
+		|| ARCH_IXDP2X01 || ARCH_PNX010X || MACH_MX31ADS)
 	---help---
 	  Support for CS89x0 chipset based Ethernet cards. If you have a
 	  network (Ethernet) card of this type, say Y and read the
@@ -1421,6 +1422,11 @@ config CS89x0
 	  To compile this driver as a module, choose M here. The module
 	  will be called cs89x0.
 
+config CS89x0_NONISA_IRQ
+	def_bool y
+	depends on CS89x0 != n
+	depends on MACH_IXDP2351 || ARCH_IXDP2X01 || ARCH_PNX010X || MACH_MX31ADS
+
 config TC35815
 	tristate "TOSHIBA TC35815 Ethernet support"
 	depends on NET_PCI && PCI && MIPS
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/drivers/serial/imx.c ipipe-2.6.26-mxc/drivers/serial/imx.c
--- adeos-ipipe-2.6.26-arm-1.11-02/drivers/serial/imx.c	2008-07-29 23:55:51.000000000 +0200
+++ ipipe-2.6.26-mxc/drivers/serial/imx.c	2008-10-19 15:15:34.000000000 +0200
@@ -40,6 +40,7 @@
 #include <linux/tty_flip.h>
 #include <linux/serial_core.h>
 #include <linux/serial.h>
+#include <linux/clk.h>
 
 #include <asm/io.h>
 #include <asm/irq.h>
@@ -61,6 +62,11 @@
 #define UBIR  0xa4 /* BRM Incremental Register */
 #define UBMR  0xa8 /* BRM Modulator Register */
 #define UBRC  0xac /* Baud Rate Count Register */
+#if defined CONFIG_ARCH_MX3 || defined CONFIG_ARCH_MX2
+#define ONEMS 0xb0 /* One Millisecond register */
+#define UTS   0xb4 /* UART Test Register */
+#endif
+#ifdef CONFIG_ARCH_IMX
 #define BIPR1 0xb0 /* Incremental Preset Register 1 */
 #define BIPR2 0xb4 /* Incremental Preset Register 2 */
 #define BIPR3 0xb8 /* Incremental Preset Register 3 */
@@ -70,6 +76,7 @@
 #define BMPR3 0xc8 /* BRM Modulator Register 3 */
 #define BMPR4 0xcc /* BRM Modulator Register 4 */
 #define UTS   0xd0 /* UART Test Register */
+#endif
 
 /* UART Control Register Bit Fields.*/
 #define  URXD_CHARRDY    (1<<15)
@@ -89,7 +96,12 @@
 #define  UCR1_RTSDEN     (1<<5)	 /* RTS delta interrupt enable */
 #define  UCR1_SNDBRK     (1<<4)	 /* Send break */
 #define  UCR1_TDMAEN     (1<<3)	 /* Transmitter ready DMA enable */
+#ifdef CONFIG_ARCH_IMX
 #define  UCR1_UARTCLKEN  (1<<2)	 /* UART clock enabled */
+#endif
+#if defined CONFIG_ARCH_MX3 || defined CONFIG_ARCH_MX2
+#define  UCR1_UARTCLKEN  (0)	 /* not present on mx2/mx3 */
+#endif
 #define  UCR1_DOZE       (1<<1)	 /* Doze */
 #define  UCR1_UARTEN     (1<<0)	 /* UART enabled */
 #define  UCR2_ESCI     	 (1<<15) /* Escape seq interrupt enable */
@@ -163,8 +175,19 @@
 #define  UTS_SOFTRST	 (1<<0)	 /* Software reset */
 
 /* We've been assigned a range on the "Low-density serial ports" major */
+#ifdef CONFIG_ARCH_IMX
 #define SERIAL_IMX_MAJOR	204
 #define MINOR_START		41
+#define DEV_NAME		"ttySMX"
+#define MAX_INTERNAL_IRQ	IMX_IRQS
+#endif
+
+#if defined CONFIG_ARCH_MX3 || defined CONFIG_ARCH_MX2
+#define SERIAL_IMX_MAJOR        207
+#define MINOR_START	        16
+#define DEV_NAME		"ttymxc"
+#define MAX_INTERNAL_IRQ	MXC_MAX_INT_LINES
+#endif
 
 /*
  * This determines how often we check the modem status signals
@@ -176,12 +199,15 @@
 
 #define DRIVER_NAME "IMX-uart"
 
+#define UART_NR 8
+
 struct imx_port {
 	struct uart_port	port;
 	struct timer_list	timer;
 	unsigned int		old_status;
 	int			txirq,rxirq,rtsirq;
 	int			have_rtscts:1;
+	struct clk		*clk;
 };
 
 /*
@@ -405,6 +431,26 @@ out:
 	return IRQ_HANDLED;
 }
 
+static irqreturn_t imx_int(int irq, void *dev_id)
+{
+	struct imx_port *sport = dev_id;
+	unsigned int sts;
+
+	sts = readl(sport->port.membase + USR1);
+
+	if (sts & USR1_RRDY)
+		imx_rxint(irq, dev_id);
+
+	if (sts & USR1_TRDY &&
+			readl(sport->port.membase + UCR1) & UCR1_TXMPTYEN)
+		imx_txint(irq, dev_id);
+
+	if (sts & USR1_RTSS)
+		imx_rtsint(irq, dev_id);
+
+	return IRQ_HANDLED;
+}
+
 /*
  * Return TIOCSER_TEMT when transmitter is not busy.
  */
@@ -477,7 +523,8 @@ static int imx_setup_ufcr(struct imx_por
 	 * RFDIV is set such way to satisfy requested uartclk value
 	 */
 	val = TXTL << 10 | RXTL;
-	ufcr_rfdiv = (imx_get_perclk1() + sport->port.uartclk / 2) / sport->port.uartclk;
+	ufcr_rfdiv = (clk_get_rate(sport->clk) + sport->port.uartclk / 2)
+			/ sport->port.uartclk;
 
 	if(!ufcr_rfdiv)
 		ufcr_rfdiv = 1;
@@ -509,21 +556,34 @@ static int imx_startup(struct uart_port 
 	writel(temp & ~UCR4_DREN, sport->port.membase + UCR4);
 
 	/*
-	 * Allocate the IRQ
+	 * Allocate the IRQ(s) i.MX1 has three interrupts whereas later
+	 * chips only have one interrupt.
 	 */
-	retval = request_irq(sport->rxirq, imx_rxint, 0,
-			     DRIVER_NAME, sport);
-	if (retval) goto error_out1;
+	if (sport->txirq > 0) {
+		retval = request_irq(sport->rxirq, imx_rxint, 0,
+				DRIVER_NAME, sport);
+		if (retval)
+			goto error_out1;
 
-	retval = request_irq(sport->txirq, imx_txint, 0,
-			     DRIVER_NAME, sport);
-	if (retval) goto error_out2;
+		retval = request_irq(sport->txirq, imx_txint, 0,
+				DRIVER_NAME, sport);
+		if (retval)
+			goto error_out2;
 
-	retval = request_irq(sport->rtsirq, imx_rtsint,
-			     (sport->rtsirq < IMX_IRQS) ? 0 :
+		retval = request_irq(sport->rtsirq, imx_rtsint,
+			     (sport->rtsirq < MAX_INTERNAL_IRQ) ? 0 :
 			       IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,
-			     DRIVER_NAME, sport);
-	if (retval) goto error_out3;
+				DRIVER_NAME, sport);
+		if (retval)
+			goto error_out3;
+	} else {
+		retval = request_irq(sport->port.irq, imx_int, 0,
+				DRIVER_NAME, sport);
+		if (retval) {
+			free_irq(sport->port.irq, sport);
+			goto error_out1;
+		}
+	}
 
 	/*
 	 * Finally, clear and enable interrupts
@@ -548,9 +608,11 @@ static int imx_startup(struct uart_port 
 	return 0;
 
 error_out3:
-	free_irq(sport->txirq, sport);
+	if (sport->txirq)
+		free_irq(sport->txirq, sport);
 error_out2:
-	free_irq(sport->rxirq, sport);
+	if (sport->rxirq)
+		free_irq(sport->rxirq, sport);
 error_out1:
 	return retval;
 }
@@ -568,9 +630,12 @@ static void imx_shutdown(struct uart_por
 	/*
 	 * Free the interrupts
 	 */
-	free_irq(sport->rtsirq, sport);
-	free_irq(sport->txirq, sport);
-	free_irq(sport->rxirq, sport);
+	if (sport->txirq > 0) {
+		free_irq(sport->rtsirq, sport);
+		free_irq(sport->txirq, sport);
+		free_irq(sport->rxirq, sport);
+	} else
+		free_irq(sport->port.irq, sport);
 
 	/*
 	 * Disable all interrupts, port and break condition.
@@ -589,6 +654,7 @@ imx_set_termios(struct uart_port *port, 
 	unsigned long flags;
 	unsigned int ucr2, old_ucr1, old_txrxen, baud, quot;
 	unsigned int old_csize = old ? old->c_cflag & CSIZE : CS8;
+	unsigned int div, num, denom, ufcr;
 
 	/*
 	 * If we don't support modem control lines, don't allow
@@ -634,7 +700,7 @@ imx_set_termios(struct uart_port *port, 
 	/*
 	 * Ask the core to calculate the divisor for us.
 	 */
-	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16);
+	baud = uart_get_baud_rate(port, termios, old, 50, port->uartclk / 16);
 	quot = uart_get_divisor(port, baud);
 
 	spin_lock_irqsave(&sport->port.lock, flags);
@@ -684,14 +750,41 @@ imx_set_termios(struct uart_port *port, 
 			sport->port.membase + UCR2);
 	old_txrxen &= (UCR2_TXEN | UCR2_RXEN);
 
-	/* set the baud rate. We assume uartclk = 16 MHz
-	 *
-	 * baud * 16   UBIR - 1
-	 * --------- = --------
-	 *  uartclk    UBMR - 1
-	 */
-	writel((baud / 100) - 1, sport->port.membase + UBIR);
-	writel(10000 - 1, sport->port.membase + UBMR);
+	div = sport->port.uartclk / (baud * 16);
+	if (div > 7)
+		div = 7;
+	if (!div)
+		div = 1;
+
+	num = baud;
+	denom = port->uartclk / div / 16;
+
+	/* shift num and denom right until they fit into 16 bits */
+	while (num > 0x10000 || denom > 0x10000) {
+		num >>= 1;
+		denom >>= 1;
+	}
+	if (num > 0)
+		num -= 1;
+	if (denom > 0)
+		denom -= 1;
+
+	writel(num, sport->port.membase + UBIR);
+	writel(denom, sport->port.membase + UBMR);
+
+	if (div == 7)
+		div = 6; /* 6 in RFDIV means divide by 7 */
+	else
+		div = 6 - div;
+
+	ufcr = readl(sport->port.membase + UFCR);
+	ufcr = (ufcr & (~UFCR_RFDIV)) |
+	    (div << 7);
+	writel(ufcr, sport->port.membase + UFCR);
+
+#ifdef ONEMS
+	writel(sport->port.uartclk / div / 1000, sport->port.membase + ONEMS);
+#endif
 
 	writel(old_ucr1, sport->port.membase + UCR1);
 
@@ -801,65 +894,7 @@ static struct uart_ops imx_pops = {
 	.verify_port	= imx_verify_port,
 };
 
-static struct imx_port imx_ports[] = {
-	{
-	.txirq  = UART1_MINT_TX,
-	.rxirq  = UART1_MINT_RX,
-	.rtsirq = UART1_MINT_RTS,
-	.port	= {
-		.type		= PORT_IMX,
-		.iotype		= UPIO_MEM,
-		.membase	= (void *)IMX_UART1_BASE,
-		.mapbase	= 0x00206000,
-		.irq		= UART1_MINT_RX,
-		.uartclk	= 16000000,
-		.fifosize	= 32,
-		.flags		= UPF_BOOT_AUTOCONF,
-		.ops		= &imx_pops,
-		.line		= 0,
-	},
-	}, {
-	.txirq  = UART2_MINT_TX,
-	.rxirq  = UART2_MINT_RX,
-	.rtsirq = UART2_MINT_RTS,
-	.port	= {
-		.type		= PORT_IMX,
-		.iotype		= UPIO_MEM,
-		.membase	= (void *)IMX_UART2_BASE,
-		.mapbase	= 0x00207000,
-		.irq		= UART2_MINT_RX,
-		.uartclk	= 16000000,
-		.fifosize	= 32,
-		.flags		= UPF_BOOT_AUTOCONF,
-		.ops		= &imx_pops,
-		.line		= 1,
-	},
-	}
-};
-
-/*
- * Setup the IMX serial ports.
- * Note also that we support "console=ttySMXx" where "x" is either 0 or 1.
- * Which serial port this ends up being depends on the machine you're
- * running this kernel on.  I'm not convinced that this is a good idea,
- * but that's the way it traditionally works.
- *
- */
-static void __init imx_init_ports(void)
-{
-	static int first = 1;
-	int i;
-
-	if (!first)
-		return;
-	first = 0;
-
-	for (i = 0; i < ARRAY_SIZE(imx_ports); i++) {
-		init_timer(&imx_ports[i].timer);
-		imx_ports[i].timer.function = imx_timeout;
-		imx_ports[i].timer.data     = (unsigned long)&imx_ports[i];
-	}
-}
+static struct imx_port *imx_ports[UART_NR];
 
 #ifdef CONFIG_SERIAL_IMX_CONSOLE
 static void imx_console_putchar(struct uart_port *port, int ch)
@@ -878,7 +913,7 @@ static void imx_console_putchar(struct u
 static void
 imx_console_write(struct console *co, const char *s, unsigned int count)
 {
-	struct imx_port *sport = &imx_ports[co->index];
+	struct imx_port *sport = imx_ports[co->index];
 	unsigned int old_ucr1, old_ucr2;
 
 	/*
@@ -944,7 +979,7 @@ imx_console_get_options(struct imx_port 
 		else
 			ucfr_rfdiv = 6 - ucfr_rfdiv;
 
-		uartclk = imx_get_perclk1();
+		uartclk = clk_get_rate(sport->clk);
 		uartclk /= ucfr_rfdiv;
 
 		{	/*
@@ -984,7 +1019,7 @@ imx_console_setup(struct console *co, ch
 	 */
 	if (co->index == -1 || co->index >= ARRAY_SIZE(imx_ports))
 		co->index = 0;
-	sport = &imx_ports[co->index];
+	sport = imx_ports[co->index];
 
 	if (options)
 		uart_parse_options(options, &baud, &parity, &bits, &flow);
@@ -998,7 +1033,7 @@ imx_console_setup(struct console *co, ch
 
 static struct uart_driver imx_reg;
 static struct console imx_console = {
-	.name		= "ttySMX",
+	.name		= DEV_NAME,
 	.write		= imx_console_write,
 	.device		= uart_console_device,
 	.setup		= imx_console_setup,
@@ -1007,14 +1042,6 @@ static struct console imx_console = {
 	.data		= &imx_reg,
 };
 
-static int __init imx_rs_console_init(void)
-{
-	imx_init_ports();
-	register_console(&imx_console);
-	return 0;
-}
-console_initcall(imx_rs_console_init);
-
 #define IMX_CONSOLE	&imx_console
 #else
 #define IMX_CONSOLE	NULL
@@ -1023,7 +1050,7 @@ console_initcall(imx_rs_console_init);
 static struct uart_driver imx_reg = {
 	.owner          = THIS_MODULE,
 	.driver_name    = DRIVER_NAME,
-	.dev_name       = "ttySMX",
+	.dev_name       = DEV_NAME,
 	.major          = SERIAL_IMX_MAJOR,
 	.minor          = MINOR_START,
 	.nr             = ARRAY_SIZE(imx_ports),
@@ -1050,29 +1077,98 @@ static int serial_imx_resume(struct plat
         return 0;
 }
 
-static int serial_imx_probe(struct platform_device *dev)
+static int serial_imx_probe(struct platform_device *pdev)
 {
+	struct imx_port *sport;
 	struct imxuart_platform_data *pdata;
+	void __iomem *base;
+	int ret = 0;
+	struct resource *res;
 
-	imx_ports[dev->id].port.dev = &dev->dev;
+	sport = kzalloc(sizeof(*sport), GFP_KERNEL);
+	if (!sport)
+		return -ENOMEM;
 
-	pdata = (struct imxuart_platform_data *)dev->dev.platform_data;
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		ret = -ENODEV;
+		goto free;
+	}
+
+	base = ioremap(res->start, PAGE_SIZE);
+	if (!base) {
+		ret = -ENOMEM;
+		goto free;
+	}
+
+	sport->port.dev = &pdev->dev;
+	sport->port.mapbase = res->start;
+	sport->port.membase = base;
+	sport->port.type = PORT_IMX,
+	sport->port.iotype = UPIO_MEM;
+	sport->port.irq = platform_get_irq(pdev, 0);
+	sport->rxirq = platform_get_irq(pdev, 0);
+	sport->txirq = platform_get_irq(pdev, 1);
+	sport->rtsirq = platform_get_irq(pdev, 2);
+	sport->port.fifosize = 32;
+	sport->port.ops = &imx_pops;
+	sport->port.flags = UPF_BOOT_AUTOCONF;
+	sport->port.line = pdev->id;
+	init_timer(&sport->timer);
+	sport->timer.function = imx_timeout;
+	sport->timer.data     = (unsigned long)sport;
+
+	sport->clk = clk_get(&pdev->dev, "uart_clk");
+	if (IS_ERR(sport->clk)) {
+		ret = PTR_ERR(sport->clk);
+		goto unmap;
+	}
+	clk_enable(sport->clk);
+
+	sport->port.uartclk = clk_get_rate(sport->clk);
+
+	imx_ports[pdev->id] = sport;
+
+	pdata = pdev->dev.platform_data;
 	if(pdata && (pdata->flags & IMXUART_HAVE_RTSCTS))
-		imx_ports[dev->id].have_rtscts = 1;
+		sport->have_rtscts = 1;
+
+	if (pdata->init)
+		pdata->init(pdev);
+
+	uart_add_one_port(&imx_reg, &sport->port);
+	platform_set_drvdata(pdev, &sport->port);
 
-	uart_add_one_port(&imx_reg, &imx_ports[dev->id].port);
-	platform_set_drvdata(dev, &imx_ports[dev->id]);
 	return 0;
+unmap:
+	iounmap(sport->port.membase);
+free:
+	kfree(sport);
+
+	return ret;
 }
 
-static int serial_imx_remove(struct platform_device *dev)
+static int serial_imx_remove(struct platform_device *pdev)
 {
-	struct imx_port *sport = platform_get_drvdata(dev);
+	struct imxuart_platform_data *pdata;
+	struct imx_port *sport = platform_get_drvdata(pdev);
 
-	platform_set_drvdata(dev, NULL);
+	pdata = pdev->dev.platform_data;
 
-	if (sport)
+	platform_set_drvdata(pdev, NULL);
+
+	if (sport) {
 		uart_remove_one_port(&imx_reg, &sport->port);
+		clk_put(sport->clk);
+	}
+
+	clk_disable(sport->clk);
+
+	if (pdata->exit)
+		pdata->exit(pdev);
+
+	iounmap(sport->port.membase);
+	kfree(sport);
 
 	return 0;
 }
@@ -1095,8 +1191,6 @@ static int __init imx_serial_init(void)
 
 	printk(KERN_INFO "Serial: IMX driver\n");
 
-	imx_init_ports();
-
 	ret = uart_register_driver(&imx_reg);
 	if (ret)
 		return ret;
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/drivers/serial/Kconfig ipipe-2.6.26-mxc/drivers/serial/Kconfig
--- adeos-ipipe-2.6.26-arm-1.11-02/drivers/serial/Kconfig	2008-07-29 23:55:51.000000000 +0200
+++ ipipe-2.6.26-mxc/drivers/serial/Kconfig	2008-10-19 15:15:34.000000000 +0200
@@ -753,7 +753,7 @@ config BFIN_UART3_CTSRTS
 
 config SERIAL_IMX
 	bool "IMX serial port support"
-	depends on ARM && ARCH_IMX
+	depends on ARM && (ARCH_IMX || ARCH_MXC)
 	select SERIAL_CORE
 	help
 	  If you have a machine based on a Motorola IMX CPU you
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/board-mx27ads.h ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/board-mx27ads.h
--- adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/board-mx27ads.h	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/board-mx27ads.h	2008-10-19 15:15:34.000000000 +0200
@@ -0,0 +1,354 @@
+/*
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_BOARD_MX27ADS_H__
+#define __ASM_ARCH_MXC_BOARD_MX27ADS_H__
+
+/* external interrupt multiplexer */
+#define MXC_EXP_IO_BASE		(MXC_GPIO_BASE + MXC_MAX_GPIO_LINES)
+
+#define MXC_VIRTUAL_INTS_BASE	(MXC_EXP_IO_BASE + MXC_MAX_EXP_IO_LINES)
+#define MXC_SDIO1_CARD_IRQ	MXC_VIRTUAL_INTS_BASE
+#define MXC_SDIO2_CARD_IRQ	(MXC_VIRTUAL_INTS_BASE + 1)
+#define MXC_SDIO3_CARD_IRQ	(MXC_VIRTUAL_INTS_BASE + 2)
+
+#define MXC_MAX_BOARD_INTS      (MXC_MAX_EXP_IO_LINES + \
+				MXC_MAX_VIRTUAL_INTS)
+
+/*
+ * MXC UART EVB board level configurations
+ */
+
+#define MXC_LL_EXTUART_PADDR	(CS4_BASE_ADDR + 0x20000)
+#define MXC_LL_EXTUART_VADDR	(CS4_BASE_ADDR_VIRT + 0x20000)
+#define MXC_LL_EXTUART_16BIT_BUS
+
+#define MXC_LL_UART_PADDR       UART1_BASE_ADDR
+#define MXC_LL_UART_VADDR       AIPI_IO_ADDRESS(UART1_BASE_ADDR)
+
+/*
+ * @name Memory Size parameters
+ */
+
+/*
+ * Size of SDRAM memory
+ */
+#define SDRAM_MEM_SIZE          SZ_128M
+
+/*
+ * PBC Controller parameters
+ */
+
+/*
+ * Base address of PBC controller, CS4
+ */
+#define PBC_BASE_ADDRESS        0xEB000000
+#define PBC_REG_ADDR(offset)    (PBC_BASE_ADDRESS + (offset))
+
+/*
+ * PBC Interupt name definitions
+ */
+#define PBC_GPIO1_0  0
+#define PBC_GPIO1_1  1
+#define PBC_GPIO1_2  2
+#define PBC_GPIO1_3  3
+#define PBC_GPIO1_4  4
+#define PBC_GPIO1_5  5
+
+#define PBC_INTR_MAX_NUM 6
+#define PBC_INTR_SHARED_MAX_NUM 8
+
+/* When the PBC address connection is fixed in h/w, defined as 1 */
+#define PBC_ADDR_SH             0
+
+/* Offsets for the PBC Controller register */
+/*
+ * PBC Board version register offset
+ */
+#define PBC_VERSION_REG         PBC_REG_ADDR(0x00000 >> PBC_ADDR_SH)
+/*
+ * PBC Board control register 1 set address.
+ */
+#define PBC_BCTRL1_SET_REG      PBC_REG_ADDR(0x00008 >> PBC_ADDR_SH)
+/*
+ * PBC Board control register 1 clear address.
+ */
+#define PBC_BCTRL1_CLEAR_REG    PBC_REG_ADDR(0x0000C >> PBC_ADDR_SH)
+/*
+ * PBC Board control register 2 set address.
+ */
+#define PBC_BCTRL2_SET_REG      PBC_REG_ADDR(0x00010 >> PBC_ADDR_SH)
+/*
+ * PBC Board control register 2 clear address.
+ */
+#define PBC_BCTRL2_CLEAR_REG    PBC_REG_ADDR(0x00014 >> PBC_ADDR_SH)
+/*
+ * PBC Board control register 3 set address.
+ */
+#define PBC_BCTRL3_SET_REG      PBC_REG_ADDR(0x00018 >> PBC_ADDR_SH)
+/*
+ * PBC Board control register 3 clear address.
+ */
+#define PBC_BCTRL3_CLEAR_REG    PBC_REG_ADDR(0x0001C >> PBC_ADDR_SH)
+/*
+ * PBC Board control register 3 set address.
+ */
+#define PBC_BCTRL4_SET_REG      PBC_REG_ADDR(0x00020 >> PBC_ADDR_SH)
+/*
+ * PBC Board control register 4 clear address.
+ */
+#define PBC_BCTRL4_CLEAR_REG    PBC_REG_ADDR(0x00024 >> PBC_ADDR_SH)
+/*PBC_ADDR_SH
+ * PBC Board status register 1.
+ */
+#define PBC_BSTAT1_REG          PBC_REG_ADDR(0x00028 >> PBC_ADDR_SH)
+/*
+ * PBC Board interrupt status register.
+ */
+#define PBC_INTSTATUS_REG       PBC_REG_ADDR(0x0002C >> PBC_ADDR_SH)
+/*
+ * PBC Board interrupt current status register.
+ */
+#define PBC_INTCURR_STATUS_REG  PBC_REG_ADDR(0x00034 >> PBC_ADDR_SH)
+/*
+ * PBC Interrupt mask register set address.
+ */
+#define PBC_INTMASK_SET_REG     PBC_REG_ADDR(0x00038 >> PBC_ADDR_SH)
+/*
+ * PBC Interrupt mask register clear address.
+ */
+#define PBC_INTMASK_CLEAR_REG   PBC_REG_ADDR(0x0003C >> PBC_ADDR_SH)
+/*
+ * External UART A.
+ */
+#define PBC_SC16C652_UARTA_REG  PBC_REG_ADDR(0x20000 >> PBC_ADDR_SH)
+/*
+ * UART 4 Expanding Signal Status.
+ */
+#define PBC_UART_STATUS_REG     PBC_REG_ADDR(0x22000 >> PBC_ADDR_SH)
+/*
+ * UART 4 Expanding Signal Control Set.
+ */
+#define PBC_UCTRL_SET_REG       PBC_REG_ADDR(0x24000 >> PBC_ADDR_SH)
+/*
+ * UART 4 Expanding Signal Control Clear.
+ */
+#define PBC_UCTRL_CLR_REG       PBC_REG_ADDR(0x26000 >> PBC_ADDR_SH)
+/*
+ * Ethernet Controller IO base address.
+ */
+#define PBC_CS8900A_IOBASE_REG  PBC_REG_ADDR(0x40000 >> PBC_ADDR_SH)
+/*
+ * Ethernet Controller Memory base address.
+ */
+#define PBC_CS8900A_MEMBASE_REG PBC_REG_ADDR(0x42000 >> PBC_ADDR_SH)
+/*
+ * Ethernet Controller DMA base address.
+ */
+#define PBC_CS8900A_DMABASE_REG PBC_REG_ADDR(0x44000 >> PBC_ADDR_SH)
+
+/* PBC Board Version Register bit definition */
+#define PBC_VERSION_ADS         0x8000	/* Bit15=1 means version for ads */
+#define PBC_VERSION_EVB_REVB    0x4000	/* BIT14=1 means version for evb revb */
+
+/* PBC Board Control Register 1 bit definitions */
+#define PBC_BCTRL1_ERST         0x0001	/* Ethernet Reset */
+#define PBC_BCTRL1_URST         0x0002	/* Reset External UART controller */
+#define PBC_BCTRL1_FRST         0x0004	/* FEC Reset */
+#define PBC_BCTRL1_ESLEEP       0x0010	/* Enable ethernet Sleep */
+#define PBC_BCTRL1_LCDON        0x0800	/* Enable the LCD */
+
+/* PBC Board Control Register 2 bit definitions */
+#define PBC_BCTRL2_VCC_EN       0x0004	/*   Enable VCC */
+#define PBC_BCTRL2_VPP_EN       0x0008	/*   Enable Vpp */
+#define PBC_BCTRL2_ATAFEC_EN    0X0010
+#define PBC_BCTRL2_ATAFEC_SEL   0X0020
+#define PBC_BCTRL2_ATA_EN       0X0040
+#define PBC_BCTRL2_IRDA_SD      0X0080
+#define PBC_BCTRL2_IRDA_EN      0X0100
+#define PBC_BCTRL2_CCTL10       0X0200
+#define PBC_BCTRL2_CCTL11       0X0400
+
+/* PBC Board Control Register 3 bit definitions */
+#define PBC_BCTRL3_HSH_EN       0X0020
+#define PBC_BCTRL3_FSH_MOD      0X0040
+#define PBC_BCTRL3_OTG_HS_EN    0X0080
+#define PBC_BCTRL3_OTG_VBUS_EN  0X0100
+#define PBC_BCTRL3_FSH_VBUS_EN  0X0200
+#define PBC_BCTRL3_USB_OTG_ON   0X0800
+#define PBC_BCTRL3_USB_FSH_ON   0X1000
+
+/* PBC Board Control Register 4 bit definitions */
+#define PBC_BCTRL4_REGEN_SEL    0X0001
+#define PBC_BCTRL4_USER_OFF     0X0002
+#define PBC_BCTRL4_VIB_EN       0X0004
+#define PBC_BCTRL4_PWRGT1_EN    0X0008
+#define PBC_BCTRL4_PWRGT2_EN    0X0010
+#define PBC_BCTRL4_STDBY_PRI    0X0020
+
+#ifndef __ASSEMBLY__
+/*
+ * Enumerations for SD cards and memory stick card. This corresponds to
+ * the card EN bits in the IMR: SD1_EN | MS_EN | SD3_EN | SD2_EN.
+ */
+enum mxc_card_no {
+	MXC_CARD_SD2 = 0,
+	MXC_CARD_SD3,
+	MXC_CARD_MS,
+	MXC_CARD_SD1,
+	MXC_CARD_MIN = MXC_CARD_SD2,
+	MXC_CARD_MAX = MXC_CARD_SD1,
+};
+#endif
+
+#define MXC_CPLD_VER_1_50       0x01
+
+/*
+ * PBC BSTAT Register bit definitions
+ */
+#define PBC_BSTAT_PRI_INT       0X0001
+#define PBC_BSTAT_USB_BYP       0X0002
+#define PBC_BSTAT_ATA_IOCS16    0X0004
+#define PBC_BSTAT_ATA_CBLID     0X0008
+#define PBC_BSTAT_ATA_DASP      0X0010
+#define PBC_BSTAT_PWR_RDY       0X0020
+#define PBC_BSTAT_SD3_WP        0X0100
+#define PBC_BSTAT_SD2_WP        0X0200
+#define PBC_BSTAT_SD1_WP        0X0400
+#define PBC_BSTAT_SD3_DET       0X0800
+#define PBC_BSTAT_SD2_DET       0X1000
+#define PBC_BSTAT_SD1_DET       0X2000
+#define PBC_BSTAT_MS_DET        0X4000
+#define PBC_BSTAT_SD3_DET_BIT   11
+#define PBC_BSTAT_SD2_DET_BIT   12
+#define PBC_BSTAT_SD1_DET_BIT   13
+#define PBC_BSTAT_MS_DET_BIT    14
+#define MXC_BSTAT_BIT(n)        ((n == MXC_CARD_SD2) ? PBC_BSTAT_SD2_DET : \
+				 ((n == MXC_CARD_SD3) ? PBC_BSTAT_SD3_DET : \
+				 ((n == MXC_CARD_SD1) ? PBC_BSTAT_SD1_DET : \
+				 ((n == MXC_CARD_MS) ? PBC_BSTAT_MS_DET : \
+					0x0))))
+
+/*
+ * PBC UART Control Register bit definitions
+ */
+#define PBC_UCTRL_DCE_DCD       0X0001
+#define PBC_UCTRL_DCE_DSR       0X0002
+#define PBC_UCTRL_DCE_RI        0X0004
+#define PBC_UCTRL_DTE_DTR       0X0100
+
+/*
+ * PBC UART Status Register bit definitions
+ */
+#define PBC_USTAT_DTE_DCD       0X0001
+#define PBC_USTAT_DTE_DSR       0X0002
+#define PBC_USTAT_DTE_RI        0X0004
+#define PBC_USTAT_DCE_DTR       0X0100
+
+/*
+ * PBC Interupt mask register bit definitions
+ */
+#define PBC_INTR_SD3_R_EN_BIT   4
+#define PBC_INTR_SD2_R_EN_BIT   0
+#define PBC_INTR_SD1_R_EN_BIT   6
+#define PBC_INTR_MS_R_EN_BIT    5
+#define PBC_INTR_SD3_EN_BIT     13
+#define PBC_INTR_SD2_EN_BIT     12
+#define PBC_INTR_MS_EN_BIT      14
+#define PBC_INTR_SD1_EN_BIT     15
+
+#define PBC_INTR_SD2_R_EN       0x0001
+#define PBC_INTR_LOW_BAT        0X0002
+#define PBC_INTR_OTG_FSOVER     0X0004
+#define PBC_INTR_FSH_OVER       0X0008
+#define PBC_INTR_SD3_R_EN       0x0010
+#define PBC_INTR_MS_R_EN        0x0020
+#define PBC_INTR_SD1_R_EN       0x0040
+#define PBC_INTR_FEC_INT        0X0080
+#define PBC_INTR_ENET_INT       0X0100
+#define PBC_INTR_OTGFS_INT      0X0200
+#define PBC_INTR_XUART_INT      0X0400
+#define PBC_INTR_CCTL12         0X0800
+#define PBC_INTR_SD2_EN         0x1000
+#define PBC_INTR_SD3_EN         0x2000
+#define PBC_INTR_MS_EN          0x4000
+#define PBC_INTR_SD1_EN         0x8000
+
+
+
+/* For interrupts like xuart, enet etc */
+#define EXPIO_PARENT_INT        IOMUX_TO_IRQ(MX27_PIN_TIN)
+#define MXC_MAX_EXP_IO_LINES    16
+
+/*
+ * This corresponds to PBC_INTMASK_SET_REG at offset 0x38.
+ *
+ */
+#define EXPIO_INT_LOW_BAT       (MXC_EXP_IO_BASE + 1)
+#define EXPIO_INT_OTG_FS_OVR    (MXC_EXP_IO_BASE + 2)
+#define EXPIO_INT_FSH_OVR       (MXC_EXP_IO_BASE + 3)
+#define EXPIO_INT_RES4          (MXC_EXP_IO_BASE + 4)
+#define EXPIO_INT_RES5          (MXC_EXP_IO_BASE + 5)
+#define EXPIO_INT_RES6          (MXC_EXP_IO_BASE + 6)
+#define EXPIO_INT_FEC           (MXC_EXP_IO_BASE + 7)
+#define EXPIO_INT_ENET_INT      (MXC_EXP_IO_BASE + 8)
+#define EXPIO_INT_OTG_FS_INT    (MXC_EXP_IO_BASE + 9)
+#define EXPIO_INT_XUART_INTA    (MXC_EXP_IO_BASE + 10)
+#define EXPIO_INT_CCTL12_INT    (MXC_EXP_IO_BASE + 11)
+#define EXPIO_INT_SD2_EN        (MXC_EXP_IO_BASE + 12)
+#define EXPIO_INT_SD3_EN        (MXC_EXP_IO_BASE + 13)
+#define EXPIO_INT_MS_EN         (MXC_EXP_IO_BASE + 14)
+#define EXPIO_INT_SD1_EN        (MXC_EXP_IO_BASE + 15)
+
+/*
+ * This is System IRQ used by CS8900A for interrupt generation
+ * taken from platform.h
+ */
+#define CS8900AIRQ              EXPIO_INT_ENET_INT
+/* This is I/O Base address used to access registers of CS8900A on MXC ADS */
+#define CS8900A_BASE_ADDRESS    (PBC_CS8900A_IOBASE_REG + 0x300)
+
+#define MXC_PMIC_INT_LINE       IOMUX_TO_IRQ(MX27_PIN_TOUT)
+
+/*
+* This is used to detect if the CPLD version is for mx27 evb board rev-a
+*/
+#define PBC_CPLD_VERSION_IS_REVA() \
+	((__raw_readw(PBC_VERSION_REG) & \
+	(PBC_VERSION_ADS | PBC_VERSION_EVB_REVB))\
+	== 0)
+
+/* This is used to active or inactive ata signal in CPLD .
+ *  It is dependent with hardware
+ */
+#define PBC_ATA_SIGNAL_ACTIVE() \
+	__raw_writew(           \
+		PBC_BCTRL2_ATAFEC_EN|PBC_BCTRL2_ATAFEC_SEL|PBC_BCTRL2_ATA_EN, \
+		PBC_BCTRL2_CLEAR_REG)
+
+#define PBC_ATA_SIGNAL_INACTIVE() \
+	__raw_writew(  \
+		PBC_BCTRL2_ATAFEC_EN|PBC_BCTRL2_ATAFEC_SEL|PBC_BCTRL2_ATA_EN, \
+		PBC_BCTRL2_SET_REG)
+
+#define MXC_BD_LED1             (1 << 5)
+#define MXC_BD_LED2             (1 << 6)
+#define MXC_BD_LED_ON(led) \
+	__raw_writew(led, PBC_BCTRL1_SET_REG)
+#define MXC_BD_LED_OFF(led) \
+	__raw_writew(led, PBC_BCTRL1_CLEAR_REG)
+
+/* to determine the correct external crystal reference */
+#define CKIH_27MHZ_BIT_SET      (1 << 3)
+
+#endif				/* __ASM_ARCH_MXC_BOARD_MX27ADS_H__ */
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/board-mx31ads.h ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/board-mx31ads.h
--- adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/board-mx31ads.h	2008-07-29 23:55:59.000000000 +0200
+++ ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/board-mx31ads.h	2008-10-19 15:15:34.000000000 +0200
@@ -90,6 +90,9 @@
 #define PBC_INTMASK_CLEAR_REG	(PBC_INTMASK_CLEAR + PBC_BASE_ADDRESS)
 #define EXPIO_PARENT_INT	IOMUX_TO_IRQ(MX31_PIN_GPIO1_4)
 
+#define MXC_EXP_IO_BASE		(MXC_MAX_INT_LINES + MXC_MAX_GPIO_LINES)
+#define MXC_IRQ_TO_EXPIO(irq)	((irq) - MXC_EXP_IO_BASE)
+
 #define EXPIO_INT_LOW_BAT	(MXC_EXP_IO_BASE + 0)
 #define EXPIO_INT_PB_IRQ	(MXC_EXP_IO_BASE + 1)
 #define EXPIO_INT_OTG_FS_OVR	(MXC_EXP_IO_BASE + 2)
@@ -109,4 +112,9 @@
 
 #define MXC_MAX_EXP_IO_LINES	16
 
+/* mandatory for CONFIG_LL_DEBUG */
+
+#define MXC_LL_UART_PADDR	UART1_BASE_ADDR
+#define MXC_LL_UART_VADDR	AIPS1_IO_ADDRESS(UART1_BASE_ADDR)
+
 #endif /* __ASM_ARCH_MXC_BOARD_MX31ADS_H__ */
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/board-mx31lite.h ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/board-mx31lite.h
--- adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/board-mx31lite.h	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/board-mx31lite.h	2008-10-19 15:15:34.000000000 +0200
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_MXC_BOARD_MX31LITE_H__
+#define __ASM_ARCH_MXC_BOARD_MX31LITE_H__
+
+#define MXC_MAX_EXP_IO_LINES	16
+
+
+/*
+ * Memory Size parameters
+ */
+
+/*
+ * Size of SDRAM memory
+ */
+#define SDRAM_MEM_SIZE		SZ_128M
+/*
+ * Size of MBX buffer memory
+ */
+#define MXC_MBX_MEM_SIZE	SZ_16M
+/*
+ * Size of memory available to kernel
+ */
+#define MEM_SIZE		(SDRAM_MEM_SIZE - MXC_MBX_MEM_SIZE)
+
+#define MXC_LL_UART_PADDR	UART1_BASE_ADDR
+#define MXC_LL_UART_VADDR	AIPS1_IO_ADDRESS(UART1_BASE_ADDR)
+
+#endif /* __ASM_ARCH_MXC_BOARD_MX31ADS_H__ */
+
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/board-pcm037.h ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/board-pcm037.h
--- adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/board-pcm037.h	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/board-pcm037.h	2008-10-19 15:15:34.000000000 +0200
@@ -0,0 +1,27 @@
+/*
+ *  Copyright (C) 2008 Sascha Hauer, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_MXC_BOARD_PCM037_H__
+#define __ASM_ARCH_MXC_BOARD_PCM037_H__
+
+/* mandatory for CONFIG_LL_DEBUG */
+
+#define MXC_LL_UART_PADDR	UART1_BASE_ADDR
+#define MXC_LL_UART_VADDR	AIPS1_IO_ADDRESS(UART1_BASE_ADDR)
+
+#endif /* __ASM_ARCH_MXC_BOARD_PCM037_H__ */
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/board-pcm038.h ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/board-pcm038.h
--- adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/board-pcm038.h	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/board-pcm038.h	2008-10-19 15:15:34.000000000 +0200
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2008 Juergen Beisert (kernel@pengutronix.de)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ */
+
+#ifndef __ASM_ARCH_MXC_BOARD_PCM038_H__
+#define __ASM_ARCH_MXC_BOARD_PCM038_H__
+
+/* mandatory for CONFIG_LL_DEBUG */
+
+#define MXC_LL_UART_PADDR	UART1_BASE_ADDR
+#define MXC_LL_UART_VADDR	(AIPI_BASE_ADDR_VIRT + 0x0A000)
+
+#ifndef __ASSEMBLY__
+/*
+ * This CPU module needs a baseboard to work. After basic initializing
+ * its own devices, it calls baseboard's init function.
+ * TODO: Add your own baseboard init function and call it from
+ * inside pcm038_init().
+ *
+ * This example here is for the development board. Refer pcm970-baseboard.c
+ */
+
+extern void pcm970_baseboard_init(void);
+
+#endif
+
+#endif /* __ASM_ARCH_MXC_BOARD_PCM038_H__ */
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/clock.h ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/clock.h
--- adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/clock.h	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/clock.h	2008-10-19 15:15:34.000000000 +0200
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+
+#ifndef __ASM_ARCH_MXC_CLOCK_H__
+#define __ASM_ARCH_MXC_CLOCK_H__
+
+#ifndef __ASSEMBLY__
+#include <linux/list.h>
+
+struct module;
+
+struct clk {
+	struct list_head node;
+	struct module *owner;
+	const char *name;
+	int id;
+	/* Source clock this clk depends on */
+	struct clk *parent;
+	/* Secondary clock to enable/disable with this clock */
+	struct clk *secondary;
+	/* Reference count of clock enable/disable */
+	__s8 usecount;
+	/* Register bit position for clock's enable/disable control. */
+	u8 enable_shift;
+	/* Register address for clock's enable/disable control. */
+	u32 enable_reg;
+	u32 flags;
+	/* get the current clock rate (always a fresh value) */
+	unsigned long (*get_rate) (struct clk *);
+	/* Function ptr to set the clock to a new rate. The rate must match a
+	   supported rate returned from round_rate. Leave blank if clock is not
+	   programmable */
+	int (*set_rate) (struct clk *, unsigned long);
+	/* Function ptr to round the requested clock rate to the nearest
+	   supported rate that is less than or equal to the requested rate. */
+	unsigned long (*round_rate) (struct clk *, unsigned long);
+	/* Function ptr to enable the clock. Leave blank if clock can not
+	   be gated. */
+	int (*enable) (struct clk *);
+	/* Function ptr to disable the clock. Leave blank if clock can not
+	   be gated. */
+	void (*disable) (struct clk *);
+	/* Function ptr to set the parent clock of the clock. */
+	int (*set_parent) (struct clk *, struct clk *);
+};
+
+int clk_register(struct clk *clk);
+void clk_unregister(struct clk *clk);
+
+#endif /* __ASSEMBLY__ */
+#endif /* __ASM_ARCH_MXC_CLOCK_H__ */
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/common.h ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/common.h
--- adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/common.h	2007-10-22 21:49:15.000000000 +0200
+++ ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/common.h	2008-10-19 15:15:34.000000000 +0200
@@ -11,10 +11,10 @@
 #ifndef __ASM_ARCH_MXC_COMMON_H__
 #define __ASM_ARCH_MXC_COMMON_H__
 
-struct sys_timer;
-
 extern void mxc_map_io(void);
 extern void mxc_init_irq(void);
-extern struct sys_timer mxc_timer;
+extern void mxc_timer_init(const char *clk_timer);
+extern int mxc_clocks_init(unsigned long fref);
+extern int mxc_register_gpios(void);
 
 #endif
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/debug-macro.S ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/debug-macro.S
--- adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/debug-macro.S	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/debug-macro.S	2008-10-19 15:15:34.000000000 +0200
@@ -0,0 +1,49 @@
+/* linux/include/asm-arm/arch-imx/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) 1994-1999 Russell King
+ *  Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <asm/arch/hardware.h>
+
+#ifdef CONFIG_MACH_MX31ADS
+#include <asm/arch/board-mx31ads.h>
+#endif
+#ifdef CONFIG_MACH_PCM037
+#include <asm/arch/board-pcm037.h>
+#endif
+#ifdef CONFIG_MACH_MX31LITE
+#include <asm/arch/board-mx31lite.h>
+#endif
+#ifdef CONFIG_MACH_MX27ADS
+#include <asm/arch/board-mx27ads.h>
+#endif
+#ifdef CONFIG_MACH_PCM038
+#include <asm/arch/board-pcm038.h>
+#endif
+		.macro	addruart,rx
+		mrc	p15, 0, \rx, c1, c0
+		tst	\rx, #1			@ MMU enabled?
+		ldreq	\rx, =MXC_LL_UART_PADDR	@ physical
+		ldrne	\rx, =MXC_LL_UART_VADDR	@ virtual
+		.endm
+
+		.macro	senduart,rd,rx
+		str	\rd, [\rx, #0x40]	@ TXDATA
+		.endm
+
+		.macro	waituart,rd,rx
+		.endm
+
+		.macro	busyuart,rd,rx
+1002:		ldr	\rd, [\rx, #0x98]	@ SR2
+		tst	\rd, #1 << 3		@ TXDC
+		beq	1002b			@ wait until transmit done
+		.endm
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/gpio.h ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/gpio.h
--- adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/gpio.h	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/gpio.h	2008-10-19 15:15:34.000000000 +0200
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifndef __ASM_ARCH_MXC_GPIO_H__
+#define __ASM_ARCH_MXC_GPIO_H__
+
+#include <asm/hardware.h>
+#include <asm-generic/gpio.h>
+
+/* use gpiolib dispatchers */
+#define gpio_get_value		__gpio_get_value
+#define gpio_set_value		__gpio_set_value
+#define gpio_cansleep		__gpio_cansleep
+
+#define gpio_to_irq(gpio)	(MXC_MAX_INT_LINES + (gpio))
+#define irq_to_gpio(irq)	((irq) - MXC_MAX_INT_LINES)
+
+struct mxc_gpio_port {
+	void __iomem *base;
+	int irq;
+	int virtual_irq_start;
+	struct gpio_chip chip;
+};
+
+int mxc_gpio_init(struct mxc_gpio_port*, int);
+
+#endif
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/hardware.h ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/hardware.h
--- adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/hardware.h	2008-07-29 23:55:59.000000000 +0200
+++ ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/hardware.h	2008-10-19 15:15:34.000000000 +0200
@@ -1,11 +1,20 @@
 /*
- *  Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
  */
 
 #ifndef __ASM_ARCH_MXC_HARDWARE_H__
@@ -17,15 +26,12 @@
 # include <asm/arch/mx31.h>
 #endif
 
-#include <asm/arch/mxc.h>
-
-/*
- * ---------------------------------------------------------------------------
- * Board specific defines
- * ---------------------------------------------------------------------------
- */
-#ifdef CONFIG_MACH_MX31ADS
-# include <asm/arch/board-mx31ads.h>
+#ifdef CONFIG_ARCH_MX2
+# ifdef CONFIG_MACH_MX27
+#  include <asm/arch/mx27.h>
+# endif
 #endif
 
+#include <asm/arch/mxc.h>
+
 #endif /* __ASM_ARCH_MXC_HARDWARE_H__ */
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/iim.h ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/iim.h
--- adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/iim.h	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/iim.h	2008-10-19 15:15:34.000000000 +0200
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+
+#ifndef __ASM_ARCH_MXC_IIM_H__
+#define __ASM_ARCH_MXC_IIM_H__
+
+/* Register offsets */
+#define MXC_IIMSTAT             0x0000
+#define MXC_IIMSTATM            0x0004
+#define MXC_IIMERR              0x0008
+#define MXC_IIMEMASK            0x000C
+#define MXC_IIMFCTL             0x0010
+#define MXC_IIMUA               0x0014
+#define MXC_IIMLA               0x0018
+#define MXC_IIMSDAT             0x001C
+#define MXC_IIMPREV             0x0020
+#define MXC_IIMSREV             0x0024
+#define MXC_IIMPRG_P            0x0028
+#define MXC_IIMSCS0             0x002C
+#define MXC_IIMSCS1             0x0030
+#define MXC_IIMSCS2             0x0034
+#define MXC_IIMSCS3             0x0038
+#define MXC_IIMFBAC0            0x0800
+#define MXC_IIMJAC              0x0804
+#define MXC_IIMHWV1             0x0808
+#define MXC_IIMHWV2             0x080C
+#define MXC_IIMHAB0             0x0810
+#define MXC_IIMHAB1             0x0814
+/* Definitions for i.MX27 TO2 */
+#define MXC_IIMMAC              0x0814
+#define MXC_IIMPREV_FUSE        0x0818
+#define MXC_IIMSREV_FUSE        0x081C
+#define MXC_IIMSJC_CHALL_0      0x0820
+#define MXC_IIMSJC_CHALL_7      0x083C
+#define MXC_IIMFB0UC17          0x0840
+#define MXC_IIMFB0UC255         0x0BFC
+#define MXC_IIMFBAC1            0x0C00
+/* Definitions for i.MX27 TO2 */
+#define MXC_IIMSUID             0x0C04
+#define MXC_IIMKEY0             0x0C04
+#define MXC_IIMKEY20            0x0C54
+#define MXC_IIMSJC_RESP_0       0x0C58
+#define MXC_IIMSJC_RESP_7       0x0C74
+#define MXC_IIMFB1UC30          0x0C78
+#define MXC_IIMFB1UC255         0x0FFC
+
+/* Bit definitions */
+
+#define MXC_IIMHWV1_WLOCK               (0x1 << 7)
+#define MXC_IIMHWV1_MCU_ENDIAN          (0x1 << 6)
+#define MXC_IIMHWV1_DSP_ENDIAN          (0x1 << 5)
+#define MXC_IIMHWV1_BOOT_INT            (0x1 << 4)
+#define MXC_IIMHWV1_SCC_DISABLE         (0x1 << 3)
+#define MXC_IIMHWV1_HANTRO_DISABLE      (0x1 << 2)
+#define MXC_IIMHWV1_MEMSTICK_DIS        (0x1 << 1)
+
+#define MXC_IIMHWV2_WLOCK               (0x1 << 7)
+#define MXC_IIMHWV2_BP_SDMA             (0x1 << 6)
+#define MXC_IIMHWV2_SCM_DCM             (0x1 << 5)
+
+#endif /* __ASM_ARCH_MXC_IIM_H__ */
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/imx-uart.h ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/imx-uart.h
--- adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/imx-uart.h	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/imx-uart.h	2008-10-19 15:15:34.000000000 +0200
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2008 by Sascha Hauer <kernel@pengutronix.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ */
+
+#ifndef ASMARM_ARCH_UART_H
+#define ASMARM_ARCH_UART_H
+
+#define IMXUART_HAVE_RTSCTS (1<<0)
+
+struct imxuart_platform_data {
+	int (*init)(struct platform_device *pdev);
+	int (*exit)(struct platform_device *pdev);
+	unsigned int flags;
+};
+
+int __init imx_init_uart(int uart_no, struct imxuart_platform_data *pdata);
+
+#endif
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/iomux-mx1-mx2.h ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/iomux-mx1-mx2.h
--- adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/iomux-mx1-mx2.h	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/iomux-mx1-mx2.h	2008-10-19 15:15:34.000000000 +0200
@@ -0,0 +1,372 @@
+/*
+ * Copyright (C) 2008 by Sascha Hauer <kernel@pengutronix.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ */
+
+#ifndef _MXC_GPIO_MX1_MX2_H
+#define _MXC_GPIO_MX1_MX2_H
+
+#include <linux/io.h>
+
+#define MXC_GPIO_ALLOC_MODE_NORMAL	0
+#define MXC_GPIO_ALLOC_MODE_NO_ALLOC	1
+#define MXC_GPIO_ALLOC_MODE_TRY_ALLOC	2
+#define MXC_GPIO_ALLOC_MODE_ALLOC_ONLY	4
+#define MXC_GPIO_ALLOC_MODE_RELEASE	8
+
+/*
+ *  GPIO Module and I/O Multiplexer
+ *  x = 0..3 for reg_A, reg_B, reg_C, reg_D
+ */
+#define VA_GPIO_BASE	IO_ADDRESS(GPIO_BASE_ADDR)
+#define MXC_DDIR(x)    (0x00 + ((x) << 8))
+#define MXC_OCR1(x)    (0x04 + ((x) << 8))
+#define MXC_OCR2(x)    (0x08 + ((x) << 8))
+#define MXC_ICONFA1(x) (0x0c + ((x) << 8))
+#define MXC_ICONFA2(x) (0x10 + ((x) << 8))
+#define MXC_ICONFB1(x) (0x14 + ((x) << 8))
+#define MXC_ICONFB2(x) (0x18 + ((x) << 8))
+#define MXC_DR(x)      (0x1c + ((x) << 8))
+#define MXC_GIUS(x)    (0x20 + ((x) << 8))
+#define MXC_SSR(x)     (0x24 + ((x) << 8))
+#define MXC_ICR1(x)    (0x28 + ((x) << 8))
+#define MXC_ICR2(x)    (0x2c + ((x) << 8))
+#define MXC_IMR(x)     (0x30 + ((x) << 8))
+#define MXC_ISR(x)     (0x34 + ((x) << 8))
+#define MXC_GPR(x)     (0x38 + ((x) << 8))
+#define MXC_SWR(x)     (0x3c + ((x) << 8))
+#define MXC_PUEN(x)    (0x40 + ((x) << 8))
+
+#ifdef CONFIG_ARCH_MX1
+# define GPIO_PORT_MAX  3
+#endif
+#ifdef CONFIG_ARCH_MX2
+# define GPIO_PORT_MAX  5
+#endif
+
+#ifndef GPIO_PORT_MAX
+# error "GPIO config port count unknown!"
+#endif
+
+#define GPIO_PIN_MASK 0x1f
+
+#define GPIO_PORT_SHIFT 5
+#define GPIO_PORT_MASK (0x7 << GPIO_PORT_SHIFT)
+
+#define GPIO_PORTA (0 << GPIO_PORT_SHIFT)
+#define GPIO_PORTB (1 << GPIO_PORT_SHIFT)
+#define GPIO_PORTC (2 << GPIO_PORT_SHIFT)
+#define GPIO_PORTD (3 << GPIO_PORT_SHIFT)
+#define GPIO_PORTE (4 << GPIO_PORT_SHIFT)
+#define GPIO_PORTF (5 << GPIO_PORT_SHIFT)
+
+#define GPIO_OUT   (1 << 8)
+#define GPIO_IN    (0 << 8)
+#define GPIO_PUEN  (1 << 9)
+
+#define GPIO_PF    (1 << 10)
+#define GPIO_AF    (1 << 11)
+
+#define GPIO_OCR_SHIFT 12
+#define GPIO_OCR_MASK (3 << GPIO_OCR_SHIFT)
+#define GPIO_AIN   (0 << GPIO_OCR_SHIFT)
+#define GPIO_BIN   (1 << GPIO_OCR_SHIFT)
+#define GPIO_CIN   (2 << GPIO_OCR_SHIFT)
+#define GPIO_GPIO  (3 << GPIO_OCR_SHIFT)
+
+#define GPIO_AOUT_SHIFT 14
+#define GPIO_AOUT_MASK (3 << GPIO_AOUT_SHIFT)
+#define GPIO_AOUT     (0 << GPIO_AOUT_SHIFT)
+#define GPIO_AOUT_ISR (1 << GPIO_AOUT_SHIFT)
+#define GPIO_AOUT_0   (2 << GPIO_AOUT_SHIFT)
+#define GPIO_AOUT_1   (3 << GPIO_AOUT_SHIFT)
+
+#define GPIO_BOUT_SHIFT 16
+#define GPIO_BOUT_MASK (3 << GPIO_BOUT_SHIFT)
+#define GPIO_BOUT      (0 << GPIO_BOUT_SHIFT)
+#define GPIO_BOUT_ISR  (1 << GPIO_BOUT_SHIFT)
+#define GPIO_BOUT_0    (2 << GPIO_BOUT_SHIFT)
+#define GPIO_BOUT_1    (3 << GPIO_BOUT_SHIFT)
+
+extern void mxc_gpio_mode(int gpio_mode);
+extern int mxc_gpio_setup_multiple_pins(const int *pin_list, unsigned count,
+					int alloc_mode, const char *label);
+
+/*-------------------------------------------------------------------------*/
+
+/* assignements for GPIO alternate/primary functions */
+
+/* FIXME: This list is not completed. The correct directions are
+ * missing on some (many) pins
+ */
+#ifdef CONFIG_ARCH_MX1
+#define PA0_AIN_SPI2_CLK     (GPIO_GIUS | GPIO_PORTA | GPIO_OUT | 0)
+#define PA0_AF_ETMTRACESYNC  (GPIO_PORTA | GPIO_AF | 0)
+#define PA1_AOUT_SPI2_RXD    (GPIO_GIUS | GPIO_PORTA | GPIO_IN | 1)
+#define PA1_PF_TIN           (GPIO_PORTA | GPIO_PF | 1)
+#define PA2_PF_PWM0          (GPIO_PORTA | GPIO_OUT | GPIO_PF | 2)
+#define PA3_PF_CSI_MCLK      (GPIO_PORTA | GPIO_PF | 3)
+#define PA4_PF_CSI_D0        (GPIO_PORTA | GPIO_PF | 4)
+#define PA5_PF_CSI_D1        (GPIO_PORTA | GPIO_PF | 5)
+#define PA6_PF_CSI_D2        (GPIO_PORTA | GPIO_PF | 6)
+#define PA7_PF_CSI_D3        (GPIO_PORTA | GPIO_PF | 7)
+#define PA8_PF_CSI_D4        (GPIO_PORTA | GPIO_PF | 8)
+#define PA9_PF_CSI_D5        (GPIO_PORTA | GPIO_PF | 9)
+#define PA10_PF_CSI_D6       (GPIO_PORTA | GPIO_PF | 10)
+#define PA11_PF_CSI_D7       (GPIO_PORTA | GPIO_PF | 11)
+#define PA12_PF_CSI_VSYNC    (GPIO_PORTA | GPIO_PF | 12)
+#define PA13_PF_CSI_HSYNC    (GPIO_PORTA | GPIO_PF | 13)
+#define PA14_PF_CSI_PIXCLK   (GPIO_PORTA | GPIO_PF | 14)
+#define PA15_PF_I2C_SDA      (GPIO_PORTA | GPIO_OUT | GPIO_PF | 15)
+#define PA16_PF_I2C_SCL      (GPIO_PORTA | GPIO_OUT | GPIO_PF | 16)
+#define PA17_AF_ETMTRACEPKT4 (GPIO_PORTA | GPIO_AF | 17)
+#define PA17_AIN_SPI2_SS     (GPIO_GIUS | GPIO_PORTA | GPIO_OUT | 17)
+#define PA18_AF_ETMTRACEPKT5 (GPIO_PORTA | GPIO_AF | 18)
+#define PA19_AF_ETMTRACEPKT6 (GPIO_PORTA | GPIO_AF | 19)
+#define PA20_AF_ETMTRACEPKT7 (GPIO_PORTA | GPIO_AF | 20)
+#define PA21_PF_A0           (GPIO_PORTA | GPIO_PF | 21)
+#define PA22_PF_CS4          (GPIO_PORTA | GPIO_PF | 22)
+#define PA23_PF_CS5          (GPIO_PORTA | GPIO_PF | 23)
+#define PA24_PF_A16          (GPIO_PORTA | GPIO_PF | 24)
+#define PA24_AF_ETMTRACEPKT0 (GPIO_PORTA | GPIO_AF | 24)
+#define PA25_PF_A17          (GPIO_PORTA | GPIO_PF | 25)
+#define PA25_AF_ETMTRACEPKT1 (GPIO_PORTA | GPIO_AF | 25)
+#define PA26_PF_A18          (GPIO_PORTA | GPIO_PF | 26)
+#define PA26_AF_ETMTRACEPKT2 (GPIO_PORTA | GPIO_AF | 26)
+#define PA27_PF_A19          (GPIO_PORTA | GPIO_PF | 27)
+#define PA27_AF_ETMTRACEPKT3 (GPIO_PORTA | GPIO_AF | 27)
+#define PA28_PF_A20          (GPIO_PORTA | GPIO_PF | 28)
+#define PA28_AF_ETMPIPESTAT0 (GPIO_PORTA | GPIO_AF | 28)
+#define PA29_PF_A21          (GPIO_PORTA | GPIO_PF | 29)
+#define PA29_AF_ETMPIPESTAT1 (GPIO_PORTA | GPIO_AF | 29)
+#define PA30_PF_A22          (GPIO_PORTA | GPIO_PF | 30)
+#define PA30_AF_ETMPIPESTAT2 (GPIO_PORTA | GPIO_AF | 30)
+#define PA31_PF_A23          (GPIO_PORTA | GPIO_PF | 31)
+#define PA31_AF_ETMTRACECLK  (GPIO_PORTA | GPIO_AF | 31)
+#define PB8_PF_SD_DAT0       (GPIO_PORTB | GPIO_PF | GPIO_PUEN | 8)
+#define PB8_AF_MS_PIO        (GPIO_PORTB | GPIO_AF | 8)
+#define PB9_PF_SD_DAT1       (GPIO_PORTB | GPIO_PF | GPIO_PUEN  | 9)
+#define PB9_AF_MS_PI1        (GPIO_PORTB | GPIO_AF | 9)
+#define PB10_PF_SD_DAT2      (GPIO_PORTB | GPIO_PF | GPIO_PUEN  | 10)
+#define PB10_AF_MS_SCLKI     (GPIO_PORTB | GPIO_AF | 10)
+#define PB11_PF_SD_DAT3      (GPIO_PORTB | GPIO_PF | 11)
+#define PB11_AF_MS_SDIO      (GPIO_PORTB | GPIO_AF | 11)
+#define PB12_PF_SD_CLK       (GPIO_PORTB | GPIO_PF | 12)
+#define PB12_AF_MS_SCLK0     (GPIO_PORTB | GPIO_AF | 12)
+#define PB13_PF_SD_CMD       (GPIO_PORTB | GPIO_PF | GPIO_PUEN | 13)
+#define PB13_AF_MS_BS        (GPIO_PORTB | GPIO_AF | 13)
+#define PB14_AF_SSI_RXFS     (GPIO_PORTB | GPIO_AF | 14)
+#define PB15_AF_SSI_RXCLK    (GPIO_PORTB | GPIO_AF | 15)
+#define PB16_AF_SSI_RXDAT    (GPIO_PORTB | GPIO_IN | GPIO_AF | 16)
+#define PB17_AF_SSI_TXDAT    (GPIO_PORTB | GPIO_OUT | GPIO_AF | 17)
+#define PB18_AF_SSI_TXFS     (GPIO_PORTB | GPIO_AF | 18)
+#define PB19_AF_SSI_TXCLK    (GPIO_PORTB | GPIO_AF | 19)
+#define PB20_PF_USBD_AFE     (GPIO_PORTB | GPIO_PF | 20)
+#define PB21_PF_USBD_OE      (GPIO_PORTB | GPIO_PF | 21)
+#define PB22_PFUSBD_RCV      (GPIO_PORTB | GPIO_PF | 22)
+#define PB23_PF_USBD_SUSPND  (GPIO_PORTB | GPIO_PF | 23)
+#define PB24_PF_USBD_VP      (GPIO_PORTB | GPIO_PF | 24)
+#define PB25_PF_USBD_VM      (GPIO_PORTB | GPIO_PF | 25)
+#define PB26_PF_USBD_VPO     (GPIO_PORTB | GPIO_PF | 26)
+#define PB27_PF_USBD_VMO     (GPIO_PORTB | GPIO_PF | 27)
+#define PB28_PF_UART2_CTS    (GPIO_PORTB | GPIO_OUT | GPIO_PF | 28)
+#define PB29_PF_UART2_RTS    (GPIO_PORTB | GPIO_IN | GPIO_PF | 29)
+#define PB30_PF_UART2_TXD    (GPIO_PORTB | GPIO_OUT | GPIO_PF | 30)
+#define PB31_PF_UART2_RXD    (GPIO_PORTB | GPIO_IN | GPIO_PF | 31)
+#define PC3_PF_SSI_RXFS      (GPIO_PORTC | GPIO_PF | 3)
+#define PC4_PF_SSI_RXCLK     (GPIO_PORTC | GPIO_PF | 4)
+#define PC5_PF_SSI_RXDAT     (GPIO_PORTC | GPIO_IN | GPIO_PF | 5)
+#define PC6_PF_SSI_TXDAT     (GPIO_PORTC | GPIO_OUT | GPIO_PF | 6)
+#define PC7_PF_SSI_TXFS      (GPIO_PORTC | GPIO_PF | 7)
+#define PC8_PF_SSI_TXCLK     (GPIO_PORTC | GPIO_PF | 8)
+#define PC9_PF_UART1_CTS     (GPIO_PORTC | GPIO_OUT | GPIO_PF | 9)
+#define PC10_PF_UART1_RTS    (GPIO_PORTC | GPIO_IN | GPIO_PF | 10)
+#define PC11_PF_UART1_TXD    (GPIO_PORTC | GPIO_OUT | GPIO_PF | 11)
+#define PC12_PF_UART1_RXD    (GPIO_PORTC | GPIO_IN | GPIO_PF | 12)
+#define PC13_PF_SPI1_SPI_RDY (GPIO_PORTC | GPIO_PF | 13)
+#define PC14_PF_SPI1_SCLK    (GPIO_PORTC | GPIO_PF | 14)
+#define PC15_PF_SPI1_SS      (GPIO_PORTC | GPIO_PF | 15)
+#define PC16_PF_SPI1_MISO    (GPIO_PORTC | GPIO_PF | 16)
+#define PC17_PF_SPI1_MOSI    (GPIO_PORTC | GPIO_PF | 17)
+#define PC24_BIN_UART3_RI    (GPIO_GIUS | GPIO_PORTC | GPIO_OUT | GPIO_BIN | 24)
+#define PC25_BIN_UART3_DSR   (GPIO_GIUS | GPIO_PORTC | GPIO_OUT | GPIO_BIN | 25)
+#define PC26_AOUT_UART3_DTR  (GPIO_GIUS | GPIO_PORTC | GPIO_IN | 26)
+#define PC27_BIN_UART3_DCD   (GPIO_GIUS | GPIO_PORTC | GPIO_OUT | GPIO_BIN | 27)
+#define PC28_BIN_UART3_CTS   (GPIO_GIUS | GPIO_PORTC | GPIO_OUT | GPIO_BIN | 28)
+#define PC29_AOUT_UART3_RTS  (GPIO_GIUS | GPIO_PORTC | GPIO_IN | 29)
+#define PC30_BIN_UART3_TX    (GPIO_GIUS | GPIO_PORTC | GPIO_BIN | 30)
+#define PC31_AOUT_UART3_RX   (GPIO_GIUS | GPIO_PORTC | GPIO_IN | 31)
+#define PD6_PF_LSCLK         (GPIO_PORTD | GPIO_OUT | GPIO_PF | 6)
+#define PD7_PF_REV           (GPIO_PORTD | GPIO_PF | 7)
+#define PD7_AF_UART2_DTR     (GPIO_GIUS | GPIO_PORTD | GPIO_IN | GPIO_AF | 7)
+#define PD7_AIN_SPI2_SCLK    (GPIO_GIUS | GPIO_PORTD | GPIO_AIN | 7)
+#define PD8_PF_CLS           (GPIO_PORTD | GPIO_PF | 8)
+#define PD8_AF_UART2_DCD     (GPIO_PORTD | GPIO_OUT | GPIO_AF | 8)
+#define PD8_AIN_SPI2_SS      (GPIO_GIUS | GPIO_PORTD | GPIO_AIN | 8)
+#define PD9_PF_PS            (GPIO_PORTD | GPIO_PF | 9)
+#define PD9_AF_UART2_RI      (GPIO_PORTD | GPIO_OUT | GPIO_AF | 9)
+#define PD9_AOUT_SPI2_RXD    (GPIO_GIUS | GPIO_PORTD | GPIO_IN | 9)
+#define PD10_PF_SPL_SPR      (GPIO_PORTD | GPIO_OUT | GPIO_PF | 10)
+#define PD10_AF_UART2_DSR    (GPIO_PORTD | GPIO_OUT | GPIO_AF | 10)
+#define PD10_AIN_SPI2_TXD    (GPIO_GIUS | GPIO_PORTD | GPIO_OUT | 10)
+#define PD11_PF_CONTRAST     (GPIO_PORTD | GPIO_OUT | GPIO_PF | 11)
+#define PD12_PF_ACD_OE       (GPIO_PORTD | GPIO_OUT | GPIO_PF | 12)
+#define PD13_PF_LP_HSYNC     (GPIO_PORTD | GPIO_OUT | GPIO_PF | 13)
+#define PD14_PF_FLM_VSYNC    (GPIO_PORTD | GPIO_OUT | GPIO_PF | 14)
+#define PD15_PF_LD0          (GPIO_PORTD | GPIO_OUT | GPIO_PF | 15)
+#define PD16_PF_LD1          (GPIO_PORTD | GPIO_OUT | GPIO_PF | 16)
+#define PD17_PF_LD2          (GPIO_PORTD | GPIO_OUT | GPIO_PF | 17)
+#define PD18_PF_LD3          (GPIO_PORTD | GPIO_OUT | GPIO_PF | 18)
+#define PD19_PF_LD4          (GPIO_PORTD | GPIO_OUT | GPIO_PF | 19)
+#define PD20_PF_LD5          (GPIO_PORTD | GPIO_OUT | GPIO_PF | 20)
+#define PD21_PF_LD6          (GPIO_PORTD | GPIO_OUT | GPIO_PF | 21)
+#define PD22_PF_LD7          (GPIO_PORTD | GPIO_OUT | GPIO_PF | 22)
+#define PD23_PF_LD8          (GPIO_PORTD | GPIO_OUT | GPIO_PF | 23)
+#define PD24_PF_LD9          (GPIO_PORTD | GPIO_OUT | GPIO_PF | 24)
+#define PD25_PF_LD10         (GPIO_PORTD | GPIO_OUT | GPIO_PF | 25)
+#define PD26_PF_LD11         (GPIO_PORTD | GPIO_OUT | GPIO_PF | 26)
+#define PD27_PF_LD12         (GPIO_PORTD | GPIO_OUT | GPIO_PF | 27)
+#define PD28_PF_LD13         (GPIO_PORTD | GPIO_OUT | GPIO_PF | 28)
+#define PD29_PF_LD14         (GPIO_PORTD | GPIO_OUT | GPIO_PF | 29)
+#define PD30_PF_LD15         (GPIO_PORTD | GPIO_OUT | GPIO_PF | 30)
+#define PD31_PF_TMR2OUT      (GPIO_PORTD | GPIO_PF | 31)
+#define PD31_BIN_SPI2_TXD    (GPIO_GIUS | GPIO_PORTD | GPIO_BIN | 31)
+#endif
+
+#ifdef CONFIG_ARCH_MX2
+#define PA5_PF_LSCLK		(GPIO_PORTA | GPIO_OUT | GPIO_PF | 5)
+#define PA6_PF_LD0		(GPIO_PORTA | GPIO_OUT | GPIO_PF | 6)
+#define PA7_PF_LD1		(GPIO_PORTA | GPIO_OUT | GPIO_PF | 7)
+#define PA8_PF_LD2		(GPIO_PORTA | GPIO_OUT | GPIO_PF | 8)
+#define PA9_PF_LD3		(GPIO_PORTA | GPIO_OUT | GPIO_PF | 9)
+#define PA10_PF_LD4		(GPIO_PORTA | GPIO_OUT | GPIO_PF | 10)
+#define PA11_PF_LD5		(GPIO_PORTA | GPIO_OUT | GPIO_PF | 11)
+#define PA12_PF_LD6		(GPIO_PORTA | GPIO_OUT | GPIO_PF | 12)
+#define PA13_PF_LD7		(GPIO_PORTA | GPIO_OUT | GPIO_PF | 13)
+#define PA14_PF_LD8		(GPIO_PORTA | GPIO_OUT | GPIO_PF | 14)
+#define PA15_PF_LD9		(GPIO_PORTA | GPIO_OUT | GPIO_PF | 15)
+#define PA16_PF_LD10		(GPIO_PORTA | GPIO_OUT | GPIO_PF | 16)
+#define PA17_PF_LD11		(GPIO_PORTA | GPIO_OUT | GPIO_PF | 17)
+#define PA18_PF_LD12		(GPIO_PORTA | GPIO_OUT | GPIO_PF | 18)
+#define PA19_PF_LD13		(GPIO_PORTA | GPIO_OUT | GPIO_PF | 19)
+#define PA20_PF_LD14		(GPIO_PORTA | GPIO_OUT | GPIO_PF | 20)
+#define PA21_PF_LD15		(GPIO_PORTA | GPIO_OUT | GPIO_PF | 21)
+#define PA22_PF_LD16		(GPIO_PORTA | GPIO_OUT | GPIO_PF | 22)
+#define PA23_PF_LD17		(GPIO_PORTA | GPIO_OUT | GPIO_PF | 23)
+#define PA24_PF_REV		(GPIO_PORTA | GPIO_OUT | GPIO_PF | 24)
+#define PA25_PF_CLS		(GPIO_PORTA | GPIO_OUT | GPIO_PF | 25)
+#define PA26_PF_PS		(GPIO_PORTA | GPIO_OUT | GPIO_PF | 26)
+#define PA27_PF_SPL_SPR		(GPIO_PORTA | GPIO_OUT | GPIO_PF | 27)
+#define PA28_PF_HSYNC		(GPIO_PORTA | GPIO_OUT | GPIO_PF | 28)
+#define PA29_PF_VSYNC		(GPIO_PORTA | GPIO_OUT | GPIO_PF | 29)
+#define PA30_PF_CONTRAST	(GPIO_PORTA | GPIO_OUT | GPIO_PF | 30)
+#define PA31_PF_OE_ACD		(GPIO_PORTA | GPIO_OUT | GPIO_PF | 31)
+#define PB10_PF_CSI_D0		(GPIO_PORTB | GPIO_OUT | GPIO_PF | 10)
+#define PB10_AF_UART6_TXD	(GPIO_PORTB | GPIO_OUT | GPIO_AF | 10)
+#define PB11_PF_CSI_D1		(GPIO_PORTB | GPIO_OUT | GPIO_PF | 11)
+#define PB11_AF_UART6_RXD	(GPIO_PORTB | GPIO_IN  | GPIO_AF | 11)
+#define PB12_PF_CSI_D2		(GPIO_PORTB | GPIO_OUT | GPIO_PF | 12)
+#define PB12_AF_UART6_CTS	(GPIO_PORTB | GPIO_OUT | GPIO_AF | 12)
+#define PB13_PF_CSI_D3		(GPIO_PORTB | GPIO_OUT | GPIO_PF | 13)
+#define PB13_AF_UART6_RTS	(GPIO_PORTB | GPIO_IN  | GPIO_AF | 13)
+#define PB14_PF_CSI_D4		(GPIO_PORTB | GPIO_OUT | GPIO_PF | 14)
+#define PB15_PF_CSI_MCLK	(GPIO_PORTB | GPIO_OUT | GPIO_PF | 15)
+#define PB16_PF_CSI_PIXCLK	(GPIO_PORTB | GPIO_OUT | GPIO_PF | 16)
+#define PB17_PF_CSI_D5		(GPIO_PORTB | GPIO_OUT | GPIO_PF | 17)
+#define PB18_PF_CSI_D6		(GPIO_PORTB | GPIO_OUT | GPIO_PF | 18)
+#define PB18_AF_UART5_TXD	(GPIO_PORTB | GPIO_OUT | GPIO_AF | 18)
+#define PB19_PF_CSI_D7		(GPIO_PORTB | GPIO_OUT | GPIO_PF | 19)
+#define PB19_AF_UART5_RXD	(GPIO_PORTB | GPIO_IN  | GPIO_AF | 19)
+#define PB20_PF_CSI_VSYNC	(GPIO_PORTB | GPIO_OUT | GPIO_PF | 20)
+#define PB20_AF_UART5_CTS	(GPIO_PORTB | GPIO_OUT | GPIO_AF | 20)
+#define PB21_PF_CSI_HSYNC	(GPIO_PORTB | GPIO_OUT | GPIO_PF | 21)
+#define PB21_AF_UART5_RTS	(GPIO_PORTB | GPIO_IN  | GPIO_AF | 21)
+#define PB26_AF_UART4_RTS	(GPIO_PORTB | GPIO_IN  | GPIO_PF | 26)
+#define PB28_AF_UART4_TXD	(GPIO_PORTB | GPIO_OUT | GPIO_AF | 28)
+#define PB29_AF_UART4_CTS	(GPIO_PORTB | GPIO_OUT | GPIO_AF | 29)
+#define PB31_AF_UART4_RXD	(GPIO_PORTB | GPIO_IN  | GPIO_AF | 31)
+#define PC5_PF_I2C2_SDA		(GPIO_PORTC | GPIO_IN  | GPIO_PF | 5)
+#define PC6_PF_I2C2_SCL		(GPIO_PORTC | GPIO_IN  | GPIO_PF | 6)
+#define PC16_PF_SSI4_FS		(GPIO_PORTC | GPIO_IN  | GPIO_PF | 16)
+#define PC17_PF_SSI4_RXD	(GPIO_PORTC | GPIO_IN  | GPIO_PF | 17)
+#define PC18_PF_SSI4_TXD	(GPIO_PORTC | GPIO_IN  | GPIO_PF | 18)
+#define PC19_PF_SSI4_CLK	(GPIO_PORTC | GPIO_IN  | GPIO_PF | 19)
+#define PC20_PF_SSI1_FS		(GPIO_PORTC | GPIO_IN  | GPIO_PF | 20)
+#define PC21_PF_SSI1_RXD	(GPIO_PORTC | GPIO_IN  | GPIO_PF | 21)
+#define PC22_PF_SSI1_TXD	(GPIO_PORTC | GPIO_IN  | GPIO_PF | 22)
+#define PC23_PF_SSI1_CLK	(GPIO_PORTC | GPIO_IN  | GPIO_PF | 23)
+#define PC24_PF_SSI2_FS		(GPIO_PORTC | GPIO_IN  | GPIO_PF | 24)
+#define PC25_PF_SSI2_RXD	(GPIO_PORTC | GPIO_IN  | GPIO_PF | 25)
+#define PC26_PF_SSI2_TXD	(GPIO_PORTC | GPIO_IN  | GPIO_PF | 26)
+#define PC27_PF_SSI2_CLK	(GPIO_PORTC | GPIO_IN  | GPIO_PF | 27)
+#define PC28_PF_SSI3_FS		(GPIO_PORTC | GPIO_IN  | GPIO_PF | 28)
+#define PC29_PF_SSI3_RXD	(GPIO_PORTC | GPIO_IN  | GPIO_PF | 29)
+#define PC30_PF_SSI3_TXD	(GPIO_PORTC | GPIO_IN  | GPIO_PF | 30)
+#define PC31_PF_SSI3_CLK	(GPIO_PORTC | GPIO_IN  | GPIO_PF | 31)
+#define PD0_AIN_FEC_TXD0	(GPIO_PORTD | GPIO_OUT | GPIO_AIN | 0)
+#define PD1_AIN_FEC_TXD1	(GPIO_PORTD | GPIO_OUT | GPIO_AIN | 1)
+#define PD2_AIN_FEC_TXD2	(GPIO_PORTD | GPIO_OUT | GPIO_AIN | 2)
+#define PD3_AIN_FEC_TXD3	(GPIO_PORTD | GPIO_OUT | GPIO_AIN | 3)
+#define PD4_AOUT_FEC_RX_ER	(GPIO_PORTD | GPIO_IN | GPIO_AOUT | 4)
+#define PD5_AOUT_FEC_RXD1	(GPIO_PORTD | GPIO_IN | GPIO_AOUT | 5)
+#define PD6_AOUT_FEC_RXD2	(GPIO_PORTD | GPIO_IN | GPIO_AOUT | 6)
+#define PD7_AOUT_FEC_RXD3	(GPIO_PORTD | GPIO_IN | GPIO_AOUT | 7)
+#define PD8_AF_FEC_MDIO		(GPIO_PORTD | GPIO_IN | GPIO_AF | 8)
+#define PD9_AIN_FEC_MDC		(GPIO_PORTD | GPIO_OUT | GPIO_AIN | 9)
+#define PD10_AOUT_FEC_CRS	(GPIO_PORTD | GPIO_IN | GPIO_AOUT | 10)
+#define PD11_AOUT_FEC_TX_CLK	(GPIO_PORTD | GPIO_IN | GPIO_AOUT | 11)
+#define PD12_AOUT_FEC_RXD0	(GPIO_PORTD | GPIO_IN | GPIO_AOUT | 12)
+#define PD13_AOUT_FEC_RX_DV	(GPIO_PORTD | GPIO_IN | GPIO_AOUT | 13)
+#define PD14_AOUT_FEC_CLR	(GPIO_PORTD | GPIO_IN | GPIO_AOUT | 14)
+#define PD15_AOUT_FEC_COL	(GPIO_PORTD | GPIO_IN | GPIO_AOUT | 15)
+#define PD16_AIN_FEC_TX_ER	(GPIO_PORTD | GPIO_OUT | GPIO_AIN | 16)
+#define PD17_PF_I2C_DATA	(GPIO_PORTD | GPIO_OUT | GPIO_PF | 17)
+#define PD18_PF_I2C_CLK		(GPIO_PORTD | GPIO_OUT | GPIO_PF | 18)
+#define PD25_PF_CSPI1_RDY	(GPIO_PORTD | GPIO_OUT | GPIO_PF  | 25)
+#define PD26_PF_CSPI1_SS2	(GPIO_PORTD | GPIO_OUT | GPIO_PF  | 26)
+#define PD27_PF_CSPI1_SS1	(GPIO_PORTD | GPIO_OUT | GPIO_PF  | 27)
+#define PD28_PF_CSPI1_SS0	(GPIO_PORTD | GPIO_OUT | GPIO_PF  | 28)
+#define PD29_PF_CSPI1_SCLK	(GPIO_PORTD | GPIO_OUT | GPIO_PF  | 29)
+#define PD30_PF_CSPI1_MISO	(GPIO_PORTD | GPIO_IN | GPIO_PF  | 30)
+#define PD31_PF_CSPI1_MOSI	(GPIO_PORTD | GPIO_OUT | GPIO_PF  | 31)
+#define PF23_AIN_FEC_TX_EN	(GPIO_PORTF | GPIO_OUT | GPIO_AIN | 23)
+#define PE3_PF_UART2_CTS	(GPIO_PORTE | GPIO_OUT | GPIO_PF | 3)
+#define PE4_PF_UART2_RTS	(GPIO_PORTE | GPIO_IN  | GPIO_PF | 4)
+#define PE6_PF_UART2_TXD	(GPIO_PORTE | GPIO_OUT | GPIO_PF | 6)
+#define PE7_PF_UART2_RXD	(GPIO_PORTE | GPIO_IN  | GPIO_PF | 7)
+#define PE8_PF_UART3_TXD	(GPIO_PORTE | GPIO_OUT | GPIO_PF | 8)
+#define PE9_PF_UART3_RXD	(GPIO_PORTE | GPIO_IN  | GPIO_PF | 9)
+#define PE10_PF_UART3_CTS	(GPIO_PORTE | GPIO_OUT | GPIO_PF | 10)
+#define PE11_PF_UART3_RTS	(GPIO_PORTE | GPIO_IN  | GPIO_PF | 11)
+#define PE12_PF_UART1_TXD	(GPIO_PORTE | GPIO_OUT | GPIO_PF | 12)
+#define PE13_PF_UART1_RXD	(GPIO_PORTE | GPIO_IN  | GPIO_PF | 13)
+#define PE14_PF_UART1_CTS	(GPIO_PORTE | GPIO_OUT | GPIO_PF | 14)
+#define PE15_PF_UART1_RTS	(GPIO_PORTE | GPIO_IN  | GPIO_PF | 15)
+#define PE18_AF_CSPI3_MISO	(GPIO_PORTE | GPIO_IN  | GPIO_AF | 18)
+#define PE21_AF_CSPI3_SS	(GPIO_PORTE | GPIO_OUT | GPIO_AF | 21)
+#define PE22_AF_CSPI3_MOSI	(GPIO_PORTE | GPIO_OUT | GPIO_AF | 22)
+#define PE23_AF_CSPI3_SCLK	(GPIO_PORTE | GPIO_OUT | GPIO_AF | 23)
+#endif
+
+/* decode irq number to use with IMR(x), ISR(x) and friends */
+#define IRQ_TO_REG(irq) ((irq - MXC_MAX_INT_LINES) >> 5)
+
+#define IRQ_GPIOA(x)  (MXC_MAX_INT_LINES + x)
+#define IRQ_GPIOB(x)  (IRQ_GPIOA(32) + x)
+#define IRQ_GPIOC(x)  (IRQ_GPIOB(32) + x)
+#define IRQ_GPIOD(x)  (IRQ_GPIOC(32) + x)
+
+#endif /* _MXC_GPIO_MX1_MX2_H */
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/iomux-mx3.h ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/iomux-mx3.h
--- adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/iomux-mx3.h	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/iomux-mx3.h	2008-10-19 15:15:34.000000000 +0200
@@ -0,0 +1,501 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2008 by Sascha Hauer <kernel@pengutronix.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ */
+
+#ifndef __MACH_MX31_IOMUX_H__
+#define __MACH_MX31_IOMUX_H__
+
+#include <linux/types.h>
+
+/*
+ * various IOMUX output functions
+ */
+
+#define	IOMUX_OCONFIG_GPIO (0 << 4)	/* used as GPIO */
+#define	IOMUX_OCONFIG_FUNC (1 << 4)	/* used as function */
+#define	IOMUX_OCONFIG_ALT1 (2 << 4)	/* used as alternate function 1 */
+#define	IOMUX_OCONFIG_ALT2 (3 << 4)	/* used as alternate function 2 */
+#define	IOMUX_OCONFIG_ALT3 (4 << 4)	/* used as alternate function 3 */
+#define	IOMUX_OCONFIG_ALT4 (5 << 4)	/* used as alternate function 4 */
+#define	IOMUX_OCONFIG_ALT5 (6 << 4)	/* used as alternate function 5 */
+#define	IOMUX_OCONFIG_ALT6 (7 << 4)	/* used as alternate function 6 */
+#define	IOMUX_ICONFIG_NONE  0	 	/* not configured for input */
+#define	IOMUX_ICONFIG_GPIO  1		/* used as GPIO */
+#define	IOMUX_ICONFIG_FUNC  2		/* used as function */
+#define	IOMUX_ICONFIG_ALT1  4		/* used as alternate function 1 */
+#define	IOMUX_ICONFIG_ALT2  8		/* used as alternate function 2 */
+
+#define IOMUX_CONFIG_GPIO (IOMUX_OCONFIG_GPIO | IOMUX_ICONFIG_GPIO)
+#define IOMUX_CONFIG_FUNC (IOMUX_OCONFIG_FUNC | IOMUX_ICONFIG_FUNC)
+#define IOMUX_CONFIG_ALT1 (IOMUX_OCONFIG_ALT1 | IOMUX_ICONFIG_ALT1)
+#define IOMUX_CONFIG_ALT2 (IOMUX_OCONFIG_ALT2 | IOMUX_ICONFIG_ALT2)
+
+/*
+ * various IOMUX pad functions
+ */
+enum iomux_pad_config {
+	PAD_CTL_NOLOOPBACK	= 0x0 << 9,
+	PAD_CTL_LOOPBACK	= 0x1 << 9,
+	PAD_CTL_PKE_NONE	= 0x0 << 8,
+	PAD_CTL_PKE_ENABLE	= 0x1 << 8,
+	PAD_CTL_PUE_KEEPER	= 0x0 << 7,
+	PAD_CTL_PUE_PUD		= 0x1 << 7,
+	PAD_CTL_100K_PD		= 0x0 << 5,
+	PAD_CTL_100K_PU		= 0x1 << 5,
+	PAD_CTL_47K_PU		= 0x2 << 5,
+	PAD_CTL_22K_PU		= 0x3 << 5,
+	PAD_CTL_HYS_CMOS	= 0x0 << 4,
+	PAD_CTL_HYS_SCHMITZ	= 0x1 << 4,
+	PAD_CTL_ODE_CMOS	= 0x0 << 3,
+	PAD_CTL_ODE_OpenDrain	= 0x1 << 3,
+	PAD_CTL_DRV_NORMAL	= 0x0 << 1,
+	PAD_CTL_DRV_HIGH	= 0x1 << 1,
+	PAD_CTL_DRV_MAX		= 0x2 << 1,
+	PAD_CTL_SRE_SLOW	= 0x0 << 0,
+	PAD_CTL_SRE_FAST	= 0x1 << 0
+};
+
+/*
+ * various IOMUX general purpose functions
+ */
+enum iomux_gp_func {
+	MUX_PGP_FIRI			= 1 << 0,
+	MUX_DDR_MODE			= 1 << 1,
+	MUX_PGP_CSPI_BB			= 1 << 2,
+	MUX_PGP_ATA_1			= 1 << 3,
+	MUX_PGP_ATA_2			= 1 << 4,
+	MUX_PGP_ATA_3			= 1 << 5,
+	MUX_PGP_ATA_4			= 1 << 6,
+	MUX_PGP_ATA_5			= 1 << 7,
+	MUX_PGP_ATA_6			= 1 << 8,
+	MUX_PGP_ATA_7			= 1 << 9,
+	MUX_PGP_ATA_8			= 1 << 10,
+	MUX_PGP_UH2			= 1 << 11,
+	MUX_SDCTL_CSD0_SEL		= 1 << 12,
+	MUX_SDCTL_CSD1_SEL		= 1 << 13,
+	MUX_CSPI1_UART3			= 1 << 14,
+	MUX_EXTDMAREQ2_MBX_SEL		= 1 << 15,
+	MUX_TAMPER_DETECT_EN		= 1 << 16,
+	MUX_PGP_USB_4WIRE		= 1 << 17,
+	MUX_PGB_USB_COMMON		= 1 << 18,
+	MUX_SDHC_MEMSTICK1		= 1 << 19,
+	MUX_SDHC_MEMSTICK2		= 1 << 20,
+	MUX_PGP_SPLL_BYP		= 1 << 21,
+	MUX_PGP_UPLL_BYP		= 1 << 22,
+	MUX_PGP_MSHC1_CLK_SEL		= 1 << 23,
+	MUX_PGP_MSHC2_CLK_SEL		= 1 << 24,
+	MUX_CSPI3_UART5_SEL		= 1 << 25,
+	MUX_PGP_ATA_9			= 1 << 26,
+	MUX_PGP_USB_SUSPEND		= 1 << 27,
+	MUX_PGP_USB_OTG_LOOPBACK	= 1 << 28,
+	MUX_PGP_USB_HS1_LOOPBACK	= 1 << 29,
+	MUX_PGP_USB_HS2_LOOPBACK	= 1 << 30,
+	MUX_CLKO_DDR_MODE		= 1 << 31,
+};
+
+/*
+ * This function enables/disables the general purpose function for a particular
+ * signal.
+ */
+void iomux_config_gpr(enum iomux_gp_func , bool);
+
+/*
+ * set the mode for a IOMUX pin.
+ */
+int mxc_iomux_mode(unsigned int);
+
+/*
+ * This function enables/disables the general purpose function for a particular
+ * signal.
+ */
+void mxc_iomux_set_gpr(enum iomux_gp_func, bool);
+
+#define IOMUX_PADNUM_MASK	0x1ff
+#define IOMUX_GPIONUM_SHIFT	9
+#define IOMUX_GPIONUM_MASK	(0xff << IOMUX_GPIONUM_SHIFT)
+#define IOMUX_MODE_SHIFT	17
+#define IOMUX_MODE_MASK	(0xff << IOMUX_MODE_SHIFT)
+
+#define IOMUX_PIN(gpionum, padnum) \
+	(((gpionum << IOMUX_GPIONUM_SHIFT) & IOMUX_GPIONUM_MASK) | \
+	 (padnum & IOMUX_PADNUM_MASK))
+
+#define IOMUX_MODE(pin, mode) (pin | mode << IOMUX_MODE_SHIFT)
+
+#define IOMUX_TO_GPIO(iomux_pin) \
+	((iomux_pin & IOMUX_GPIONUM_MASK) >> IOMUX_GPIONUM_SHIFT)
+#define IOMUX_TO_IRQ(iomux_pin) \
+	(((iomux_pin & IOMUX_GPIONUM_MASK) >> IOMUX_GPIONUM_SHIFT) + \
+	MXC_GPIO_INT_BASE)
+
+/*
+ * This enumeration is constructed based on the Section
+ * "sw_pad_ctl & sw_mux_ctl details" of the MX31 IC Spec. Each enumerated
+ * value is constructed based on the rules described above.
+ */
+
+enum iomux_pins {
+	MX31_PIN_TTM_PAD	= IOMUX_PIN(0xff,   0),
+	MX31_PIN_CSPI3_SPI_RDY	= IOMUX_PIN(0xff,   1),
+	MX31_PIN_CSPI3_SCLK	= IOMUX_PIN(0xff,   2),
+	MX31_PIN_CSPI3_MISO	= IOMUX_PIN(0xff,   3),
+	MX31_PIN_CSPI3_MOSI	= IOMUX_PIN(0xff,   4),
+	MX31_PIN_CLKSS		= IOMUX_PIN(0xff,   5),
+	MX31_PIN_CE_CONTROL	= IOMUX_PIN(0xff,   6),
+	MX31_PIN_ATA_RESET_B	= IOMUX_PIN(95,     7),
+	MX31_PIN_ATA_DMACK	= IOMUX_PIN(94,     8),
+	MX31_PIN_ATA_DIOW	= IOMUX_PIN(93,     9),
+	MX31_PIN_ATA_DIOR	= IOMUX_PIN(92,    10),
+	MX31_PIN_ATA_CS1	= IOMUX_PIN(91,    11),
+	MX31_PIN_ATA_CS0	= IOMUX_PIN(90,    12),
+	MX31_PIN_SD1_DATA3	= IOMUX_PIN(63,    13),
+	MX31_PIN_SD1_DATA2	= IOMUX_PIN(62,    14),
+	MX31_PIN_SD1_DATA1	= IOMUX_PIN(61,    15),
+	MX31_PIN_SD1_DATA0	= IOMUX_PIN(60,    16),
+	MX31_PIN_SD1_CLK	= IOMUX_PIN(59,    17),
+	MX31_PIN_SD1_CMD	= IOMUX_PIN(58,    18),
+	MX31_PIN_D3_SPL		= IOMUX_PIN(0xff,  19),
+	MX31_PIN_D3_CLS		= IOMUX_PIN(0xff,  20),
+	MX31_PIN_D3_REV		= IOMUX_PIN(0xff,  21),
+	MX31_PIN_CONTRAST	= IOMUX_PIN(0xff,  22),
+	MX31_PIN_VSYNC3		= IOMUX_PIN(0xff,  23),
+	MX31_PIN_READ		= IOMUX_PIN(0xff,  24),
+	MX31_PIN_WRITE		= IOMUX_PIN(0xff,  25),
+	MX31_PIN_PAR_RS		= IOMUX_PIN(0xff,  26),
+	MX31_PIN_SER_RS		= IOMUX_PIN(89,    27),
+	MX31_PIN_LCS1		= IOMUX_PIN(88,    28),
+	MX31_PIN_LCS0		= IOMUX_PIN(87,    29),
+	MX31_PIN_SD_D_CLK	= IOMUX_PIN(86,    30),
+	MX31_PIN_SD_D_IO	= IOMUX_PIN(85,    31),
+	MX31_PIN_SD_D_I		= IOMUX_PIN(84,    32),
+	MX31_PIN_DRDY0		= IOMUX_PIN(0xff,  33),
+	MX31_PIN_FPSHIFT	= IOMUX_PIN(0xff,  34),
+	MX31_PIN_HSYNC		= IOMUX_PIN(0xff,  35),
+	MX31_PIN_VSYNC0		= IOMUX_PIN(0xff,  36),
+	MX31_PIN_LD17		= IOMUX_PIN(0xff,  37),
+	MX31_PIN_LD16		= IOMUX_PIN(0xff,  38),
+	MX31_PIN_LD15		= IOMUX_PIN(0xff,  39),
+	MX31_PIN_LD14		= IOMUX_PIN(0xff,  40),
+	MX31_PIN_LD13		= IOMUX_PIN(0xff,  41),
+	MX31_PIN_LD12		= IOMUX_PIN(0xff,  42),
+	MX31_PIN_LD11		= IOMUX_PIN(0xff,  43),
+	MX31_PIN_LD10		= IOMUX_PIN(0xff,  44),
+	MX31_PIN_LD9		= IOMUX_PIN(0xff,  45),
+	MX31_PIN_LD8		= IOMUX_PIN(0xff,  46),
+	MX31_PIN_LD7		= IOMUX_PIN(0xff,  47),
+	MX31_PIN_LD6		= IOMUX_PIN(0xff,  48),
+	MX31_PIN_LD5		= IOMUX_PIN(0xff,  49),
+	MX31_PIN_LD4		= IOMUX_PIN(0xff,  50),
+	MX31_PIN_LD3		= IOMUX_PIN(0xff,  51),
+	MX31_PIN_LD2		= IOMUX_PIN(0xff,  52),
+	MX31_PIN_LD1		= IOMUX_PIN(0xff,  53),
+	MX31_PIN_LD0		= IOMUX_PIN(0xff,  54),
+	MX31_PIN_USBH2_DATA1	= IOMUX_PIN(0xff,  55),
+	MX31_PIN_USBH2_DATA0	= IOMUX_PIN(0xff,  56),
+	MX31_PIN_USBH2_NXT	= IOMUX_PIN(0xff,  57),
+	MX31_PIN_USBH2_STP	= IOMUX_PIN(0xff,  58),
+	MX31_PIN_USBH2_DIR	= IOMUX_PIN(0xff,  59),
+	MX31_PIN_USBH2_CLK	= IOMUX_PIN(0xff,  60),
+	MX31_PIN_USBOTG_DATA7	= IOMUX_PIN(0xff,  61),
+	MX31_PIN_USBOTG_DATA6	= IOMUX_PIN(0xff,  62),
+	MX31_PIN_USBOTG_DATA5	= IOMUX_PIN(0xff,  63),
+	MX31_PIN_USBOTG_DATA4	= IOMUX_PIN(0xff,  64),
+	MX31_PIN_USBOTG_DATA3	= IOMUX_PIN(0xff,  65),
+	MX31_PIN_USBOTG_DATA2	= IOMUX_PIN(0xff,  66),
+	MX31_PIN_USBOTG_DATA1	= IOMUX_PIN(0xff,  67),
+	MX31_PIN_USBOTG_DATA0	= IOMUX_PIN(0xff,  68),
+	MX31_PIN_USBOTG_NXT	= IOMUX_PIN(0xff,  69),
+	MX31_PIN_USBOTG_STP	= IOMUX_PIN(0xff,  70),
+	MX31_PIN_USBOTG_DIR	= IOMUX_PIN(0xff,  71),
+	MX31_PIN_USBOTG_CLK	= IOMUX_PIN(0xff,  72),
+	MX31_PIN_USB_BYP	= IOMUX_PIN(31,    73),
+	MX31_PIN_USB_OC		= IOMUX_PIN(30,    74),
+	MX31_PIN_USB_PWR	= IOMUX_PIN(29,    75),
+	MX31_PIN_SJC_MOD	= IOMUX_PIN(0xff,  76),
+	MX31_PIN_DE_B		= IOMUX_PIN(0xff,  77),
+	MX31_PIN_TRSTB		= IOMUX_PIN(0xff,  78),
+	MX31_PIN_TDO		= IOMUX_PIN(0xff,  79),
+	MX31_PIN_TDI		= IOMUX_PIN(0xff,  80),
+	MX31_PIN_TMS		= IOMUX_PIN(0xff,  81),
+	MX31_PIN_TCK		= IOMUX_PIN(0xff,  82),
+	MX31_PIN_RTCK		= IOMUX_PIN(0xff,  83),
+	MX31_PIN_KEY_COL7	= IOMUX_PIN(57,    84),
+	MX31_PIN_KEY_COL6	= IOMUX_PIN(56,    85),
+	MX31_PIN_KEY_COL5	= IOMUX_PIN(55,    86),
+	MX31_PIN_KEY_COL4	= IOMUX_PIN(54,    87),
+	MX31_PIN_KEY_COL3	= IOMUX_PIN(0xff,  88),
+	MX31_PIN_KEY_COL2	= IOMUX_PIN(0xff,  89),
+	MX31_PIN_KEY_COL1	= IOMUX_PIN(0xff,  90),
+	MX31_PIN_KEY_COL0	= IOMUX_PIN(0xff,  91),
+	MX31_PIN_KEY_ROW7	= IOMUX_PIN(53,    92),
+	MX31_PIN_KEY_ROW6	= IOMUX_PIN(52,    93),
+	MX31_PIN_KEY_ROW5	= IOMUX_PIN(51,    94),
+	MX31_PIN_KEY_ROW4	= IOMUX_PIN(50,    95),
+	MX31_PIN_KEY_ROW3	= IOMUX_PIN(0xff,  96),
+	MX31_PIN_KEY_ROW2	= IOMUX_PIN(0xff,  97),
+	MX31_PIN_KEY_ROW1	= IOMUX_PIN(0xff,  98),
+	MX31_PIN_KEY_ROW0	= IOMUX_PIN(0xff,  99),
+	MX31_PIN_BATT_LINE	= IOMUX_PIN(49,   100),
+	MX31_PIN_CTS2		= IOMUX_PIN(0xff, 101),
+	MX31_PIN_RTS2		= IOMUX_PIN(0xff, 102),
+	MX31_PIN_TXD2		= IOMUX_PIN(28,   103),
+	MX31_PIN_RXD2		= IOMUX_PIN(27,   104),
+	MX31_PIN_DTR_DCE2	= IOMUX_PIN(48,   105),
+	MX31_PIN_DCD_DTE1	= IOMUX_PIN(47,   106),
+	MX31_PIN_RI_DTE1	= IOMUX_PIN(46,   107),
+	MX31_PIN_DSR_DTE1	= IOMUX_PIN(45,   108),
+	MX31_PIN_DTR_DTE1	= IOMUX_PIN(44,   109),
+	MX31_PIN_DCD_DCE1	= IOMUX_PIN(43,   110),
+	MX31_PIN_RI_DCE1	= IOMUX_PIN(42,   111),
+	MX31_PIN_DSR_DCE1	= IOMUX_PIN(41,   112),
+	MX31_PIN_DTR_DCE1	= IOMUX_PIN(40,   113),
+	MX31_PIN_CTS1		= IOMUX_PIN(39,   114),
+	MX31_PIN_RTS1		= IOMUX_PIN(38,   115),
+	MX31_PIN_TXD1		= IOMUX_PIN(37,   116),
+	MX31_PIN_RXD1		= IOMUX_PIN(36,   117),
+	MX31_PIN_CSPI2_SPI_RDY	= IOMUX_PIN(0xff, 118),
+	MX31_PIN_CSPI2_SCLK	= IOMUX_PIN(0xff, 119),
+	MX31_PIN_CSPI2_SS2	= IOMUX_PIN(0xff, 120),
+	MX31_PIN_CSPI2_SS1	= IOMUX_PIN(0xff, 121),
+	MX31_PIN_CSPI2_SS0	= IOMUX_PIN(0xff, 122),
+	MX31_PIN_CSPI2_MISO	= IOMUX_PIN(0xff, 123),
+	MX31_PIN_CSPI2_MOSI	= IOMUX_PIN(0xff, 124),
+	MX31_PIN_CSPI1_SPI_RDY	= IOMUX_PIN(0xff, 125),
+	MX31_PIN_CSPI1_SCLK	= IOMUX_PIN(0xff, 126),
+	MX31_PIN_CSPI1_SS2	= IOMUX_PIN(0xff, 127),
+	MX31_PIN_CSPI1_SS1	= IOMUX_PIN(0xff, 128),
+	MX31_PIN_CSPI1_SS0	= IOMUX_PIN(0xff, 129),
+	MX31_PIN_CSPI1_MISO	= IOMUX_PIN(0xff, 130),
+	MX31_PIN_CSPI1_MOSI	= IOMUX_PIN(0xff, 131),
+	MX31_PIN_SFS6		= IOMUX_PIN(26,   132),
+	MX31_PIN_SCK6		= IOMUX_PIN(25,   133),
+	MX31_PIN_SRXD6		= IOMUX_PIN(24,   134),
+	MX31_PIN_STXD6		= IOMUX_PIN(23,   135),
+	MX31_PIN_SFS5		= IOMUX_PIN(0xff, 136),
+	MX31_PIN_SCK5		= IOMUX_PIN(0xff, 137),
+	MX31_PIN_SRXD5		= IOMUX_PIN(22,   138),
+	MX31_PIN_STXD5		= IOMUX_PIN(21,   139),
+	MX31_PIN_SFS4		= IOMUX_PIN(0xff, 140),
+	MX31_PIN_SCK4		= IOMUX_PIN(0xff, 141),
+	MX31_PIN_SRXD4		= IOMUX_PIN(20,   142),
+	MX31_PIN_STXD4		= IOMUX_PIN(19,   143),
+	MX31_PIN_SFS3		= IOMUX_PIN(0xff, 144),
+	MX31_PIN_SCK3		= IOMUX_PIN(0xff, 145),
+	MX31_PIN_SRXD3		= IOMUX_PIN(18,   146),
+	MX31_PIN_STXD3		= IOMUX_PIN(17,   147),
+	MX31_PIN_I2C_DAT	= IOMUX_PIN(0xff, 148),
+	MX31_PIN_I2C_CLK	= IOMUX_PIN(0xff, 149),
+	MX31_PIN_CSI_PIXCLK	= IOMUX_PIN(83,   150),
+	MX31_PIN_CSI_HSYNC	= IOMUX_PIN(82,   151),
+	MX31_PIN_CSI_VSYNC	= IOMUX_PIN(81,   152),
+	MX31_PIN_CSI_MCLK	= IOMUX_PIN(80,   153),
+	MX31_PIN_CSI_D15	= IOMUX_PIN(79,   154),
+	MX31_PIN_CSI_D14	= IOMUX_PIN(78,   155),
+	MX31_PIN_CSI_D13	= IOMUX_PIN(77,   156),
+	MX31_PIN_CSI_D12	= IOMUX_PIN(76,   157),
+	MX31_PIN_CSI_D11	= IOMUX_PIN(75,   158),
+	MX31_PIN_CSI_D10	= IOMUX_PIN(74,   159),
+	MX31_PIN_CSI_D9		= IOMUX_PIN(73,   160),
+	MX31_PIN_CSI_D8		= IOMUX_PIN(72,   161),
+	MX31_PIN_CSI_D7		= IOMUX_PIN(71,   162),
+	MX31_PIN_CSI_D6		= IOMUX_PIN(70,   163),
+	MX31_PIN_CSI_D5		= IOMUX_PIN(69,   164),
+	MX31_PIN_CSI_D4		= IOMUX_PIN(68,   165),
+	MX31_PIN_M_GRANT	= IOMUX_PIN(0xff, 166),
+	MX31_PIN_M_REQUEST	= IOMUX_PIN(0xff, 167),
+	MX31_PIN_PC_POE		= IOMUX_PIN(0xff, 168),
+	MX31_PIN_PC_RW_B	= IOMUX_PIN(0xff, 169),
+	MX31_PIN_IOIS16		= IOMUX_PIN(0xff, 170),
+	MX31_PIN_PC_RST		= IOMUX_PIN(0xff, 171),
+	MX31_PIN_PC_BVD2	= IOMUX_PIN(0xff, 172),
+	MX31_PIN_PC_BVD1	= IOMUX_PIN(0xff, 173),
+	MX31_PIN_PC_VS2		= IOMUX_PIN(0xff, 174),
+	MX31_PIN_PC_VS1		= IOMUX_PIN(0xff, 175),
+	MX31_PIN_PC_PWRON	= IOMUX_PIN(0xff, 176),
+	MX31_PIN_PC_READY	= IOMUX_PIN(0xff, 177),
+	MX31_PIN_PC_WAIT_B	= IOMUX_PIN(0xff, 178),
+	MX31_PIN_PC_CD2_B	= IOMUX_PIN(0xff, 179),
+	MX31_PIN_PC_CD1_B	= IOMUX_PIN(0xff, 180),
+	MX31_PIN_D0		= IOMUX_PIN(0xff, 181),
+	MX31_PIN_D1		= IOMUX_PIN(0xff, 182),
+	MX31_PIN_D2		= IOMUX_PIN(0xff, 183),
+	MX31_PIN_D3		= IOMUX_PIN(0xff, 184),
+	MX31_PIN_D4		= IOMUX_PIN(0xff, 185),
+	MX31_PIN_D5		= IOMUX_PIN(0xff, 186),
+	MX31_PIN_D6		= IOMUX_PIN(0xff, 187),
+	MX31_PIN_D7		= IOMUX_PIN(0xff, 188),
+	MX31_PIN_D8		= IOMUX_PIN(0xff, 189),
+	MX31_PIN_D9		= IOMUX_PIN(0xff, 190),
+	MX31_PIN_D10		= IOMUX_PIN(0xff, 191),
+	MX31_PIN_D11		= IOMUX_PIN(0xff, 192),
+	MX31_PIN_D12		= IOMUX_PIN(0xff, 193),
+	MX31_PIN_D13		= IOMUX_PIN(0xff, 194),
+	MX31_PIN_D14		= IOMUX_PIN(0xff, 195),
+	MX31_PIN_D15		= IOMUX_PIN(0xff, 196),
+	MX31_PIN_NFRB		= IOMUX_PIN(16,   197),
+	MX31_PIN_NFCE_B		= IOMUX_PIN(15,   198),
+	MX31_PIN_NFWP_B		= IOMUX_PIN(14,   199),
+	MX31_PIN_NFCLE		= IOMUX_PIN(13,   200),
+	MX31_PIN_NFALE		= IOMUX_PIN(12,   201),
+	MX31_PIN_NFRE_B		= IOMUX_PIN(11,   202),
+	MX31_PIN_NFWE_B		= IOMUX_PIN(10,   203),
+	MX31_PIN_SDQS3		= IOMUX_PIN(0xff, 204),
+	MX31_PIN_SDQS2		= IOMUX_PIN(0xff, 205),
+	MX31_PIN_SDQS1		= IOMUX_PIN(0xff, 206),
+	MX31_PIN_SDQS0		= IOMUX_PIN(0xff, 207),
+	MX31_PIN_SDCLK_B	= IOMUX_PIN(0xff, 208),
+	MX31_PIN_SDCLK		= IOMUX_PIN(0xff, 209),
+	MX31_PIN_SDCKE1		= IOMUX_PIN(0xff, 210),
+	MX31_PIN_SDCKE0		= IOMUX_PIN(0xff, 211),
+	MX31_PIN_SDWE		= IOMUX_PIN(0xff, 212),
+	MX31_PIN_CAS		= IOMUX_PIN(0xff, 213),
+	MX31_PIN_RAS		= IOMUX_PIN(0xff, 214),
+	MX31_PIN_RW		= IOMUX_PIN(0xff, 215),
+	MX31_PIN_BCLK		= IOMUX_PIN(0xff, 216),
+	MX31_PIN_LBA		= IOMUX_PIN(0xff, 217),
+	MX31_PIN_ECB		= IOMUX_PIN(0xff, 218),
+	MX31_PIN_CS5		= IOMUX_PIN(0xff, 219),
+	MX31_PIN_CS4		= IOMUX_PIN(0xff, 220),
+	MX31_PIN_CS3		= IOMUX_PIN(0xff, 221),
+	MX31_PIN_CS2		= IOMUX_PIN(0xff, 222),
+	MX31_PIN_CS1		= IOMUX_PIN(0xff, 223),
+	MX31_PIN_CS0		= IOMUX_PIN(0xff, 224),
+	MX31_PIN_OE		= IOMUX_PIN(0xff, 225),
+	MX31_PIN_EB1		= IOMUX_PIN(0xff, 226),
+	MX31_PIN_EB0		= IOMUX_PIN(0xff, 227),
+	MX31_PIN_DQM3		= IOMUX_PIN(0xff, 228),
+	MX31_PIN_DQM2		= IOMUX_PIN(0xff, 229),
+	MX31_PIN_DQM1		= IOMUX_PIN(0xff, 230),
+	MX31_PIN_DQM0		= IOMUX_PIN(0xff, 231),
+	MX31_PIN_SD31		= IOMUX_PIN(0xff, 232),
+	MX31_PIN_SD30		= IOMUX_PIN(0xff, 233),
+	MX31_PIN_SD29		= IOMUX_PIN(0xff, 234),
+	MX31_PIN_SD28		= IOMUX_PIN(0xff, 235),
+	MX31_PIN_SD27		= IOMUX_PIN(0xff, 236),
+	MX31_PIN_SD26		= IOMUX_PIN(0xff, 237),
+	MX31_PIN_SD25		= IOMUX_PIN(0xff, 238),
+	MX31_PIN_SD24		= IOMUX_PIN(0xff, 239),
+	MX31_PIN_SD23		= IOMUX_PIN(0xff, 240),
+	MX31_PIN_SD22		= IOMUX_PIN(0xff, 241),
+	MX31_PIN_SD21		= IOMUX_PIN(0xff, 242),
+	MX31_PIN_SD20		= IOMUX_PIN(0xff, 243),
+	MX31_PIN_SD19		= IOMUX_PIN(0xff, 244),
+	MX31_PIN_SD18		= IOMUX_PIN(0xff, 245),
+	MX31_PIN_SD17		= IOMUX_PIN(0xff, 246),
+	MX31_PIN_SD16		= IOMUX_PIN(0xff, 247),
+	MX31_PIN_SD15		= IOMUX_PIN(0xff, 248),
+	MX31_PIN_SD14		= IOMUX_PIN(0xff, 249),
+	MX31_PIN_SD13		= IOMUX_PIN(0xff, 250),
+	MX31_PIN_SD12		= IOMUX_PIN(0xff, 251),
+	MX31_PIN_SD11		= IOMUX_PIN(0xff, 252),
+	MX31_PIN_SD10		= IOMUX_PIN(0xff, 253),
+	MX31_PIN_SD9		= IOMUX_PIN(0xff, 254),
+	MX31_PIN_SD8		= IOMUX_PIN(0xff, 255),
+	MX31_PIN_SD7		= IOMUX_PIN(0xff, 256),
+	MX31_PIN_SD6		= IOMUX_PIN(0xff, 257),
+	MX31_PIN_SD5		= IOMUX_PIN(0xff, 258),
+	MX31_PIN_SD4		= IOMUX_PIN(0xff, 259),
+	MX31_PIN_SD3		= IOMUX_PIN(0xff, 260),
+	MX31_PIN_SD2		= IOMUX_PIN(0xff, 261),
+	MX31_PIN_SD1		= IOMUX_PIN(0xff, 262),
+	MX31_PIN_SD0		= IOMUX_PIN(0xff, 263),
+	MX31_PIN_SDBA0		= IOMUX_PIN(0xff, 264),
+	MX31_PIN_SDBA1		= IOMUX_PIN(0xff, 265),
+	MX31_PIN_A25		= IOMUX_PIN(0xff, 266),
+	MX31_PIN_A24		= IOMUX_PIN(0xff, 267),
+	MX31_PIN_A23		= IOMUX_PIN(0xff, 268),
+	MX31_PIN_A22		= IOMUX_PIN(0xff, 269),
+	MX31_PIN_A21		= IOMUX_PIN(0xff, 270),
+	MX31_PIN_A20		= IOMUX_PIN(0xff, 271),
+	MX31_PIN_A19		= IOMUX_PIN(0xff, 272),
+	MX31_PIN_A18		= IOMUX_PIN(0xff, 273),
+	MX31_PIN_A17		= IOMUX_PIN(0xff, 274),
+	MX31_PIN_A16		= IOMUX_PIN(0xff, 275),
+	MX31_PIN_A14		= IOMUX_PIN(0xff, 276),
+	MX31_PIN_A15		= IOMUX_PIN(0xff, 277),
+	MX31_PIN_A13		= IOMUX_PIN(0xff, 278),
+	MX31_PIN_A12		= IOMUX_PIN(0xff, 279),
+	MX31_PIN_A11		= IOMUX_PIN(0xff, 280),
+	MX31_PIN_MA10		= IOMUX_PIN(0xff, 281),
+	MX31_PIN_A10		= IOMUX_PIN(0xff, 282),
+	MX31_PIN_A9		= IOMUX_PIN(0xff, 283),
+	MX31_PIN_A8		= IOMUX_PIN(0xff, 284),
+	MX31_PIN_A7		= IOMUX_PIN(0xff, 285),
+	MX31_PIN_A6		= IOMUX_PIN(0xff, 286),
+	MX31_PIN_A5		= IOMUX_PIN(0xff, 287),
+	MX31_PIN_A4		= IOMUX_PIN(0xff, 288),
+	MX31_PIN_A3		= IOMUX_PIN(0xff, 289),
+	MX31_PIN_A2		= IOMUX_PIN(0xff, 290),
+	MX31_PIN_A1		= IOMUX_PIN(0xff, 291),
+	MX31_PIN_A0		= IOMUX_PIN(0xff, 292),
+	MX31_PIN_VPG1		= IOMUX_PIN(0xff, 293),
+	MX31_PIN_VPG0		= IOMUX_PIN(0xff, 294),
+	MX31_PIN_DVFS1		= IOMUX_PIN(0xff, 295),
+	MX31_PIN_DVFS0		= IOMUX_PIN(0xff, 296),
+	MX31_PIN_VSTBY		= IOMUX_PIN(0xff, 297),
+	MX31_PIN_POWER_FAIL	= IOMUX_PIN(0xff, 298),
+	MX31_PIN_CKIL		= IOMUX_PIN(0xff, 299),
+	MX31_PIN_BOOT_MODE4	= IOMUX_PIN(0xff, 300),
+	MX31_PIN_BOOT_MODE3	= IOMUX_PIN(0xff, 301),
+	MX31_PIN_BOOT_MODE2	= IOMUX_PIN(0xff, 302),
+	MX31_PIN_BOOT_MODE1	= IOMUX_PIN(0xff, 303),
+	MX31_PIN_BOOT_MODE0	= IOMUX_PIN(0xff, 304),
+	MX31_PIN_CLKO		= IOMUX_PIN(0xff, 305),
+	MX31_PIN_POR_B		= IOMUX_PIN(0xff, 306),
+	MX31_PIN_RESET_IN_B	= IOMUX_PIN(0xff, 307),
+	MX31_PIN_CKIH		= IOMUX_PIN(0xff, 308),
+	MX31_PIN_SIMPD0		= IOMUX_PIN(35,   309),
+	MX31_PIN_SRX0		= IOMUX_PIN(34,   310),
+	MX31_PIN_STX0		= IOMUX_PIN(33,   311),
+	MX31_PIN_SVEN0		= IOMUX_PIN(32,   312),
+	MX31_PIN_SRST0		= IOMUX_PIN(67,   313),
+	MX31_PIN_SCLK0		= IOMUX_PIN(66,   314),
+	MX31_PIN_GPIO3_1	= IOMUX_PIN(65,   315),
+	MX31_PIN_GPIO3_0	= IOMUX_PIN(64,   316),
+	MX31_PIN_GPIO1_6	= IOMUX_PIN( 6,   317),
+	MX31_PIN_GPIO1_5	= IOMUX_PIN( 5,   318),
+	MX31_PIN_GPIO1_4	= IOMUX_PIN( 4,   319),
+	MX31_PIN_GPIO1_3	= IOMUX_PIN( 3,   320),
+	MX31_PIN_GPIO1_2	= IOMUX_PIN( 2,   321),
+	MX31_PIN_GPIO1_1	= IOMUX_PIN( 1,   322),
+	MX31_PIN_GPIO1_0	= IOMUX_PIN( 0,   323),
+	MX31_PIN_PWMO		= IOMUX_PIN( 9,   324),
+	MX31_PIN_WATCHDOG_RST	= IOMUX_PIN(0xff, 325),
+	MX31_PIN_COMPARE	= IOMUX_PIN( 8,   326),
+	MX31_PIN_CAPTURE	= IOMUX_PIN( 7,   327),
+};
+
+/*
+ * Convenience values for use with mxc_iomux_mode()
+ *
+ * Format here is MX31_PIN_(pin name)__(function)
+ */
+#define MX31_PIN_CSPI3_MOSI__RXD3	IOMUX_MODE(MX31_PIN_CSPI3_MOSI, IOMUX_CONFIG_ALT1)
+#define MX31_PIN_CSPI3_MISO__TXD3	IOMUX_MODE(MX31_PIN_CSPI3_MISO, IOMUX_CONFIG_ALT1)
+#define MX31_PIN_CTS1__CTS1		IOMUX_MODE(MX31_PIN_CTS1, IOMUX_CONFIG_FUNC)
+#define MX31_PIN_RTS1__RTS1		IOMUX_MODE(MX31_PIN_RTS1, IOMUX_CONFIG_FUNC)
+#define MX31_PIN_TXD1__TXD1		IOMUX_MODE(MX31_PIN_TXD1, IOMUX_CONFIG_FUNC)
+#define MX31_PIN_RXD1__RXD1		IOMUX_MODE(MX31_PIN_RXD1, IOMUX_CONFIG_FUNC)
+
+/*
+ * This function configures the pad value for a IOMUX pin.
+ */
+void mxc_iomux_set_pad(enum iomux_pins, u32);
+
+#endif
+
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/irqs.h ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/irqs.h
--- adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/irqs.h	2008-07-29 23:55:59.000000000 +0200
+++ ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/irqs.h	2008-10-19 15:15:34.000000000 +0200
@@ -13,17 +13,14 @@
 
 #include <asm/hardware.h>
 
-#define MXC_IRQ_TO_EXPIO(irq)	((irq) - MXC_EXP_IO_BASE)
-
-#define MXC_IRQ_TO_GPIO(irq)	((irq) - MXC_GPIO_INT_BASE)
-#define MXC_GPIO_TO_IRQ(x)	(MXC_GPIO_INT_BASE + x)
-
-/* Number of normal interrupts */
-#define NR_IRQS		(MXC_MAX_INT_LINES + \
-			MXC_MAX_GPIO_LINES + \
-			MXC_MAX_VIRTUAL_INTS)
-
-/* Number of fast interrupts */
-#define NR_FIQS		MXC_MAX_INTS
+#ifdef CONFIG_IPIPE
+#ifdef CONFIG_ARCH_MX3
+#define __ipipe_mach_irq_mux_p(irq)				\
+	((irq) == MXC_INT_GPIO1					\
+	 || (irq) == MXC_INT_GPIO2 || (irq) == MXC_INT_GPIO3)
+#elif CONFIG_ARCH_MX2
+#define __ipipe_mach_irq_mux_p(irq) ((irq) == MXC_INT_GPIO)
+#endif /* CONFIG_ARCH_MX2 */
+#endif /* CONFIG_IPIPE */
 
 #endif /* __ASM_ARCH_MXC_IRQS_H__ */
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/mx27.h ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/mx27.h
--- adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/mx27.h	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/mx27.h	2008-10-19 15:15:34.000000000 +0200
@@ -0,0 +1,302 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+
+#ifndef __ASM_ARCH_MXC_MX27_H__
+#define __ASM_ARCH_MXC_MX27_H__
+
+#ifndef __ASM_ARCH_MXC_HARDWARE_H__
+#error "Do not include directly."
+#endif
+
+/* IRAM */
+#define IRAM_BASE_ADDR          0xFFFF4C00	/* internal ram */
+
+/* Register offests */
+#define AIPI_BASE_ADDR          0x10000000
+#define AIPI_BASE_ADDR_VIRT     0xF4000000
+#define AIPI_SIZE               SZ_1M
+
+#define DMA_BASE_ADDR           (AIPI_BASE_ADDR + 0x01000)
+#define WDOG_BASE_ADDR          (AIPI_BASE_ADDR + 0x02000)
+#define GPT1_BASE_ADDR          (AIPI_BASE_ADDR + 0x03000)
+#define GPT2_BASE_ADDR          (AIPI_BASE_ADDR + 0x04000)
+#define GPT3_BASE_ADDR          (AIPI_BASE_ADDR + 0x05000)
+#define PWM_BASE_ADDR           (AIPI_BASE_ADDR + 0x06000)
+#define RTC_BASE_ADDR           (AIPI_BASE_ADDR + 0x07000)
+#define KPP_BASE_ADDR           (AIPI_BASE_ADDR + 0x08000)
+#define OWIRE_BASE_ADDR         (AIPI_BASE_ADDR + 0x09000)
+#define UART1_BASE_ADDR         (AIPI_BASE_ADDR + 0x0A000)
+#define UART2_BASE_ADDR         (AIPI_BASE_ADDR + 0x0B000)
+#define UART3_BASE_ADDR         (AIPI_BASE_ADDR + 0x0C000)
+#define UART4_BASE_ADDR         (AIPI_BASE_ADDR + 0x0D000)
+#define CSPI1_BASE_ADDR         (AIPI_BASE_ADDR + 0x0E000)
+#define CSPI2_BASE_ADDR         (AIPI_BASE_ADDR + 0x0F000)
+#define SSI1_BASE_ADDR          (AIPI_BASE_ADDR + 0x10000)
+#define SSI2_BASE_ADDR          (AIPI_BASE_ADDR + 0x11000)
+#define I2C_BASE_ADDR           (AIPI_BASE_ADDR + 0x12000)
+#define SDHC1_BASE_ADDR         (AIPI_BASE_ADDR + 0x13000)
+#define SDHC2_BASE_ADDR         (AIPI_BASE_ADDR + 0x14000)
+#define GPIO_BASE_ADDR          (AIPI_BASE_ADDR + 0x15000)
+#define AUDMUX_BASE_ADDR        (AIPI_BASE_ADDR + 0x16000)
+
+#define CSPI3_BASE_ADDR         (AIPI_BASE_ADDR + 0x17000)
+#define MSHC_BASE_ADDR          (AIPI_BASE_ADDR + 0x18000)
+#define GPT5_BASE_ADDR          (AIPI_BASE_ADDR + 0x19000)
+#define GPT4_BASE_ADDR          (AIPI_BASE_ADDR + 0x1A000)
+#define UART5_BASE_ADDR         (AIPI_BASE_ADDR + 0x1B000)
+#define UART6_BASE_ADDR         (AIPI_BASE_ADDR + 0x1C000)
+#define I2C2_BASE_ADDR          (AIPI_BASE_ADDR + 0x1D000)
+#define SDHC3_BASE_ADDR         (AIPI_BASE_ADDR + 0x1E000)
+#define GPT6_BASE_ADDR          (AIPI_BASE_ADDR + 0x1F000)
+
+#define LCDC_BASE_ADDR          (AIPI_BASE_ADDR + 0x21000)
+#define SLCDC_BASE_ADDR         (AIPI_BASE_ADDR + 0x22000)
+#define VPU_BASE_ADDR           (AIPI_BASE_ADDR + 0x23000)
+#define USBOTG_BASE_ADDR        (AIPI_BASE_ADDR + 0x24000)
+/* for mx27*/
+#define OTG_BASE_ADDR           USBOTG_BASE_ADDR
+#define SAHARA_BASE_ADDR        (AIPI_BASE_ADDR + 0x25000)
+#define EMMA_BASE_ADDR          (AIPI_BASE_ADDR + 0x26400)
+#define CCM_BASE_ADDR           (AIPI_BASE_ADDR + 0x27000)
+#define SYSCTRL_BASE_ADDR       (AIPI_BASE_ADDR + 0x27800)
+#define IIM_BASE_ADDR           (AIPI_BASE_ADDR + 0x28000)
+
+#define RTIC_BASE_ADDR          (AIPI_BASE_ADDR + 0x2A000)
+#define FEC_BASE_ADDR           (AIPI_BASE_ADDR + 0x2B000)
+#define SCC_BASE_ADDR           (AIPI_BASE_ADDR + 0x2C000)
+#define ETB_BASE_ADDR           (AIPI_BASE_ADDR + 0x3B000)
+#define ETB_RAM_BASE_ADDR       (AIPI_BASE_ADDR + 0x3C000)
+
+#define JAM_BASE_ADDR           (AIPI_BASE_ADDR + 0x3E000)
+#define MAX_BASE_ADDR           (AIPI_BASE_ADDR + 0x3F000)
+
+/* ROMP and AVIC */
+#define ROMP_BASE_ADDR          0x10041000
+
+#define AVIC_BASE_ADDR          0x10040000
+
+#define SAHB1_BASE_ADDR         0x80000000
+#define SAHB1_BASE_ADDR_VIRT    0xF4100000
+#define SAHB1_SIZE              SZ_1M
+
+#define CSI_BASE_ADDR           (SAHB1_BASE_ADDR + 0x0000)
+#define ATA_BASE_ADDR           (SAHB1_BASE_ADDR + 0x1000)
+
+/* NAND, SDRAM, WEIM, M3IF, EMI controllers */
+#define X_MEMC_BASE_ADDR        0xD8000000
+#define X_MEMC_BASE_ADDR_VIRT   0xF4200000
+#define X_MEMC_SIZE             SZ_1M
+
+#define NFC_BASE_ADDR           (X_MEMC_BASE_ADDR)
+#define SDRAMC_BASE_ADDR        (X_MEMC_BASE_ADDR + 0x1000)
+#define WEIM_BASE_ADDR          (X_MEMC_BASE_ADDR + 0x2000)
+#define M3IF_BASE_ADDR          (X_MEMC_BASE_ADDR + 0x3000)
+#define PCMCIA_CTL_BASE_ADDR    (X_MEMC_BASE_ADDR + 0x4000)
+
+/* Memory regions and CS */
+#define SDRAM_BASE_ADDR		0xA0000000
+#define CSD1_BASE_ADDR		0xB0000000
+
+#define CS0_BASE_ADDR           0xC0000000
+#define CS1_BASE_ADDR           0xC8000000
+#define CS2_BASE_ADDR           0xD0000000
+#define CS3_BASE_ADDR           0xD2000000
+#define CS4_BASE_ADDR           0xD4000000
+#define CS5_BASE_ADDR           0xD6000000
+#define PCMCIA_MEM_BASE_ADDR    0xDC000000
+
+/*
+ * This macro defines the physical to virtual address mapping for all the
+ * peripheral modules. It is used by passing in the physical address as x
+ * and returning the virtual address. If the physical address is not mapped,
+ * it returns 0xDEADBEEF
+ */
+#define IO_ADDRESS(x)   \
+	(((x >= AIPI_BASE_ADDR) && (x < (AIPI_BASE_ADDR + AIPI_SIZE))) ? \
+		AIPI_IO_ADDRESS(x) : \
+	((x >= SAHB1_BASE_ADDR) && (x < (SAHB1_BASE_ADDR + SAHB1_SIZE))) ? \
+		SAHB1_IO_ADDRESS(x) : \
+	((x >= X_MEMC_BASE_ADDR) && (x < (X_MEMC_BASE_ADDR + X_MEMC_SIZE))) ? \
+		X_MEMC_IO_ADDRESS(x) : 0xDEADBEEF)
+
+/* define the address mapping macros: in physical address order */
+#define AIPI_IO_ADDRESS(x)  \
+	(((x) - AIPI_BASE_ADDR) + AIPI_BASE_ADDR_VIRT)
+
+#define AVIC_IO_ADDRESS(x)	AIPI_IO_ADDRESS(x)
+
+#define SAHB1_IO_ADDRESS(x)  \
+	(((x) - SAHB1_BASE_ADDR) + SAHB1_BASE_ADDR_VIRT)
+
+#define CS4_IO_ADDRESS(x)  \
+	(((x) - CS4_BASE_ADDR) + CS4_BASE_ADDR_VIRT)
+
+#define X_MEMC_IO_ADDRESS(x)  \
+	(((x) - X_MEMC_BASE_ADDR) + X_MEMC_BASE_ADDR_VIRT)
+
+#define PCMCIA_IO_ADDRESS(x) \
+	(((x) - X_MEMC_BASE_ADDR) + X_MEMC_BASE_ADDR_VIRT)
+
+/* fixed interrput numbers */
+#define MXC_INT_CCM		63
+#define MXC_INT_IIM		62
+#define MXC_INT_LCDC		61
+#define MXC_INT_SLCDC		60
+#define MXC_INT_SAHARA		59
+#define MXC_INT_SCC_SCM		58
+#define MXC_INT_SCC_SMN		57
+#define MXC_INT_USB3		56
+#define MXC_INT_USB2		55
+#define MXC_INT_USB1		54
+#define MXC_INT_VPU		53
+#define MXC_INT_EMMAPP		52
+#define MXC_INT_EMMAPRP		51
+#define MXC_INT_FEC		50
+#define MXC_INT_UART5		49
+#define MXC_INT_UART6		48
+#define MXC_INT_DMACH15		47
+#define MXC_INT_DMACH14		46
+#define MXC_INT_DMACH13		45
+#define MXC_INT_DMACH12		44
+#define MXC_INT_DMACH11		43
+#define MXC_INT_DMACH10		42
+#define MXC_INT_DMACH9		41
+#define MXC_INT_DMACH8		40
+#define MXC_INT_DMACH7		39
+#define MXC_INT_DMACH6		38
+#define MXC_INT_DMACH5		37
+#define MXC_INT_DMACH4		36
+#define MXC_INT_DMACH3		35
+#define MXC_INT_DMACH2		34
+#define MXC_INT_DMACH1		33
+#define MXC_INT_DMACH0		32
+#define MXC_INT_CSI		31
+#define MXC_INT_ATA		30
+#define MXC_INT_NANDFC		29
+#define MXC_INT_PCMCIA		28
+#define MXC_INT_WDOG		27
+#define MXC_INT_GPT1		26
+#define MXC_INT_GPT2		25
+#define MXC_INT_GPT3		24
+#define MXC_INT_GPT		INT_GPT1
+#define MXC_INT_PWM		23
+#define MXC_INT_RTC		22
+#define MXC_INT_KPP		21
+#define MXC_INT_UART1		20
+#define MXC_INT_UART2		19
+#define MXC_INT_UART3		18
+#define MXC_INT_UART4		17
+#define MXC_INT_CSPI1		16
+#define MXC_INT_CSPI2		15
+#define MXC_INT_SSI1		14
+#define MXC_INT_SSI2		13
+#define MXC_INT_I2C		12
+#define MXC_INT_SDHC1		11
+#define MXC_INT_SDHC2		10
+#define MXC_INT_SDHC3		9
+#define MXC_INT_GPIO		8
+#define MXC_INT_SDHC		7
+#define MXC_INT_CSPI3		6
+#define MXC_INT_RTIC		5
+#define MXC_INT_GPT4		4
+#define MXC_INT_GPT5		3
+#define MXC_INT_GPT6		2
+#define MXC_INT_I2C2		1
+
+/* fixed DMA request numbers */
+#define DMA_REQ_NFC             37
+#define DMA_REQ_SDHC3           36
+#define DMA_REQ_UART6_RX        35
+#define DMA_REQ_UART6_TX        34
+#define DMA_REQ_UART5_RX        33
+#define DMA_REQ_UART5_TX        32
+#define DMA_REQ_CSI_RX          31
+#define DMA_REQ_CSI_STAT        30
+#define DMA_REQ_ATA_RCV         29
+#define DMA_REQ_ATA_TX          28
+#define DMA_REQ_UART1_TX        27
+#define DMA_REQ_UART1_RX        26
+#define DMA_REQ_UART2_TX        25
+#define DMA_REQ_UART2_RX        24
+#define DMA_REQ_UART3_TX        23
+#define DMA_REQ_UART3_RX        22
+#define DMA_REQ_UART4_TX        21
+#define DMA_REQ_UART4_RX        20
+#define DMA_REQ_CSPI1_TX        19
+#define DMA_REQ_CSPI1_RX        18
+#define DMA_REQ_CSPI2_TX        17
+#define DMA_REQ_CSPI2_RX        16
+#define DMA_REQ_SSI1_TX1        15
+#define DMA_REQ_SSI1_RX1        14
+#define DMA_REQ_SSI1_TX0        13
+#define DMA_REQ_SSI1_RX0        12
+#define DMA_REQ_SSI2_TX1        11
+#define DMA_REQ_SSI2_RX1        10
+#define DMA_REQ_SSI2_TX0        9
+#define DMA_REQ_SSI2_RX0        8
+#define DMA_REQ_SDHC1           7
+#define DMA_REQ_SDHC2           6
+#define DMA_REQ_MSHC            4
+#define DMA_REQ_EXT             3
+#define DMA_REQ_CSPI3_TX        2
+#define DMA_REQ_CSPI3_RX        1
+
+/* silicon revisions specific to i.MX27 */
+#define CHIP_REV_1_0		0x00
+#define CHIP_REV_2_0		0x01
+
+#ifndef __ASSEMBLY__
+extern int mx27_revision(void);
+#endif
+
+/* gpio and gpio based interrupt handling */
+#define GPIO_DR		 	0x1C
+#define GPIO_GDIR	 	0x00
+#define GPIO_PSR	 	0x24
+#define GPIO_ICR1	 	0x28
+#define GPIO_ICR2	 	0x2C
+#define GPIO_IMR	 	0x30
+#define GPIO_ISR	 	0x34
+#define GPIO_INT_LOW_LEV	0x3
+#define GPIO_INT_HIGH_LEV	0x2
+#define GPIO_INT_RISE_EDGE 	0x0
+#define GPIO_INT_FALL_EDGE	0x1
+#define GPIO_INT_NONE		0x4
+
+/* Mandatory defines used globally */
+
+/* this is an i.MX27 CPU */
+#define cpu_is_mx27()		(1)
+
+/* this CPU supports up to 192 GPIOs (don't forget the baseboard!) */
+#define ARCH_NR_GPIOS		(192 + 16)
+
+/* OS clock tick rate */
+#define CLOCK_TICK_RATE         13300000
+
+/* Start of RAM */
+#define PHYS_OFFSET		SDRAM_BASE_ADDR
+
+/* max interrupt lines count */
+#define NR_IRQS			256
+
+/* count of internal interrupt sources */
+#define MXC_MAX_INT_LINES	64
+
+#endif /* __ASM_ARCH_MXC_MX27_H__ */
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/mx31.h ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/mx31.h
--- adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/mx31.h	2008-07-29 23:55:59.000000000 +0200
+++ ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/mx31.h	2008-10-19 15:15:34.000000000 +0200
@@ -320,6 +320,8 @@
 #define MXC_MAX_GPIO_LINES      (GPIO_NUM_PIN * GPIO_PORT_NUM)
 #define MXC_MAX_VIRTUAL_INTS	16
 
+#define NR_IRQS (MXC_MAX_INT_LINES + MXC_MAX_GPIO_LINES + MXC_MAX_VIRTUAL_INTS)
+
 /*!
  * Number of GPIO port as defined in the IC Spec
  */
@@ -347,6 +349,25 @@
 #define SYSTEM_REV_MIN		CHIP_REV_1_0
 #define SYSTEM_REV_NUM		3
 
+/* gpio and gpio based interrupt handling */
+#define GPIO_DR		 	0x00
+#define GPIO_GDIR	 	0x04
+#define GPIO_PSR	 	0x08
+#define GPIO_ICR1	 	0x0C
+#define GPIO_ICR2	 	0x10
+#define GPIO_IMR	 	0x14
+#define GPIO_ISR	 	0x18
+#define GPIO_INT_LOW_LEV	0x0
+#define GPIO_INT_HIGH_LEV	0x1
+#define GPIO_INT_RISE_EDGE	0x2
+#define GPIO_INT_FALL_EDGE	0x3
+#define GPIO_INT_NONE		0x4
+
+/* Mandatory defines used globally */
+
+/* this CPU supports up to 96 GPIOs */
+#define ARCH_NR_GPIOS		96
+
 #if !defined(__ASSEMBLY__) && !defined(__MXC_BOOT_UNCOMPRESS)
 
 /* this is a i.MX31 CPU */
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/mxc.h ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/mxc.h
--- adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/mxc.h	2008-07-29 23:55:59.000000000 +0200
+++ ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/mxc.h	2008-10-19 15:15:34.000000000 +0200
@@ -1,11 +1,20 @@
 /*
  * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
+ * Copyright (C) 2008 Juergen Beisert (kernel@pengutronix.de)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
  */
 
 #ifndef __ASM_ARCH_MXC_H__
@@ -20,133 +29,8 @@
 # define cpu_is_mx31() (0)
 #endif
 
-/*
- *****************************************
- * GPT  Register definitions             *
- *****************************************
- */
-#define MXC_GPT_GPTCR		IO_ADDRESS(GPT1_BASE_ADDR + 0x00)
-#define MXC_GPT_GPTPR		IO_ADDRESS(GPT1_BASE_ADDR + 0x04)
-#define MXC_GPT_GPTSR		IO_ADDRESS(GPT1_BASE_ADDR + 0x08)
-#define MXC_GPT_GPTIR		IO_ADDRESS(GPT1_BASE_ADDR + 0x0C)
-#define MXC_GPT_GPTOCR1		IO_ADDRESS(GPT1_BASE_ADDR + 0x10)
-#define MXC_GPT_GPTOCR2		IO_ADDRESS(GPT1_BASE_ADDR + 0x14)
-#define MXC_GPT_GPTOCR3		IO_ADDRESS(GPT1_BASE_ADDR + 0x18)
-#define MXC_GPT_GPTICR1		IO_ADDRESS(GPT1_BASE_ADDR + 0x1C)
-#define MXC_GPT_GPTICR2		IO_ADDRESS(GPT1_BASE_ADDR + 0x20)
-#define MXC_GPT_GPTCNT		IO_ADDRESS(GPT1_BASE_ADDR + 0x24)
-
-/* GPT Control register bit definitions */
-#define GPTCR_FO3			(1 << 31)
-#define GPTCR_FO2			(1 << 30)
-#define GPTCR_FO1			(1 << 29)
-
-#define GPTCR_OM3_SHIFT			26
-#define GPTCR_OM3_MASK			(7 << GPTCR_OM3_SHIFT)
-#define GPTCR_OM3_DISCONNECTED		(0 << GPTCR_OM3_SHIFT)
-#define GPTCR_OM3_TOGGLE		(1 << GPTCR_OM3_SHIFT)
-#define GPTCR_OM3_CLEAR			(2 << GPTCR_OM3_SHIFT)
-#define GPTCR_OM3_SET			(3 << GPTCR_OM3_SHIFT)
-#define GPTCR_OM3_GENERATE_LOW		(7 << GPTCR_OM3_SHIFT)
-
-#define GPTCR_OM2_SHIFT			23
-#define GPTCR_OM2_MASK			(7 << GPTCR_OM2_SHIFT)
-#define GPTCR_OM2_DISCONNECTED		(0 << GPTCR_OM2_SHIFT)
-#define GPTCR_OM2_TOGGLE		(1 << GPTCR_OM2_SHIFT)
-#define GPTCR_OM2_CLEAR			(2 << GPTCR_OM2_SHIFT)
-#define GPTCR_OM2_SET			(3 << GPTCR_OM2_SHIFT)
-#define GPTCR_OM2_GENERATE_LOW		(7 << GPTCR_OM2_SHIFT)
-
-#define GPTCR_OM1_SHIFT			20
-#define GPTCR_OM1_MASK			(7 << GPTCR_OM1_SHIFT)
-#define GPTCR_OM1_DISCONNECTED		(0 << GPTCR_OM1_SHIFT)
-#define GPTCR_OM1_TOGGLE		(1 << GPTCR_OM1_SHIFT)
-#define GPTCR_OM1_CLEAR			(2 << GPTCR_OM1_SHIFT)
-#define GPTCR_OM1_SET			(3 << GPTCR_OM1_SHIFT)
-#define GPTCR_OM1_GENERATE_LOW		(7 << GPTCR_OM1_SHIFT)
-
-#define GPTCR_IM2_SHIFT			18
-#define GPTCR_IM2_MASK			(3 << GPTCR_IM2_SHIFT)
-#define GPTCR_IM2_CAPTURE_DISABLE	(0 << GPTCR_IM2_SHIFT)
-#define GPTCR_IM2_CAPTURE_RISING	(1 << GPTCR_IM2_SHIFT)
-#define GPTCR_IM2_CAPTURE_FALLING	(2 << GPTCR_IM2_SHIFT)
-#define GPTCR_IM2_CAPTURE_BOTH		(3 << GPTCR_IM2_SHIFT)
-
-#define GPTCR_IM1_SHIFT			16
-#define GPTCR_IM1_MASK			(3 << GPTCR_IM1_SHIFT)
-#define GPTCR_IM1_CAPTURE_DISABLE	(0 << GPTCR_IM1_SHIFT)
-#define GPTCR_IM1_CAPTURE_RISING	(1 << GPTCR_IM1_SHIFT)
-#define GPTCR_IM1_CAPTURE_FALLING	(2 << GPTCR_IM1_SHIFT)
-#define GPTCR_IM1_CAPTURE_BOTH		(3 << GPTCR_IM1_SHIFT)
-
-#define GPTCR_SWR			(1 << 15)
-#define GPTCR_FRR			(1 << 9)
-
-#define GPTCR_CLKSRC_SHIFT		6
-#define GPTCR_CLKSRC_MASK		(7 << GPTCR_CLKSRC_SHIFT)
-#define GPTCR_CLKSRC_NOCLOCK		(0 << GPTCR_CLKSRC_SHIFT)
-#define GPTCR_CLKSRC_HIGHFREQ		(2 << GPTCR_CLKSRC_SHIFT)
-#define GPTCR_CLKSRC_CLKIN		(3 << GPTCR_CLKSRC_SHIFT)
-#define GPTCR_CLKSRC_CLK32K		(7 << GPTCR_CLKSRC_SHIFT)
-
-#define GPTCR_STOPEN			(1 << 5)
-#define GPTCR_DOZEN			(1 << 4)
-#define GPTCR_WAITEN			(1 << 3)
-#define GPTCR_DBGEN			(1 << 2)
-
-#define GPTCR_ENMOD			(1 << 1)
-#define GPTCR_ENABLE			(1 << 0)
-
-#define GPTSR_OF1			(1 << 0)
-#define GPTSR_OF2			(1 << 1)
-#define GPTSR_OF3			(1 << 2)
-#define GPTSR_IF1			(1 << 3)
-#define GPTSR_IF2			(1 << 4)
-#define GPTSR_ROV			(1 << 5)
-
-#define GPTIR_OF1IE			GPTSR_OF1
-#define GPTIR_OF2IE			GPTSR_OF2
-#define GPTIR_OF3IE			GPTSR_OF3
-#define GPTIR_IF1IE			GPTSR_IF1
-#define GPTIR_IF2IE			GPTSR_IF2
-#define GPTIR_ROVIE			GPTSR_ROV
-
-/*
- *****************************************
- * AVIC Registers                        *
- *****************************************
- */
-#define AVIC_BASE		IO_ADDRESS(AVIC_BASE_ADDR)
-#define AVIC_INTCNTL		(AVIC_BASE + 0x00)	/* int control reg */
-#define AVIC_NIMASK		(AVIC_BASE + 0x04)	/* int mask reg */
-#define AVIC_INTENNUM		(AVIC_BASE + 0x08)	/* int enable number reg */
-#define AVIC_INTDISNUM		(AVIC_BASE + 0x0C)	/* int disable number reg */
-#define AVIC_INTENABLEH		(AVIC_BASE + 0x10)	/* int enable reg high */
-#define AVIC_INTENABLEL		(AVIC_BASE + 0x14)	/* int enable reg low */
-#define AVIC_INTTYPEH		(AVIC_BASE + 0x18)	/* int type reg high */
-#define AVIC_INTTYPEL		(AVIC_BASE + 0x1C)	/* int type reg low */
-#define AVIC_NIPRIORITY7	(AVIC_BASE + 0x20)	/* norm int priority lvl7 */
-#define AVIC_NIPRIORITY6	(AVIC_BASE + 0x24)	/* norm int priority lvl6 */
-#define AVIC_NIPRIORITY5	(AVIC_BASE + 0x28)	/* norm int priority lvl5 */
-#define AVIC_NIPRIORITY4	(AVIC_BASE + 0x2C)	/* norm int priority lvl4 */
-#define AVIC_NIPRIORITY3	(AVIC_BASE + 0x30)	/* norm int priority lvl3 */
-#define AVIC_NIPRIORITY2	(AVIC_BASE + 0x34)	/* norm int priority lvl2 */
-#define AVIC_NIPRIORITY1	(AVIC_BASE + 0x38)	/* norm int priority lvl1 */
-#define AVIC_NIPRIORITY0	(AVIC_BASE + 0x3C)	/* norm int priority lvl0 */
-#define AVIC_NIVECSR		(AVIC_BASE + 0x40)	/* norm int vector/status */
-#define AVIC_FIVECSR		(AVIC_BASE + 0x44)	/* fast int vector/status */
-#define AVIC_INTSRCH		(AVIC_BASE + 0x48)	/* int source reg high */
-#define AVIC_INTSRCL		(AVIC_BASE + 0x4C)	/* int source reg low */
-#define AVIC_INTFRCH		(AVIC_BASE + 0x50)	/* int force reg high */
-#define AVIC_INTFRCL		(AVIC_BASE + 0x54)	/* int force reg low */
-#define AVIC_NIPNDH		(AVIC_BASE + 0x58)	/* norm int pending high */
-#define AVIC_NIPNDL		(AVIC_BASE + 0x5C)	/* norm int pending low */
-#define AVIC_FIPNDH		(AVIC_BASE + 0x60)	/* fast int pending high */
-#define AVIC_FIPNDL		(AVIC_BASE + 0x64)	/* fast int pending low */
-
-#define SYSTEM_PREV_REG		IO_ADDRESS(IIM_BASE_ADDR + 0x20)
-#define SYSTEM_SREV_REG		IO_ADDRESS(IIM_BASE_ADDR + 0x24)
-#define IIM_PROD_REV_SH		3
-#define IIM_PROD_REV_LEN	5
+#ifndef CONFIG_MACH_MX27
+# define cpu_is_mx27() (0)
+#endif
 
 #endif /*  __ASM_ARCH_MXC_H__ */
diff -Naurdp adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/mxc_timer.h ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/mxc_timer.h
--- adeos-ipipe-2.6.26-arm-1.11-02/include/asm-arm/arch-mxc/mxc_timer.h	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.26-mxc/include/asm-arm/arch-mxc/mxc_timer.h	2008-10-19 15:15:34.000000000 +0200
@@ -0,0 +1,158 @@
+/*
+ * mxc_timer.h
+ *
+ * Copyright (C) 2008 Juergen Beisert (kernel@pengutronix.de)
+ *
+ * Platform independent (i.MX1, i.MX2, i.MX3) definition for timer handling.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301, USA.
+ */
+
+#ifndef __PLAT_MXC_TIMER_H
+#define __PLAT_MXC_TIMER_H
+
+#include <linux/clk.h>
+#include <asm/hardware.h>
+
+#ifdef CONFIG_ARCH_IMX
+#define TIMER_BASE		IO_ADDRESS(TIM1_BASE_ADDR)
+#define TIMER_INTERRUPT		TIM1_INT
+
+#define TCTL_VAL		TCTL_CLK_PCLK1
+#define TCTL_IRQEN		(1<<4)
+#define TCTL_FRR		(1<<8)
+#define TCTL_CLK_PCLK1		(1<<1)
+#define TCTL_CLK_PCLK1_4	(2<<1)
+#define TCTL_CLK_TIN		(3<<1)
+#define TCTL_CLK_32		(4<<1)
+
+#define MXC_TCTL   0x00
+#define MXC_TPRER  0x04
+#define MXC_TCMP   0x08
+#define MXC_TCR    0x0c
+#define MXC_TCN    0x10
+#define MXC_TSTAT  0x14
+#define TSTAT_CAPT		(1<<1)
+#define TSTAT_COMP		(1<<0)
+
+static inline void gpt_irq_disable(void)
+{
+	unsigned int tmp;
+
+	tmp = __raw_readl(TIMER_BASE + MXC_TCTL);
+	__raw_writel(tmp & ~TCTL_IRQEN, TIMER_BASE + MXC_TCTL);
+}
+
+static inline void gpt_irq_enable(void)
+{
+	__raw_writel(__raw_readl(TIMER_BASE + MXC_TCTL) | TCTL_IRQEN,
+				TIMER_BASE + MXC_TCTL);
+}
+
+static void gpt_irq_acknowledge(void)
+{
+	__raw_writel(0, TIMER_BASE + MXC_TSTAT);
+}
+#endif /* CONFIG_ARCH_IMX */
+
+#ifdef CONFIG_ARCH_MX2
+#define TIMER_BASE		IO_ADDRESS(GPT1_BASE_ADDR)
+#define TIMER_INTERRUPT		MXC_INT_GPT1
+
+#define MXC_TCTL   0x00
+#define TCTL_VAL		TCTL_CLK_PCLK1
+#define TCTL_CLK_PCLK1		(1<<1)
+#define TCTL_CLK_PCLK1_4	(2<<1)
+#define TCTL_IRQEN		(1<<4)
+#define TCTL_FRR		(1<<8)
+#define MXC_TPRER  0x04
+#define MXC_TCMP   0x08
+#define MXC_TCR    0x0c
+#define MXC_TCN    0x10
+#define MXC_TSTAT  0x14
+#define TSTAT_CAPT		(1<<1)
+#define TSTAT_COMP		(1<<0)
+
+static inline void gpt_irq_disable(void)
+{
+	unsigned int tmp;
+
+	tmp = __raw_readl(TIMER_BASE + MXC_TCTL);
+	__raw_writel(tmp & ~TCTL_IRQEN, TIMER_BASE + MXC_TCTL);
+}
+
+static inline void gpt_irq_enable(void)
+{
+	__raw_writel(__raw_readl(TIMER_BASE + MXC_TCTL) | TCTL_IRQEN,
+				TIMER_BASE + MXC_TCTL);
+}
+
+static void gpt_irq_acknowledge(void)
+{
+	__raw_writel(TSTAT_CAPT | TSTAT_COMP, TIMER_BASE + MXC_TSTAT);
+}
+#endif /* CONFIG_ARCH_MX2 */
+
+#ifdef CONFIG_ARCH_MX3
+#define TIMER_BASE		IO_ADDRESS(GPT1_BASE_ADDR)
+#define TIMER_INTERRUPT		MXC_INT_GPT
+
+#define MXC_TCTL   0x00
+#define TCTL_VAL		(TCTL_CLK_IPG | TCTL_WAITEN)
+#define TCTL_CLK_IPG		(1<<6)
+#define TCTL_FRR		(1<<9)
+#define TCTL_WAITEN		(1<<3)
+
+#define MXC_TPRER  0x04
+#define MXC_TSTAT  0x08
+#define TSTAT_OF1		(1<<0)
+#define TSTAT_OF2		(1<<1)
+#define TSTAT_OF3		(1<<2)
+#define TSTAT_IF1		(1<<3)
+#define TSTAT_IF2		(1<<4)
+#define TSTAT_ROV		(1<<5)
+#define MXC_IR     0x0c
+#define MXC_TCMP   0x10
+#define MXC_TCMP2  0x14
+#define MXC_TCMP3  0x18
+#define MXC_TCR    0x1c
+#define MXC_TCN    0x24
+
+static inline void gpt_irq_disable(void)
+{
+	__raw_writel(0, TIMER_BASE + MXC_IR);
+}
+
+static inline void gpt_irq_enable(void)
+{
+	__raw_writel(1<<0, TIMER_BASE + MXC_IR);
+}
+
+static inline void gpt_irq_acknowledge(void)
+{
+	__raw_writel(TSTAT_OF1, TIMER_BASE + MXC_TSTAT);
+}
+#endif /* CONFIG_ARCH_MX3 */
+
+#define TCTL_SWR		(1<<15)
+#define TCTL_CC			(1<<10)
+#define TCTL_OM			(1<<9)
+#define TCTL_CAP_RIS		(1<<6)
+#define TCTL_CAP_FAL		(2<<6)
+#define TCTL_CAP_RIS_FAL	(3<<6)
+#define TCTL_CAP_ENA		(1<<5)
+#define TCTL_TEN		(1<<0)
+
+#endif
