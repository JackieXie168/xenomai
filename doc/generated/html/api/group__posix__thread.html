<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Xenomai API: Threads management services.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1>Threads management services.<br>
<small>
[<a class="el" href="group__posix.html">POSIX skin.</a>]</small>
</h1>
<p>
Collaboration diagram for Threads management services.:<center><table><tr><td><img src="group__posix__thread.png" border="0" alt="" usemap="#group____posix____thread_map">
<map name="group____posix____thread_map">
<area href="group__posix__cancel.html" shape="rect" coords="468,6,628,32" alt="">
<area href="group__posix__sched.html" shape="rect" coords="439,56,657,83" alt="">
<area href="group__posix__threadattr.html" shape="rect" coords="447,107,649,134" alt="">
<area href="group__posix.html" shape="rect" coords="7,56,103,83" alt="">
</map></td></tr></table></center>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Threads management services. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/xsh_chap02_09.html#tag_02_09">Specification.</a> </dd></dl>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Modules</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__cancel.html">Thread cancellation.</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread cancellation. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__sched.html">Threads scheduling services.</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread scheduling services. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__threadattr.html">Thread creation attributes.</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread creation attributes. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#g6f67bab054483fb8be299141207f7b41">pthread_once</a> (pthread_once_t *once, void(*init_routine)(void))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute an initialization routine.  <a href="#g6f67bab054483fb8be299141207f7b41"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#g98af0fc36d3e6cac93f592e9e2a5bceb">pthread_create</a> (pthread_t *tid, const pthread_attr_t *attr, void *(*start)(void *), void *arg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a thread.  <a href="#g98af0fc36d3e6cac93f592e9e2a5bceb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#g9dbb9c5d01da062ed4de04e19eac8970">pthread_detach</a> (pthread_t thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detach a running thread.  <a href="#g9dbb9c5d01da062ed4de04e19eac8970"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#g08717c7c7cadcdd7cb3b24f316d250ed">pthread_equal</a> (pthread_t t1, pthread_t t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare thread identifiers.  <a href="#g08717c7c7cadcdd7cb3b24f316d250ed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#gca6f62575fc4db4a4453d21f96884ba0">pthread_exit</a> (void *value_ptr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Terminate the current thread.  <a href="#gca6f62575fc4db4a4453d21f96884ba0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#g8f93713ee34c7218bbd02ea22c1d571b">pthread_join</a> (pthread_t thread, void **value_ptr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for termination of a specified thread.  <a href="#g8f93713ee34c7218bbd02ea22c1d571b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">pthread_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#g943283199f45af0f5c6fe830a95430aa">pthread_self</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the identifier of the calling thread.  <a href="#g943283199f45af0f5c6fe830a95430aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#g996ea8d597a670dd6b8aa44fcf44a9d8">pthread_make_periodic_np</a> (pthread_t thread, struct timespec *starttp, struct timespec *periodtp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a thread periodic.  <a href="#g996ea8d597a670dd6b8aa44fcf44a9d8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#g29fbe1db02c6e76eac63831a9c2e0002">pthread_wait_np</a> (unsigned long *overruns_r)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for current thread next period.  <a href="#g29fbe1db02c6e76eac63831a9c2e0002"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#g46d3302ab8bd026a940848b64ee11c8f">pthread_set_mode_np</a> (int clrmask, int setmask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the mode of the current thread.  <a href="#g46d3302ab8bd026a940848b64ee11c8f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#gfd86bf6e774594f4d87e02f7183006ff">pthread_set_name_np</a> (pthread_t thread, const char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a thread name.  <a href="#gfd86bf6e774594f4d87e02f7183006ff"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g98af0fc36d3e6cac93f592e9e2a5bceb"></a><!-- doxytag: member="thread.c::pthread_create" ref="g98af0fc36d3e6cac93f592e9e2a5bceb" args="(pthread_t *tid, const pthread_attr_t *attr, void *(*start)(void *), void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_create           </td>
          <td>(</td>
          <td class="paramtype">pthread_t *&nbsp;</td>
          <td class="paramname"> <em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pthread_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *)&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a thread. 
<p>
This service create a thread. The created thread may be used with all POSIX skin services.<p>
The new thread run the <em>start</em> routine, with the <em>arg</em> argument.<p>
The new thread signal mask is inherited from the current thread, if it was also created with <a class="el" href="group__posix__thread.html#g98af0fc36d3e6cac93f592e9e2a5bceb">pthread_create()</a>, otherwise the new thread signal mask is empty.<p>
Other attributes of the new thread depend on the <em>attr</em> argument. If <em>attr</em> is null, default values for these attributes are used. See <a class="el" href="group__posix__threadattr.html">Thread creation attributes.</a> for a definition of thread creation attributes and their default values.<p>
Returning from the <em>start</em> routine has the same effect as calling <a class="el" href="group__posix__thread.html#gca6f62575fc4db4a4453d21f96884ba0">pthread_exit()</a> with the return value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tid</em>&nbsp;</td><td>address where the identifier of the new thread will be stored on success;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>thread attributes;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>thread routine;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>thread routine argument.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success; <p>
an error number if:<ul>
<li>EINVAL, <em>attr</em> is invalid;</li><li>EAGAIN, insufficient memory exists in the system heap to create a new thread, increase CONFIG_XENO_OPT_SYS_HEAPSZ;</li><li>EINVAL, thread attribute <em>inheritsched</em> is set to PTHREAD_INHERIT_SCHED and the calling thread does not belong to the POSIX skin;</li></ul>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_create.html">Specification.</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g9dbb9c5d01da062ed4de04e19eac8970"></a><!-- doxytag: member="thread.c::pthread_detach" ref="g9dbb9c5d01da062ed4de04e19eac8970" args="(pthread_t thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_detach           </td>
          <td>(</td>
          <td class="paramtype">pthread_t&nbsp;</td>
          <td class="paramname"> <em>thread</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Detach a running thread. 
<p>
This service detaches a joinable thread. A detached thread is a thread which control block is automatically reclaimed when it terminates. The control block of a joinable thread, on the other hand, is only reclaimed when joined with the service <a class="el" href="group__posix__thread.html#g8f93713ee34c7218bbd02ea22c1d571b">pthread_join()</a>.<p>
If some threads are currently blocked in the <a class="el" href="group__posix__thread.html#g8f93713ee34c7218bbd02ea22c1d571b">pthread_join()</a> service with <em>thread</em> as a target, they are unblocked and <a class="el" href="group__posix__thread.html#g8f93713ee34c7218bbd02ea22c1d571b">pthread_join()</a> returns EINVAL.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>target thread.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success; <p>
an error number if:<ul>
<li>ESRCH, <em>thread</em> is an invalid thread identifier;</li><li>EINVAL, <em>thread</em> is not joinable.</li></ul>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_detach.html">Specification.</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g08717c7c7cadcdd7cb3b24f316d250ed"></a><!-- doxytag: member="thread.c::pthread_equal" ref="g08717c7c7cadcdd7cb3b24f316d250ed" args="(pthread_t t1, pthread_t t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_equal           </td>
          <td>(</td>
          <td class="paramtype">pthread_t&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pthread_t&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compare thread identifiers. 
<p>
This service compare the thread identifiers <em>t1</em> and <em>t2</em>. No attempt is made to check the threads for existence. In order to check if a thread exists, the <a class="el" href="group__posix__signal.html#gb3b9c3388a9c4255f4644741f0e3aeb9">pthread_kill()</a> service should be used with the signal number 0.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>thread identifier;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t2</em>&nbsp;</td><td>other thread identifier.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a non zero value if the thread identifiers are equal; <p>
0 otherwise.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_equal.html">Specification.</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gca6f62575fc4db4a4453d21f96884ba0"></a><!-- doxytag: member="thread.c::pthread_exit" ref="gca6f62575fc4db4a4453d21f96884ba0" args="(void *value_ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pthread_exit           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>value_ptr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Terminate the current thread. 
<p>
This service terminate the current thread with the return value <em>value_ptr</em>. If the current thread is joinable, the return value is returned to any thread joining the current thread with the <a class="el" href="group__posix__thread.html#g8f93713ee34c7218bbd02ea22c1d571b">pthread_join()</a> service.<p>
When a thread terminates, cancellation cleanup handlers are executed in the reverse order that they were pushed. Then, thread-specific data destructors are executed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>value_ptr</em>&nbsp;</td><td>thread return value.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_exit.html">Specification.</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g8f93713ee34c7218bbd02ea22c1d571b"></a><!-- doxytag: member="thread.c::pthread_join" ref="g8f93713ee34c7218bbd02ea22c1d571b" args="(pthread_t thread, void **value_ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_join           </td>
          <td>(</td>
          <td class="paramtype">pthread_t&nbsp;</td>
          <td class="paramname"> <em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>value_ptr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait for termination of a specified thread. 
<p>
If the thread <em>thread</em> is running and joinable, this service blocks the calling thread until the thread <em>thread</em> terminates or detaches. In this case, the calling context must be a blockable context (i.e. a Xenomai thread without the scheduler locked) or the root thread (i.e. a module initilization or cleanup routine). When <em>thread</em> terminates, the calling thread is unblocked and its return value is stored at* the address <em>value_ptr</em>.<p>
If, on the other hand, the thread <em>thread</em> has already finished execution, its return value is stored at the address <em>value_ptr</em> and this service returns immediately. In this case, this service may be called from any context.<p>
This service is a cancelation point for POSIX skin threads: if the calling thread is canceled while blocked in a call to this service, the cancelation request is honored and <em>thread</em> remains joinable.<p>
Multiple simultaneous calls to <a class="el" href="group__posix__thread.html#g8f93713ee34c7218bbd02ea22c1d571b">pthread_join()</a> specifying the same running target thread block all the callers until the target thread terminates.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>identifier of the thread to wait for;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value_ptr</em>&nbsp;</td><td>address where the target thread return value will be stored on success.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success; <p>
an error number if:<ul>
<li>ESRCH, <em>thread</em> is invalid;</li><li>EDEADLK, attempting to join the calling thread;</li><li>EINVAL, <em>thread</em> is detached;</li><li>EPERM, the caller context is invalid.</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Valid contexts, if this service has to block its caller:</b></dt><dd><ul>
<li>Xenomai kernel-space thread;</li><li>kernel module initilization or cleanup routine;</li><li>Xenomai user-space thread (switches to primary mode).</li></ul>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_join.html">Specification.</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g996ea8d597a670dd6b8aa44fcf44a9d8"></a><!-- doxytag: member="thread.c::pthread_make_periodic_np" ref="g996ea8d597a670dd6b8aa44fcf44a9d8" args="(pthread_t thread, struct timespec *starttp, struct timespec *periodtp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_make_periodic_np           </td>
          <td>(</td>
          <td class="paramtype">pthread_t&nbsp;</td>
          <td class="paramname"> <em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *&nbsp;</td>
          <td class="paramname"> <em>starttp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *&nbsp;</td>
          <td class="paramname"> <em>periodtp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make a thread periodic. 
<p>
This service make the POSIX skin thread <em>thread</em> periodic.<p>
This service is a non-portable extension of the POSIX interface.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>thread identifier. This thread is immediately delayed until the first periodic release point is reached.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>starttp</em>&nbsp;</td><td>start time, expressed as an absolute value of the CLOCK_REALTIME clock. The affected thread will be delayed until this point is reached.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>periodtp</em>&nbsp;</td><td>period, expressed as a time interval.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success; <p>
an error number if:<ul>
<li>ESRCH, <em>thread</em> is invalid;</li><li>ETIMEDOUT, the start time has already passed.</li></ul>
</dd></dl>
Rescheduling: always, until the  start time has been reached. 
</div>
</div><p>
<a class="anchor" name="g6f67bab054483fb8be299141207f7b41"></a><!-- doxytag: member="once.c::pthread_once" ref="g6f67bab054483fb8be299141207f7b41" args="(pthread_once_t *once, void(*init_routine)(void))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_once           </td>
          <td>(</td>
          <td class="paramtype">pthread_once_t *&nbsp;</td>
          <td class="paramname"> <em>once</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void)&nbsp;</td>
          <td class="paramname"> <em>init_routine</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Execute an initialization routine. 
<p>
This service may be used by libraries which need an initialization function to be called only once.<p>
The function <em>init_routine</em> will only be called, with no argument, the first time this service is called specifying the address <em>once</em>.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success; <p>
an error number if:<ul>
<li>EINVAL, the object pointed to by <em>once</em> is invalid (it must have been initialized with PTHREAD_ONCE_INIT).</li></ul>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_once.html">Specification.</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g943283199f45af0f5c6fe830a95430aa"></a><!-- doxytag: member="thread.c::pthread_self" ref="g943283199f45af0f5c6fe830a95430aa" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pthread_t pthread_self           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the identifier of the calling thread. 
<p>
This service returns the identifier of the calling thread.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>identifier of the calling thread; <p>
NULL if the calling thread is not a POSIX skin thread.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_self.html">Specification.</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g46d3302ab8bd026a940848b64ee11c8f"></a><!-- doxytag: member="thread.c::pthread_set_mode_np" ref="g46d3302ab8bd026a940848b64ee11c8f" args="(int clrmask, int setmask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_set_mode_np           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>clrmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>setmask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the mode of the current thread. 
<p>
This service sets the mode of the calling thread. <em>clrmask</em> and <em>setmask</em> are two bit masks which are respectively cleared and set in the calling thread status. They are a bitwise OR of the following values:<ul>
<li>PTHREAD_LOCK_SCHED, when set, locks the scheduler, which prevents the current thread from being switched out by the scheduler until the scheduler is unlocked;</li><li>PTHREAD_SHIELD, when set, activates the interrupt shield, which improve the execution determinism of the current thread by blocking Linux interrupts when it runs in secondary mode;</li><li>PTHREAD_RPIOFF, when set, prevents the root Linux thread from inheriting the priority of the calling thread, when this thread is running in secondary mode;</li><li>PTHREAD_WARNSW, when set, cause the signal SIGXCPU to be sent to the current thread, whenever it involontary switches to secondary mode;</li><li>PTHREAD_PRIMARY, cause the migration of the current thread to primary mode.</li></ul>
<p>
PTHREAD_LOCK_SCHED is valid for any Xenomai thread, the other bits are only valid for Xenomai user-space threads.<p>
This service is a non-portable extension of the POSIX interface.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clrmask</em>&nbsp;</td><td>set of bits to be cleared;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>setmask</em>&nbsp;</td><td>set of bits to be set.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success; <p>
an error number if:<ul>
<li>EINVAL, some bit in <em>clrmask</em> or <em>setmask</em> is invalid. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="gfd86bf6e774594f4d87e02f7183006ff"></a><!-- doxytag: member="thread.c::pthread_set_name_np" ref="gfd86bf6e774594f4d87e02f7183006ff" args="(pthread_t thread, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_set_name_np           </td>
          <td>(</td>
          <td class="paramtype">pthread_t&nbsp;</td>
          <td class="paramname"> <em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set a thread name. 
<p>
This service set to <em>name</em>, the name of <em>thread</em>. This name is used for displaying information in /proc/xenomai/sched.<p>
This service is a non-portable extension of the POSIX interface.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>target thread;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of the thread.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success; <p>
an error number if:<ul>
<li>ESRCH, <em>thread</em> is invalid. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="g29fbe1db02c6e76eac63831a9c2e0002"></a><!-- doxytag: member="thread.c::pthread_wait_np" ref="g29fbe1db02c6e76eac63831a9c2e0002" args="(unsigned long *overruns_r)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_wait_np           </td>
          <td>(</td>
          <td class="paramtype">unsigned long *&nbsp;</td>
          <td class="paramname"> <em>overruns_r</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait for current thread next period. 
<p>
If it is periodic, this service blocks the calling thread until the next period elapses.<p>
This service is a cancelation point for POSIX skin threads.<p>
This service is a non-portable extension of the POSIX interface.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>overruns_r</em>&nbsp;</td><td>address where the overruns count is returned in case of overrun.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success; <p>
an error number if:<ul>
<li>EPERM, the calling context is invalid;</li><li>EWOULDBLOCK, the calling thread is not periodic;</li><li>EINTR, this service was interrupted by a signal;</li><li>ETIMEDOUT, at least one overrun occurred.</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Valid contexts:</b></dt><dd><ul>
<li>Xenomai kernel-space thread;</li><li>Xenomai user-space thread (switches to primary mode). </li></ul>
</dd></dl>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Sun Sep 16 18:34:41 2007 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
