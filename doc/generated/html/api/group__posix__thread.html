<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Xenomai API: Threads management services.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>Threads management services.<br>
<small>
[<a class="el" href="group__posix.html">POSIX skin.</a>]</small>
</h1>
<p>
Collaboration diagram for Threads management services.:<center><table><tr><td><img src="group__posix__thread.png" border="0" alt="" usemap="#group____posix____thread_map">
<map name="group____posix____thread_map">
<area href="group__posix__cancel.html" shape="rect" coords="437,8,578,32" alt="">
<area href="group__posix__sched.html" shape="rect" coords="410,56,605,80" alt="">
<area href="group__posix__threadattr.html" shape="rect" coords="418,104,597,128" alt="">
<area href="group__posix.html" shape="rect" coords="9,56,102,80" alt="">
</map></td></tr></table></center>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Threads management services. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/xsh_chap02_09.html#tag_02_09">Specification.</a> </dd></dl>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Modules</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__cancel.html">Thread cancellation.</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread cancellation. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__sched.html">Threads scheduling services.</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread scheduling services. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__threadattr.html">Thread creation attributes.</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread creation attributes. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#ga2">pthread_once</a> (pthread_once_t *once, void(*init_routine)(void))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute an initialization routine.  <a href="#ga2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#ga6">pthread_create</a> (pthread_t *tid, const pthread_attr_t *attr, void *(*start)(void *), void *arg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a thread.  <a href="#ga6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#ga7">pthread_detach</a> (pthread_t thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detach a running thread.  <a href="#ga7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#ga8">pthread_equal</a> (pthread_t t1, pthread_t t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare thread identifiers.  <a href="#ga8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#ga9">pthread_exit</a> (void *value_ptr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Terminate the current thread.  <a href="#ga9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#ga10">pthread_join</a> (pthread_t thread, void **value_ptr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for termination of a specified thread.  <a href="#ga10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">pthread_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#ga11">pthread_self</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the identifier of the calling thread.  <a href="#ga11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#ga12">pthread_make_periodic_np</a> (pthread_t thread, struct timespec *starttp, struct timespec *periodtp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a thread periodic.  <a href="#ga12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#ga13">pthread_wait_np</a> (unsigned long *overruns_r)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for current thread next period.  <a href="#ga13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#ga14">pthread_set_mode_np</a> (int clrmask, int setmask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the mode of the current thread.  <a href="#ga14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#ga15">pthread_set_name_np</a> (pthread_t thread, const char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a thread name.  <a href="#ga15"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga6" doxytag="thread.c::pthread_create"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int pthread_create           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pthread_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>tid</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const pthread_attr_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *(*)(void *)&nbsp;</td>
          <td class="mdname" nowrap> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>arg</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a thread. 
<p>
This service create a thread. The created thread may be used with all POSIX skin services.<p>
The new thread run the <em>start</em> routine, with the <em>arg</em> argument.<p>
The new thread signal mask is inherited from the current thread, if it was also created with <a class="el" href="group__posix__thread.html#ga6">pthread_create()</a>, otherwise the new thread signal mask is empty.<p>
Other attributes of the new thread depend on the <em>attr</em> argument. If <em>attr</em> is null, default values for these attributes are used. See <a class="el" href="group__posix__threadattr.html">Thread creation attributes.</a> for a definition of thread creation attributes and their default values.<p>
Returning from the <em>start</em> routine has the same effect as calling <a class="el" href="group__posix__thread.html#ga9">pthread_exit()</a> with the return value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tid</em>&nbsp;</td><td>address where the identifier of the new thread will be stored on success;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>thread attributes;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>thread routine;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>thread routine argument.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success; <p>
an error number if:<ul>
<li>EINVAL, <em>attr</em> is invalid;</li><li>EAGAIN, insufficient memory exists in the system heap to create a new thread, increase CONFIG_XENO_OPT_SYS_HEAPSZ;</li><li>EINVAL, thread attribute <em>inheritsched</em> is set to PTHREAD_INHERIT_SCHED and the calling thread does not belong to the POSIX skin;</li></ul>
</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_create.html">Specification.</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga7" doxytag="thread.c::pthread_detach"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int pthread_detach           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pthread_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>thread</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Detach a running thread. 
<p>
This service detaches a joinable thread. A detached thread is a thread which control block is automatically reclaimed when it terminates. The control block of a joinable thread, on the other hand, is only reclaimed when joined with the service <a class="el" href="group__posix__thread.html#ga10">pthread_join()</a>.<p>
If some threads are currently blocked in the <a class="el" href="group__posix__thread.html#ga10">pthread_join()</a> service with <em>thread</em> as a target, they are unblocked and <a class="el" href="group__posix__thread.html#ga10">pthread_join()</a> returns EINVAL.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>target thread.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success; <p>
an error number if:<ul>
<li>ESRCH, <em>thread</em> is an invalid thread identifier;</li><li>EINVAL, <em>thread</em> is not joinable.</li></ul>
</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_detach.html">Specification.</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga8" doxytag="thread.c::pthread_equal"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int pthread_equal           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pthread_t&nbsp;</td>
          <td class="mdname" nowrap> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>pthread_t&nbsp;</td>
          <td class="mdname" nowrap> <em>t2</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compare thread identifiers. 
<p>
This service compare the thread identifiers <em>t1</em> and <em>t2</em>. No attempt is made to check the threads for existence. In order to check if a thread exists, the <a class="el" href="group__posix__signal.html#ga25">pthread_kill()</a> service should be used with the signal number 0.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>thread identifier;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t2</em>&nbsp;</td><td>other thread identifier.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>a non zero value if the thread identifiers are equal; <p>
0 otherwise.</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_equal.html">Specification.</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga9" doxytag="thread.c::pthread_exit"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void pthread_exit           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>value_ptr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Terminate the current thread. 
<p>
This service terminate the current thread with the return value <em>value_ptr</em>. If the current thread is joinable, the return value is returned to any thread joining the current thread with the <a class="el" href="group__posix__thread.html#ga10">pthread_join()</a> service.<p>
When a thread terminates, cancellation cleanup handlers are executed in the reverse order that they were pushed. Then, thread-specific data destructors are executed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>value_ptr</em>&nbsp;</td><td>thread return value.</td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_exit.html">Specification.</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga10" doxytag="thread.c::pthread_join"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int pthread_join           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pthread_t&nbsp;</td>
          <td class="mdname" nowrap> <em>thread</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void **&nbsp;</td>
          <td class="mdname" nowrap> <em>value_ptr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait for termination of a specified thread. 
<p>
If the thread <em>thread</em> is running and joinable, this service blocks the calling thread until the thread <em>thread</em> terminates or detaches. In this case, the calling context must be blockable, i.e. a Xenomai thread. When <em>thread</em> terminates, its return value is stored at the address <em>value_ptr</em>.<p>
If, on the other hand, the thread <em>thread</em> has already finished execution, its return value is stored at the address <em>value_ptr</em> and this service returns immediately. In this case, this service may be called from any context, and in particular from modules cleanup routines.<p>
This service is a cancelation point for POSIX skin threads: if the calling thread is canceled while blocked in a call to this service, the cancelation request is honored and <em>thread</em> remains joinable.<p>
Multiple simultaneous calls to <a class="el" href="group__posix__thread.html#ga10">pthread_join()</a> specifying the same running target thread block all the callers until the target thread terminates.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>identifier of the thread to wait for;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value_ptr</em>&nbsp;</td><td>address where the target thread return value will be stored on success.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success; <p>
an error number if:<ul>
<li>ESRCH, <em>thread</em> is invalid;</li><li>EDEADLK, attempting to join the calling thread;</li><li>EINVAL, <em>thread</em> is detached;</li><li>EPERM, the caller context is invalid.</li></ul>
</dd></dl>
<dl compact><dt><b>Valid contexts, if this service has to block its caller:</b></dt><dd><ul>
<li>Xenomai kernel-space thread;</li><li>Xenomai user-space thread (switches to primary mode).</li></ul>
</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_join.html">Specification.</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga12" doxytag="thread.c::pthread_make_periodic_np"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int pthread_make_periodic_np           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pthread_t&nbsp;</td>
          <td class="mdname" nowrap> <em>thread</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct timespec *&nbsp;</td>
          <td class="mdname" nowrap> <em>starttp</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct timespec *&nbsp;</td>
          <td class="mdname" nowrap> <em>periodtp</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Make a thread periodic. 
<p>
This service make the POSIX skin thread <em>thread</em> periodic.<p>
This service is a non-portable extension of the POSIX interface.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>thread identifier;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>starttp</em>&nbsp;</td><td>start time, expressed as an absolute value of the CLOCK_REALTIME clock;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>periodtp</em>&nbsp;</td><td>period, expressed as a time interval.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success; <p>
an error number if:<ul>
<li>ESRCH, <em>thread</em> is invalid;</li><li>ETIMEDOUT, the start time has already passed. </li></ul>
</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga2" doxytag="once.c::pthread_once"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int pthread_once           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pthread_once_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>once</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void(*)(void)&nbsp;</td>
          <td class="mdname" nowrap> <em>init_routine</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Execute an initialization routine. 
<p>
This service may be used by libraries which need an initialization function to be called only once.<p>
The function <em>init_routine</em> will only be called, with no argument, the first time this service is called specifying the address <em>once</em>.<p>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success; <p>
an error number if:<ul>
<li>EINVAL, the object pointed to by <em>once</em> is invalid (it must have been initialized with PTHREAD_ONCE_INIT).</li></ul>
</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_once.html">Specification.</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga11" doxytag="thread.c::pthread_self"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">pthread_t pthread_self           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the identifier of the calling thread. 
<p>
This service returns the identifier of the calling thread.<p>
<dl compact><dt><b>Returns:</b></dt><dd>identifier of the calling thread; <p>
NULL if the calling thread is not a POSIX skin thread.</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_self.html">Specification.</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga14" doxytag="thread.c::pthread_set_mode_np"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int pthread_set_mode_np           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>clrmask</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>setmask</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the mode of the current thread. 
<p>
This service sets the mode of the calling thread. <em>clrmask</em> and <em>setmask</em> are two bit masks which are respectively cleared and set in the calling thread status. They are a bitwise OR of the following values:<ul>
<li>PTHREAD_LOCK_SCHED, when set, locks the scheduler, which prevents the current thread from being switched out by the scheduler until the scheduler is unlocked;</li><li>PTHREAD_SHIELD, when set, activates the interrupt shield, which improve the execution determinism of the current thread by blocking Linux interrupts when it runs in secondary mode;</li><li>PTHREAD_RPIOFF, when set, prevents the root Linux thread from inheriting the priority of the calling thread, when this thread is running in secondary mode;</li><li>PTHREAD_WARNSW, when set, cause the signal SIGXCPU to be sent to the current thread, whenever it involontary switches to secondary mode;</li><li>PTHREAD_PRIMARY, cause the migration of the current thread to primary mode.</li></ul>
<p>
PTHREAD_LOCK_SCHED is valid for any Xenomai thread, the other bits are only valid for Xenomai user-space threads.<p>
This service is a non-portable extension of the POSIX interface.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clrmask</em>&nbsp;</td><td>set of bits to be cleared;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>setmask</em>&nbsp;</td><td>set of bits to be set.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success; <p>
an error number if:<ul>
<li>EINVAL, some bit in <em>clrmask</em> or <em>setmask</em> is invalid. </li></ul>
</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga15" doxytag="thread.c::pthread_set_name_np"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int pthread_set_name_np           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pthread_t&nbsp;</td>
          <td class="mdname" nowrap> <em>thread</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set a thread name. 
<p>
This service set to <em>name</em>, the name of <em>thread</em>. This name is used for displaying information in /proc/xenomai/sched.<p>
This service is a non-portable extension of the POSIX interface.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>target thread;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of the thread.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success; <p>
an error number if:<ul>
<li>ESRCH, <em>thread</em> is invalid. </li></ul>
</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga13" doxytag="thread.c::pthread_wait_np"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int pthread_wait_np           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned long *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>overruns_r</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait for current thread next period. 
<p>
If it is periodic, this service blocks the calling thread until the next period elapses.<p>
This service is a cancelation point for POSIX skin threads.<p>
This service is a non-portable extension of the POSIX interface.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>overruns_r</em>&nbsp;</td><td>address where the overruns count is returned in case of overrun.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success; <p>
an error number if:<ul>
<li>EPERM, the calling context is invalid;</li><li>EWOULDBLOCK, the calling thread is not periodic;</li><li>EINTR, this service was interrupted by a signal;</li><li>ETIMEDOUT, at least one overrun occurred.</li></ul>
</dd></dl>
<dl compact><dt><b>Valid contexts:</b></dt><dd><ul>
<li>Xenomai kernel-space thread;</li><li>Xenomai user-space thread (switches to primary mode). </li></ul>
</dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Wed Aug 16 16:26:55 2006 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
