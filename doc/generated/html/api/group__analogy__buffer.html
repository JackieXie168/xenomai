<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Xenomai API: Buffer management services</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Xenomai API"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Xenomai API
   &#160;<span id="projectnumber">2.6.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__analogy__buffer.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Buffer management services</div>  </div>
<div class="ingroups"><a class="el" href="group__driverfacilities.html">Driver API.</a></div></div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Buffer management services:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__analogy__buffer.png" border="0" alt="" usemap="#group____analogy____buffer"/>
<map name="group____analogy____buffer" id="group____analogy____buffer">
<area shape="rect" id="node1" href="group__driverfacilities.html" title="Driver API." alt="" coords="7,5,92,35"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8ffbc9832255a701624fe874d319e5f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogy__buffer.html#ga8ffbc9832255a701624fe874d319e5f4">a4l_buf_prepare_absput</a> (<a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *subd, unsigned long count)</td></tr>
<tr class="memdesc:ga8ffbc9832255a701624fe874d319e5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the absolute count of data sent from the device to the buffer since the start of the acquisition and after the next DMA shot.  <a href="#ga8ffbc9832255a701624fe874d319e5f4"></a><br/></td></tr>
<tr class="memitem:ga8d053d9fc6e19eb47f9c08abf485cea9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogy__buffer.html#ga8d053d9fc6e19eb47f9c08abf485cea9">a4l_buf_commit_absput</a> (<a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *subd, unsigned long count)</td></tr>
<tr class="memdesc:ga8d053d9fc6e19eb47f9c08abf485cea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the absolute count of data which was sent from the device to the buffer since the start of the acquisition and until the last DMA shot.  <a href="#ga8d053d9fc6e19eb47f9c08abf485cea9"></a><br/></td></tr>
<tr class="memitem:ga582e96ac8358717a19995e0c8c41dffc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogy__buffer.html#ga582e96ac8358717a19995e0c8c41dffc">a4l_buf_prepare_put</a> (<a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *subd, unsigned long count)</td></tr>
<tr class="memdesc:ga582e96ac8358717a19995e0c8c41dffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the count of data which is to be sent to the buffer at the next DMA shot.  <a href="#ga582e96ac8358717a19995e0c8c41dffc"></a><br/></td></tr>
<tr class="memitem:gab03dcc685bcb3ad9111c9aa3dbe3baf5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogy__buffer.html#gab03dcc685bcb3ad9111c9aa3dbe3baf5">a4l_buf_commit_put</a> (<a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *subd, unsigned long count)</td></tr>
<tr class="memdesc:gab03dcc685bcb3ad9111c9aa3dbe3baf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the count of data sent to the buffer during the last completed DMA shots.  <a href="#gab03dcc685bcb3ad9111c9aa3dbe3baf5"></a><br/></td></tr>
<tr class="memitem:gaec920d203e34f2020eb51ddad3461d1c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogy__buffer.html#gaec920d203e34f2020eb51ddad3461d1c">a4l_buf_put</a> (<a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *subd, void *bufdata, unsigned long count)</td></tr>
<tr class="memdesc:gaec920d203e34f2020eb51ddad3461d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy some data from the device driver to the buffer.  <a href="#gaec920d203e34f2020eb51ddad3461d1c"></a><br/></td></tr>
<tr class="memitem:ga7fecd99d23d53c69381aacee4d9222d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogy__buffer.html#ga7fecd99d23d53c69381aacee4d9222d8">a4l_buf_prepare_absget</a> (<a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *subd, unsigned long count)</td></tr>
<tr class="memdesc:ga7fecd99d23d53c69381aacee4d9222d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the absolute count of data sent from the buffer to the device since the start of the acquisition and after the next DMA shot.  <a href="#ga7fecd99d23d53c69381aacee4d9222d8"></a><br/></td></tr>
<tr class="memitem:gadadad4789e1da9236fed49a33b1b2284"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogy__buffer.html#gadadad4789e1da9236fed49a33b1b2284">a4l_buf_commit_absget</a> (<a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *subd, unsigned long count)</td></tr>
<tr class="memdesc:gadadad4789e1da9236fed49a33b1b2284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the absolute count of data which was sent from the buffer to the device since the start of the acquisition and until the last DMA shot.  <a href="#gadadad4789e1da9236fed49a33b1b2284"></a><br/></td></tr>
<tr class="memitem:gaf9fe0b2fe2279e4f753ddec776d10c5f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogy__buffer.html#gaf9fe0b2fe2279e4f753ddec776d10c5f">a4l_buf_prepare_get</a> (<a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *subd, unsigned long count)</td></tr>
<tr class="memdesc:gaf9fe0b2fe2279e4f753ddec776d10c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the count of data which is to be sent from the buffer to the device at the next DMA shot.  <a href="#gaf9fe0b2fe2279e4f753ddec776d10c5f"></a><br/></td></tr>
<tr class="memitem:gabd70bc9f8bb4615f60c0107d51ca1f29"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogy__buffer.html#gabd70bc9f8bb4615f60c0107d51ca1f29">a4l_buf_commit_get</a> (<a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *subd, unsigned long count)</td></tr>
<tr class="memdesc:gabd70bc9f8bb4615f60c0107d51ca1f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the count of data sent from the buffer to the device during the last completed DMA shots.  <a href="#gabd70bc9f8bb4615f60c0107d51ca1f29"></a><br/></td></tr>
<tr class="memitem:ga6af2dcaaecfd2cd9f0deb6e9167d3cff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogy__buffer.html#ga6af2dcaaecfd2cd9f0deb6e9167d3cff">a4l_buf_get</a> (<a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *subd, void *bufdata, unsigned long count)</td></tr>
<tr class="memdesc:ga6af2dcaaecfd2cd9f0deb6e9167d3cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy some data from the buffer to the device driver.  <a href="#ga6af2dcaaecfd2cd9f0deb6e9167d3cff"></a><br/></td></tr>
<tr class="memitem:gac275c834264a50b9443304d33908f657"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogy__buffer.html#gac275c834264a50b9443304d33908f657">a4l_buf_evt</a> (<a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *subd, unsigned long evts)</td></tr>
<tr class="memdesc:gac275c834264a50b9443304d33908f657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal some event(s) to a user-space program involved in some read / write operation.  <a href="#gac275c834264a50b9443304d33908f657"></a><br/></td></tr>
<tr class="memitem:gad9e80150586b4a869562d3d098f49d36"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogy__buffer.html#gad9e80150586b4a869562d3d098f49d36">a4l_buf_count</a> (<a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *subd)</td></tr>
<tr class="memdesc:gad9e80150586b4a869562d3d098f49d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data amount available in the Analogy buffer.  <a href="#gad9e80150586b4a869562d3d098f49d36"></a><br/></td></tr>
<tr class="memitem:ga2386d5a9d84393b5db9beb22ae7674e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structa4l__cmd__desc.html">a4l_cmd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogy__buffer.html#ga2386d5a9d84393b5db9beb22ae7674e9">a4l_get_cmd</a> (<a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *subd)</td></tr>
<tr class="memdesc:ga2386d5a9d84393b5db9beb22ae7674e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current Analogy command descriptor.  <a href="#ga2386d5a9d84393b5db9beb22ae7674e9"></a><br/></td></tr>
<tr class="memitem:ga6e33ba6f8a06e3dbbfe3896b0258857f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogy__buffer.html#ga6e33ba6f8a06e3dbbfe3896b0258857f">a4l_get_chan</a> (<a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *subd)</td></tr>
<tr class="memdesc:ga6e33ba6f8a06e3dbbfe3896b0258857f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the channel index according to its type.  <a href="#ga6e33ba6f8a06e3dbbfe3896b0258857f"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<p>Buffer management services</p>
<p>The buffer is the key component of the Analogy infrastructure. It manages transfers between the user-space and the Analogy drivers thanks to generic functions which are described hereafter. Thanks to the buffer subsystem, the driver developer does not have to care about the way the user program retrieves or sends data.</p>
<p>To write a classical char driver, the developer has to fill a fops structure so as to provide transfer operations to the user program (read, write, ioctl and mmap if need be).</p>
<p>The Analogy infrastructure manages the whole interface with the userspace; the common read, write, mmap, etc. callbacks are generic Analogy functions. These functions manage (and perform, if need be) tranfers between the user-space and an asynchronous buffer thanks to lockless mechanisms.</p>
<p>Consequently, the developer has to use the proper buffer functions in order to write / read acquired data into / from the asynchronous buffer.</p>
<p>Here are listed the functions:</p>
<ul>
<li>a4l_buf_prepare_(abs)put() and a4l_buf_commit_(abs)put()</li>
<li>a4l_buf_prepare_(abs)get() and a4l_buf_commit_(abs)get()</li>
<li><a class="el" href="group__analogy__buffer.html#gaec920d203e34f2020eb51ddad3461d1c" title="Copy some data from the device driver to the buffer.">a4l_buf_put()</a></li>
<li><a class="el" href="group__analogy__buffer.html#ga6af2dcaaecfd2cd9f0deb6e9167d3cff" title="Copy some data from the buffer to the device driver.">a4l_buf_get()</a></li>
<li><a class="el" href="group__analogy__buffer.html#gac275c834264a50b9443304d33908f657" title="Signal some event(s) to a user-space program involved in some read / write operation.">a4l_buf_evt()</a>.</li>
</ul>
<p>The functions count might seem high; however, the developer needs a few of them to write a driver. Having so many functions enables to manage any transfer cases:</p>
<ul>
<li>If some DMA controller is available, there is no need to make the driver copy the acquired data into the asynchronous buffer, the DMA controller must directly trigger DMA shots into / from the buffer. In that case, a function a4l_buf_prepare_*() must be used so as to set up the DMA transfer and a function a4l_buf_commit_*() has to be called to complete the transfer().</li>
<li>For DMA controllers which need to work with global counter (the transfered data count since the beginning of the acquisition), the functions a4l_buf_*_abs_*() have been made available.</li>
<li>If no DMA controller is available, the driver has to perform the copy between the hardware component and the asynchronous buffer. In such cases, the functions <a class="el" href="group__analogy__buffer.html#ga6af2dcaaecfd2cd9f0deb6e9167d3cff" title="Copy some data from the buffer to the device driver.">a4l_buf_get()</a> and <a class="el" href="group__analogy__buffer.html#gaec920d203e34f2020eb51ddad3461d1c" title="Copy some data from the device driver to the buffer.">a4l_buf_put()</a> are useful. </li>
</ul>
<h2>Function Documentation</h2>
<a class="anchor" id="gadadad4789e1da9236fed49a33b1b2284"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int a4l_buf_commit_absget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *&#160;</td>
          <td class="paramname"><em>subd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the absolute count of data which was sent from the buffer to the device since the start of the acquisition and until the last DMA shot. </p>
<p>The functions a4l_buf_prepare_(abs)put(), a4l_buf_commit_(abs)put(), a4l_buf_prepare_(abs)get() and a4l_buf_commit_(abs)get() have been made available for DMA transfers. In such situations, no data copy is needed between the Analogy buffer and the device as some DMA controller is in charge of performing data shots from / to the Analogy buffer. However, some pointers still have to be updated so as to monitor the tranfers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subd</td><td>Subdevice descriptor structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The data count transferred to the device during the last DMA shot plus the data count which have been sent since the beginning of the acquisition</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise negative error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8d053d9fc6e19eb47f9c08abf485cea9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int a4l_buf_commit_absput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *&#160;</td>
          <td class="paramname"><em>subd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the absolute count of data which was sent from the device to the buffer since the start of the acquisition and until the last DMA shot. </p>
<p>The functions a4l_buf_prepare_(abs)put(), a4l_buf_commit_(abs)put(), a4l_buf_prepare_(abs)get() and a4l_buf_commit_(abs)get() have been made available for DMA transfers. In such situations, no data copy is needed between the Analogy buffer and the device as some DMA controller is in charge of performing data shots from / to the Analogy buffer. However, some pointers still have to be updated so as to monitor the tranfers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subd</td><td>Subdevice descriptor structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The data count transferred to the buffer during the last DMA shot plus the data count which have been sent / retrieved since the beginning of the acquisition</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise negative error code. </dd></dl>

</div>
</div>
<a class="anchor" id="gabd70bc9f8bb4615f60c0107d51ca1f29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int a4l_buf_commit_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *&#160;</td>
          <td class="paramname"><em>subd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the count of data sent from the buffer to the device during the last completed DMA shots. </p>
<p>The functions a4l_buf_prepare_(abs)put(), a4l_buf_commit_(abs)put(), a4l_buf_prepare_(abs)get() and a4l_buf_commit_(abs)get() have been made available for DMA transfers. In such situations, no data copy is needed between the Analogy buffer and the device as some DMA controller is in charge of performing data shots from / to the Analogy buffer. However, some pointers still have to be updated so as to monitor the tranfers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subd</td><td>Subdevice descriptor structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The amount of data transferred</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise negative error code. </dd></dl>

</div>
</div>
<a class="anchor" id="gab03dcc685bcb3ad9111c9aa3dbe3baf5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int a4l_buf_commit_put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *&#160;</td>
          <td class="paramname"><em>subd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the count of data sent to the buffer during the last completed DMA shots. </p>
<p>The functions a4l_buf_prepare_(abs)put(), a4l_buf_commit_(abs)put(), a4l_buf_prepare_(abs)get() and a4l_buf_commit_(abs)get() have been made available for DMA transfers. In such situations, no data copy is needed between the Analogy buffer and the device as some DMA controller is in charge of performing data shots from / to the Analogy buffer. However, some pointers still have to be updated so as to monitor the tranfers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subd</td><td>Subdevice descriptor structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The amount of data transferred</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise negative error code. </dd></dl>

</div>
</div>
<a class="anchor" id="gad9e80150586b4a869562d3d098f49d36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long a4l_buf_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *&#160;</td>
          <td class="paramname"><em>subd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the data amount available in the Analogy buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subd</td><td>Subdevice descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the amount of data available in the Analogy buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="gac275c834264a50b9443304d33908f657"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int a4l_buf_evt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *&#160;</td>
          <td class="paramname"><em>subd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>evts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal some event(s) to a user-space program involved in some read / write operation. </p>
<p>The function <a class="el" href="group__analogy__buffer.html#gac275c834264a50b9443304d33908f657" title="Signal some event(s) to a user-space program involved in some read / write operation.">a4l_buf_evt()</a> is useful in many cases:</p>
<ul>
<li>To wake-up a process waiting for some data to read.</li>
<li>To wake-up a process waiting for some data to write.</li>
<li>To notify the user-process an error has occured during the acquistion.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subd</td><td>Subdevice descriptor structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">evts</td><td>Some specific event to notify:<ul>
<li>A4L_BUF_ERROR to indicate some error has occured during the transfer</li>
<li>A4L_BUF_EOA to indicate the acquisition is complete (this event is automatically set, it should not be used).</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise negative error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6af2dcaaecfd2cd9f0deb6e9167d3cff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int a4l_buf_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *&#160;</td>
          <td class="paramname"><em>subd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>bufdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy some data from the buffer to the device driver. </p>
<p>The function <a class="el" href="group__analogy__buffer.html#ga6af2dcaaecfd2cd9f0deb6e9167d3cff" title="Copy some data from the buffer to the device driver.">a4l_buf_get()</a> must copy data coming from the Analogy buffer to some acquisition device. This ring-buffer is an intermediate area between the device driver and the user-space program, which is supposed to provide the data to send to the device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subd</td><td>Subdevice descriptor structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufdata</td><td>The data buffer to copy into the Analogy buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The amount of data to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise negative error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7fecd99d23d53c69381aacee4d9222d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int a4l_buf_prepare_absget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *&#160;</td>
          <td class="paramname"><em>subd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the absolute count of data sent from the buffer to the device since the start of the acquisition and after the next DMA shot. </p>
<p>The functions a4l_buf_prepare_(abs)put(), a4l_buf_commit_(abs)put(), a4l_buf_prepare_(abs)get() and a4l_buf_commit_(absg)et() have been made available for DMA transfers. In such situations, no data copy is needed between the Analogy buffer and the device as some DMA controller is in charge of performing data shots from / to the Analogy buffer. However, some pointers still have to be updated so as to monitor the tranfers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subd</td><td>Subdevice descriptor structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The data count to be transferred during the next DMA shot plus the data count which have been copied since the start of the acquisition</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise negative error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8ffbc9832255a701624fe874d319e5f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int a4l_buf_prepare_absput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *&#160;</td>
          <td class="paramname"><em>subd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the absolute count of data sent from the device to the buffer since the start of the acquisition and after the next DMA shot. </p>
<p>The functions a4l_buf_prepare_(abs)put(), a4l_buf_commit_(abs)put(), a4l_buf_prepare_(abs)get() and a4l_buf_commit_(absg)et() have been made available for DMA transfers. In such situations, no data copy is needed between the Analogy buffer and the device as some DMA controller is in charge of performing data shots from / to the Analogy buffer. However, some pointers still have to be updated so as to monitor the tranfers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subd</td><td>Subdevice descriptor structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The data count to be transferred during the next DMA shot plus the data count which have been copied since the start of the acquisition</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise negative error code. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf9fe0b2fe2279e4f753ddec776d10c5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int a4l_buf_prepare_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *&#160;</td>
          <td class="paramname"><em>subd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the count of data which is to be sent from the buffer to the device at the next DMA shot. </p>
<p>The functions a4l_buf_prepare_(abs)put(), a4l_buf_commit_(abs)put(), a4l_buf_prepare_(abs)get() and a4l_buf_commit_(abs)get() have been made available for DMA transfers. In such situations, no data copy is needed between the Analogy buffer and the device as some DMA controller is in charge of performing data shots from / to the Analogy buffer. However, some pointers still have to be updated so as to monitor the tranfers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subd</td><td>Subdevice descriptor structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The data count to be transferred</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise negative error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga582e96ac8358717a19995e0c8c41dffc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int a4l_buf_prepare_put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *&#160;</td>
          <td class="paramname"><em>subd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the count of data which is to be sent to the buffer at the next DMA shot. </p>
<p>The functions a4l_buf_prepare_(abs)put(), a4l_buf_commit_(abs)put(), a4l_buf_prepare_(abs)get() and a4l_buf_commit_(abs)get() have been made available for DMA transfers. In such situations, no data copy is needed between the Analogy buffer and the device as some DMA controller is in charge of performing data shots from / to the Analogy buffer. However, some pointers still have to be updated so as to monitor the tranfers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subd</td><td>Subdevice descriptor structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The data count to be transferred</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise negative error code. </dd></dl>

</div>
</div>
<a class="anchor" id="gaec920d203e34f2020eb51ddad3461d1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int a4l_buf_put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *&#160;</td>
          <td class="paramname"><em>subd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>bufdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy some data from the device driver to the buffer. </p>
<p>The function <a class="el" href="group__analogy__buffer.html#gaec920d203e34f2020eb51ddad3461d1c" title="Copy some data from the device driver to the buffer.">a4l_buf_put()</a> must copy data coming from some acquisition device to the Analogy buffer. This ring-buffer is an intermediate area between the device driver and the user-space program, which is supposed to recover the acquired data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subd</td><td>Subdevice descriptor structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufdata</td><td>The data buffer to copy into the Analogy buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The amount of data to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise negative error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6e33ba6f8a06e3dbbfe3896b0258857f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int a4l_get_chan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *&#160;</td>
          <td class="paramname"><em>subd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the channel index according to its type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subd</td><td>Subdevice descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the channel index. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2386d5a9d84393b5db9beb22ae7674e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structa4l__cmd__desc.html">a4l_cmd_t</a>* a4l_get_cmd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *&#160;</td>
          <td class="paramname"><em>subd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current Analogy command descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subd</td><td>Subdevice descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the command descriptor. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Oct 4 2013 22:39:09 for Xenomai API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.2 </li>
  </ul>
</div>
</body>
</html>
