<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Xenomai API: Buffer services.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Buffer services.<br>
<small>
[<a class="el" href="group__native.html">Native Xenomai API.</a>]</small>
</h1>
<p>
<div class="dynheader">
Collaboration diagram for Buffer services.:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__buffer.png" border="0" alt="" usemap="#group____buffer_map">
<map name="group____buffer_map">
<area shape="rect" href="group__native.html" title="Native Xenomai API." alt="" coords="5,5,157,32"></map></td></tr></table></center>
</div>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Buffer services.<p>
A buffer is a lightweight IPC object, implementing a fast, one-way Producer-Consumer data path. All messages written are buffered in a single memory area in strict FIFO order, until read either in blocking or non-blocking mode.<p>
Message are always atomically handled on the write side (i.e. no interleave, no short writes), whilst only complete messages are normally returned to the read side. However, short reads may happen under a well-defined situation (see note in <a class="el" href="group__buffer.html#g24686310221a83682adcdf3347ac7dea" title="Read from a buffer.">rt_buffer_read()</a>), albeit they can be fully avoided by proper use of the buffer. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ksrc_2skins_2native_2buffer_8c.html">buffer.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This file is part of the Xenomai project. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer.html#g7aa6a3b48ba6b6ecdd7f2ad9152d2a61">rt_buffer_create</a> (RT_BUFFER *bf, const char *name, size_t bufsz, int mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a buffer.  <a href="#g7aa6a3b48ba6b6ecdd7f2ad9152d2a61"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer.html#gbd852c3c957d2dd37c15899119a3551e">rt_buffer_delete</a> (RT_BUFFER *bf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a buffer.  <a href="#gbd852c3c957d2dd37c15899119a3551e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer.html#g1819fcb58ee95c4ce13513039f5c447a">rt_buffer_write</a> (RT_BUFFER *bf, const void *ptr, size_t len, RTIME timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write to a buffer.  <a href="#g1819fcb58ee95c4ce13513039f5c447a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer.html#g8050d5c2639b0b6ac56d926acd8f938c">rt_buffer_write_until</a> (RT_BUFFER *bf, const void *ptr, size_t len, RTIME timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write to a buffer (with absolute timeout date).  <a href="#g8050d5c2639b0b6ac56d926acd8f938c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer.html#g24686310221a83682adcdf3347ac7dea">rt_buffer_read</a> (RT_BUFFER *bf, void *ptr, size_t len, RTIME timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read from a buffer.  <a href="#g24686310221a83682adcdf3347ac7dea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer.html#gf78c43664dda8a17c5c63ad4be2da179">rt_buffer_clear</a> (RT_BUFFER *bf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear a buffer.  <a href="#gf78c43664dda8a17c5c63ad4be2da179"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer.html#g98722ca524c008906069607a289fb26a">rt_buffer_inquire</a> (RT_BUFFER *bf, RT_BUFFER_INFO *info)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inquire about a buffer.  <a href="#g98722ca524c008906069607a289fb26a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer.html#g9d88ba56f1dc341b1b78c1549678fa4e">rt_buffer_bind</a> (RT_BUFFER *bf, const char *name, RTIME timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bind to a buffer.  <a href="#g9d88ba56f1dc341b1b78c1549678fa4e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer.html#g85e669d38297fa6dff6e78339bb8329d">rt_buffer_unbind</a> (RT_BUFFER *bf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unbind from a buffer.  <a href="#g85e669d38297fa6dff6e78339bb8329d"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g9d88ba56f1dc341b1b78c1549678fa4e"></a><!-- doxytag: member="buffer.h::rt_buffer_bind" ref="g9d88ba56f1dc341b1b78c1549678fa4e" args="(RT_BUFFER *bf, const char *name, RTIME timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_buffer_bind           </td>
          <td>(</td>
          <td class="paramtype">RT_BUFFER *&nbsp;</td>
          <td class="paramname"> <em>bf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bind to a buffer. 
<p>
This user-space only service retrieves the uniform descriptor of a given Xenomai buffer identified by its symbolic name. If the buffer does not exist on entry, this service blocks the caller until a buffer of the given name is created.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>A valid NULL-terminated name which identifies the buffer to bind to.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bf</em>&nbsp;</td><td>The address of a buffer descriptor retrieved by the operation. Contents of this memory is undefined upon failure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The number of clock ticks to wait for the registration to occur (see note). Passing TM_INFINITE causes the caller to block indefinitely until the object is registered. Passing TM_NONBLOCK causes the service to return immediately without waiting if the object is not registered on entry.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EFAULT is returned if <em>bf</em> or <em>name</em> is referencing invalid memory.</li></ul>
<p>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#g770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task.">rt_task_unblock()</a> has been called for the waiting task before the retrieval has completed.</li></ul>
<p>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to TM_NONBLOCK and the searched object is not registered on entry.</li></ul>
<p>
<ul>
<li>-ETIMEDOUT is returned if the object cannot be retrieved within the specified amount of time.</li></ul>
<p>
<ul>
<li>-EPERM is returned if this service should block, but was called from a context which cannot sleep (e.g. interrupt, non-realtime context).</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>User-space task (switches to primary mode)</li></ul>
<p>
Rescheduling: always unless the request is immediately satisfied or <em>timeout</em> specifies a non-blocking operation.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The <em>timeout</em> value will be interpreted as jiffies if the native skin is bound to a periodic time base (see CONFIG_XENO_OPT_NATIVE_PERIOD), or nanosebfs otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf78c43664dda8a17c5c63ad4be2da179"></a><!-- doxytag: member="buffer.c::rt_buffer_clear" ref="gf78c43664dda8a17c5c63ad4be2da179" args="(RT_BUFFER *bf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_buffer_clear           </td>
          <td>(</td>
          <td class="paramtype">RT_BUFFER *&nbsp;</td>
          <td class="paramname"> <em>bf</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear a buffer. 
<p>
Empties a buffer from any data.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bf</em>&nbsp;</td><td>The descriptor address of the cleared buffer.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>bf</em> is not a buffer descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>bf</em> is a deleted buffer descriptor.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: possible, as a consequence of resuming tasks that wait for buffer space in <a class="el" href="group__buffer.html#g1819fcb58ee95c4ce13513039f5c447a" title="Write to a buffer.">rt_buffer_write()</a>. 
<p>References <a class="el" href="pod_8h-source.html#l00251">xnpod_schedule()</a>, and <a class="el" href="synch_8c-source.html#l00848">xnsynch_flush()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g7aa6a3b48ba6b6ecdd7f2ad9152d2a61"></a><!-- doxytag: member="buffer.c::rt_buffer_create" ref="g7aa6a3b48ba6b6ecdd7f2ad9152d2a61" args="(RT_BUFFER *bf, const char *name, size_t bufsz, int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_buffer_create           </td>
          <td>(</td>
          <td class="paramtype">RT_BUFFER *&nbsp;</td>
          <td class="paramname"> <em>bf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bufsz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a buffer. 
<p>
Create a synchronization object that allows tasks to send and receive data asynchronously via a memory buffer. Data may be of an arbitrary length, albeit this IPC is best suited for small to medium-sized messages, since data always have to be copied to the buffer during transit. Large messages may be more efficiently handled by message queues (RT_QUEUE) via <a class="el" href="group__native__queue.html#g8b1dcb15753bdfce02f25f166e18948d" title="Send a message to a queue.">rt_queue_send()</a>/rt_queue_receive() services.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bf</em>&nbsp;</td><td>The address of a buffer descriptor Xenomai will use to store the buffer-related data. This descriptor must always be valid while the buffer is active therefore it must be allocated in permanent memory.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>An ASCII string standing for the symbolic name of the buffer. When non-NULL and non-empty, this string is copied to a safe place into the descriptor, and passed to the registry package if enabled for indexing the created buffer.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bufsz</em>&nbsp;</td><td>The size of the buffer space available to hold data. The required memory is obtained from the system heap.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>The buffer creation mode. The following flags can be OR'ed into this bitmask, each of them affecting the new buffer:</td></tr>
  </table>
</dl>
<ul>
<li>B_FIFO makes tasks pend in FIFO order for reading data from the buffer.</li></ul>
<p>
<ul>
<li>B_PRIO makes tasks pend in priority order for reading data from the buffer.</li></ul>
<p>
This parameter also applies to tasks blocked on the buffer's output queue (see <a class="el" href="group__buffer.html#g1819fcb58ee95c4ce13513039f5c447a" title="Write to a buffer.">rt_buffer_write()</a>).<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-ENOMEM is returned if the system fails to get enough dynamic memory from the global real-time heap in order to register the buffer.</li></ul>
<p>
<ul>
<li>-EEXIST is returned if the <em>name</em> is already in use by some registered object.</li></ul>
<p>
<ul>
<li>-EPERM is returned if this service was called from an asynchronous context.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>User-space task (switches to secondary mode)</li></ul>
<p>
Rescheduling: possible. 
<p>References <a class="el" href="src_2skins_2native_2buffer_8c-source.html#l00037">rt_buffer_delete()</a>, <a class="el" href="nucleus_2registry_8c-source.html#l00573">xnregistry_enter()</a>, and <a class="el" href="synch_8c-source.html#l00102">xnsynch_init()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gbd852c3c957d2dd37c15899119a3551e"></a><!-- doxytag: member="buffer.c::rt_buffer_delete" ref="gbd852c3c957d2dd37c15899119a3551e" args="(RT_BUFFER *bf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_buffer_delete           </td>
          <td>(</td>
          <td class="paramtype">RT_BUFFER *&nbsp;</td>
          <td class="paramname"> <em>bf</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete a buffer. 
<p>
Destroy a buffer and release all the tasks currently pending on it. A buffer exists in the system since <a class="el" href="group__buffer.html#g7aa6a3b48ba6b6ecdd7f2ad9152d2a61" title="Create a buffer.">rt_buffer_create()</a> has been called to create it, so this service must be called in order to destroy it afterwards.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bf</em>&nbsp;</td><td>The descriptor address of the buffer to delete.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>bf</em> is not a buffer descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>bf</em> is a deleted buffer descriptor.</li></ul>
<p>
<ul>
<li>-EPERM is returned if this service was called from an asynchronous context.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>User-space task (switches to secondary mode)</li></ul>
<p>
Rescheduling: possible. 
<p>References <a class="el" href="pod_8h-source.html#l00251">xnpod_schedule()</a>, and <a class="el" href="nucleus_2registry_8c-source.html#l00809">xnregistry_remove()</a>.</p>

<p>Referenced by <a class="el" href="ksrc_2skins_2native_2buffer_8c-source.html#l00191">rt_buffer_create()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g98722ca524c008906069607a289fb26a"></a><!-- doxytag: member="buffer.c::rt_buffer_inquire" ref="g98722ca524c008906069607a289fb26a" args="(RT_BUFFER *bf, RT_BUFFER_INFO *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_buffer_inquire           </td>
          <td>(</td>
          <td class="paramtype">RT_BUFFER *&nbsp;</td>
          <td class="paramname"> <em>bf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RT_BUFFER_INFO *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inquire about a buffer. 
<p>
Return various information about the status of a given buffer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bf</em>&nbsp;</td><td>The descriptor address of the inquired buffer.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>The address of a structure the buffer information will be written to.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned and status information is written to the structure pointed at by <em>info</em> upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>bf</em> is not a buffer descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>bf</em> is a deleted buffer descriptor.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="g24686310221a83682adcdf3347ac7dea"></a><!-- doxytag: member="buffer.c::rt_buffer_read" ref="g24686310221a83682adcdf3347ac7dea" args="(RT_BUFFER *bf, void *ptr, size_t len, RTIME timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_buffer_read           </td>
          <td>(</td>
          <td class="paramtype">RT_BUFFER *&nbsp;</td>
          <td class="paramname"> <em>bf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read from a buffer. 
<p>
Reads the next message from the specified buffer. If no message is available on entry, the caller is allowed to block until enough data is written to the buffer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bf</em>&nbsp;</td><td>The descriptor address of the buffer to read from.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>A pointer to a memory area which will be written upon success with the received data.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The length in bytes of the memory area pointed to by <em>ptr</em>. Under normal circumstances, <a class="el" href="group__buffer.html#g24686310221a83682adcdf3347ac7dea" title="Read from a buffer.">rt_buffer_read()</a> only returns entire messages as specified by the <em>len</em> argument, or an error value. However, short reads are allowed when a potential deadlock situation is detected (see note below).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The number of clock ticks to wait for a message to be available from the buffer (see note). Passing TM_INFINITE causes the caller to block indefinitely until enough data is available. Passing TM_NONBLOCK causes the service to return immediately without blocking in case not enough data is available.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes read from the buffer is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-ETIMEDOUT is returned if <em>timeout</em> is different from TM_NONBLOCK and not enough data is available within the specified amount of time to form a complete message.</li></ul>
<p>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to TM_NONBLOCK and not enough data is immediately available on entry to form a complete message.</li></ul>
<p>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#g770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task.">rt_task_unblock()</a> has been called for the reading task before enough data became available to form a complete message.</li></ul>
<p>
<ul>
<li>-EINVAL is returned if <em>bf</em> is not a buffer descriptor, or <em>len</em> is greater than the actual buffer length.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>bf</em> is a deleted buffer descriptor.</li></ul>
<p>
<ul>
<li>-EPERM is returned if this service should block, but was called from a context which cannot sleep (e.g. interrupt, non-realtime context).</li></ul>
<p>
<ul>
<li>-ENOMEM is returned if not enough memory is available from the system heap to hold a temporary copy of the message (user-space call only).</li></ul>
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>A short read (i.e. fewer bytes returned than requested by <em>len</em>) may happen whenever a pathological use of the buffer is encountered. This condition only arises when the system detects that one or more writers are waiting for sending data, while a reader would have to wait for receiving a complete message at the same time. For instance, consider the following sequence, involving a 1024-byte buffer (bf) and two threads:</dd></dl>
writer thread &gt; rt_write_buffer(&amp;bf, ptr, 1, TM_INFINITE); (one byte to read, 1023 bytes available for sending) writer thread &gt; rt_write_buffer(&amp;bf, ptr, 1024, TM_INFINITE); (writer blocks - no space for another 1024-byte message) reader thread &gt; rt_read_buffer(&amp;bf, ptr, 1024, TM_INFINITE); (short read - a truncated (1-byte) message is returned)<p>
In order to prevent both threads to wait for each other indefinitely, a short read is allowed, which may be completed by a subsequent call to <a class="el" href="group__buffer.html#g24686310221a83682adcdf3347ac7dea" title="Read from a buffer.">rt_buffer_read()</a> or rt_buffer_read_until(). If that case arises, thread priorities, buffer and/or message lengths should likely be fixed, in order to eliminate such condition.<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine (non-blocking call only)</li><li>Kernel-based task</li><li>User-space task (switches to primary mode)</li></ul>
<p>
Rescheduling: always unless the request is immediately satisfied and no task is waiting for buffer space to be released for the same buffer (see <a class="el" href="group__buffer.html#g1819fcb58ee95c4ce13513039f5c447a" title="Write to a buffer.">rt_buffer_write()</a>), or <em>timeout</em> specifies a non-blocking operation.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The <em>timeout</em> value will be interpreted as jiffies if the native skin is bound to a periodic time base (see CONFIG_XENO_OPT_NATIVE_PERIOD), or nanoseconds otherwise. </dd></dl>

<p>References <a class="el" href="bufd_8h-source.html#l00082">xnbufd_map_kwrite()</a>, and <a class="el" href="bufd_8c-source.html#l00792">xnbufd_unmap_kwrite()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g85e669d38297fa6dff6e78339bb8329d"></a><!-- doxytag: member="buffer.h::rt_buffer_unbind" ref="g85e669d38297fa6dff6e78339bb8329d" args="(RT_BUFFER *bf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_buffer_unbind           </td>
          <td>(</td>
          <td class="paramtype">RT_BUFFER *&nbsp;</td>
          <td class="paramname"> <em>bf</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unbind from a buffer. 
<p>
This user-space only service unbinds the calling task from the buffer object previously retrieved by a call to <a class="el" href="group__buffer.html#g9d88ba56f1dc341b1b78c1549678fa4e" title="Bind to a buffer.">rt_buffer_bind()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bf</em>&nbsp;</td><td>The address of a buffer descriptor to unbind from.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is always returned.</dd></dl>
This service can be called from:<p>
<ul>
<li>User-space task.</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="g1819fcb58ee95c4ce13513039f5c447a"></a><!-- doxytag: member="buffer.c::rt_buffer_write" ref="g1819fcb58ee95c4ce13513039f5c447a" args="(RT_BUFFER *bf, const void *ptr, size_t len, RTIME timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_buffer_write           </td>
          <td>(</td>
          <td class="paramtype">RT_BUFFER *&nbsp;</td>
          <td class="paramname"> <em>bf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write to a buffer. 
<p>
Writes a message to the specified buffer. If not enough buffer space is available on entry to hold the message, the caller is allowed to block until enough room is freed. Data written by <a class="el" href="group__buffer.html#g1819fcb58ee95c4ce13513039f5c447a" title="Write to a buffer.">rt_buffer_write()</a> calls can be read in FIFO order by subsequent <a class="el" href="group__buffer.html#g24686310221a83682adcdf3347ac7dea" title="Read from a buffer.">rt_buffer_read()</a> calls. Messages sent via <a class="el" href="group__buffer.html#g1819fcb58ee95c4ce13513039f5c447a" title="Write to a buffer.">rt_buffer_write()</a> are handled atomically (no interleave, no short writes).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bf</em>&nbsp;</td><td>The descriptor address of the buffer to write to.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>The address of the message data to be written to the buffer.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The length in bytes of the message data. Zero is a valid value, in which case the buffer is left untouched, and zero is returned to the caller. No partial message is ever sent.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The number of clock ticks to wait for enough buffer space to be available to hold the message (see note). Passing TM_INFINITE causes the caller to block indefinitely until enough buffer space is available. Passing TM_NONBLOCK causes the service to return immediately without blocking in case of buffer space shortage.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes written to the buffer is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-ETIMEDOUT is returned if <em>timeout</em> is different from TM_NONBLOCK and no buffer space is available within the specified amount of time to hold the message.</li></ul>
<p>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to TM_NONBLOCK and no buffer space is immediately available on entry to hold the message.</li></ul>
<p>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#g770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task.">rt_task_unblock()</a> has been called for the writing task before enough buffer space became available to hold the message.</li></ul>
<p>
<ul>
<li>-EINVAL is returned if <em>bf</em> is not a buffer descriptor, or <em>len</em> is greater than the actual buffer length.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>bf</em> is a deleted buffer descriptor.</li></ul>
<p>
<ul>
<li>-EPERM is returned if this service should block, but was called from a context which cannot sleep (e.g. interrupt, non-realtime context).</li></ul>
<p>
<ul>
<li>-ENOMEM is returned if not enough memory is available from the system heap to hold a temporary copy of the message (user-space call only).</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine (non-blocking call only)</li><li>Kernel-based task</li><li>User-space task (switches to primary mode)</li></ul>
<p>
Rescheduling: always unless the request is immediately satisfied and no task is waiting for messages on the same buffer, or <em>timeout</em> specifies a non-blocking operation.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The <em>timeout</em> value will be interpreted as jiffies if the native skin is bound to a periodic time base (see CONFIG_XENO_OPT_NATIVE_PERIOD), or nanoseconds otherwise. </dd></dl>

<p>References <a class="el" href="bufd_8h-source.html#l00076">xnbufd_map_kread()</a>, and <a class="el" href="bufd_8c-source.html#l00760">xnbufd_unmap_kread()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g8050d5c2639b0b6ac56d926acd8f938c"></a><!-- doxytag: member="buffer.c::rt_buffer_write_until" ref="g8050d5c2639b0b6ac56d926acd8f938c" args="(RT_BUFFER *bf, const void *ptr, size_t len, RTIME timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_buffer_write_until           </td>
          <td>(</td>
          <td class="paramtype">RT_BUFFER *&nbsp;</td>
          <td class="paramname"> <em>bf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write to a buffer (with absolute timeout date). 
<p>
Writes a message to the specified buffer. If not enough buffer space is available on entry to hold the message, the caller is allowed to block until enough room is freed, or a timeout elapses.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bf</em>&nbsp;</td><td>The descriptor address of the buffer to write to.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>The address of the message data to be written to the buffer.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The length in bytes of the message data. Zero is a valid value, in which case the buffer is left untouched, and zero is returned to the caller.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The absolute date specifying a time limit to wait for enough buffer space to be available to hold the message (see note). Passing TM_INFINITE causes the caller to block indefinitely until enough buffer space is available. Passing TM_NONBLOCK causes the service to return immediately without blocking in case of buffer space shortage.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes written to the buffer is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-ETIMEDOUT is returned if the absolute <em>timeout</em> date is reached before enough buffer space is available to hold the message.</li></ul>
<p>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to TM_NONBLOCK and no buffer space is immediately available on entry to hold the message.</li></ul>
<p>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#g770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task.">rt_task_unblock()</a> has been called for the writing task before enough buffer space became available to hold the message.</li></ul>
<p>
<ul>
<li>-EINVAL is returned if <em>bf</em> is not a buffer descriptor, or <em>len</em> is greater than the actual buffer length.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>bf</em> is a deleted buffer descriptor.</li></ul>
<p>
<ul>
<li>-EPERM is returned if this service should block, but was called from a context which cannot sleep (e.g. interrupt, non-realtime context).</li></ul>
<p>
<ul>
<li>-ENOMEM is returned if not enough memory is available from the system heap to hold a temporary copy of the message (user-space call only).</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine (non-blocking call only)</li><li>Kernel-based task</li><li>User-space task (switches to primary mode)</li></ul>
<p>
Rescheduling: always unless the request is immediately satisfied and no task is waiting for messages on the same buffer, or <em>timeout</em> specifies a non-blocking operation.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The <em>timeout</em> value will be interpreted as jiffies if the native skin is bound to a periodic time base (see CONFIG_XENO_OPT_NATIVE_PERIOD), or nanoseconds otherwise. </dd></dl>

<p>References <a class="el" href="bufd_8h-source.html#l00076">xnbufd_map_kread()</a>, and <a class="el" href="bufd_8c-source.html#l00760">xnbufd_unmap_kread()</a>.</p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed May 5 10:19:59 2010 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
