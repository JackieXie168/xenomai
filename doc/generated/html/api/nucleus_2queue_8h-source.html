<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Xenomai API: include/nucleus/queue.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000000.html">include</a>&nbsp;/&nbsp;<a class="el" href="dir_000006.html">nucleus</a></div>
<h1>queue.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (C) 2001,2002,2003 Philippe Gerum &lt;rpm@xenomai.org&gt;.</span>
00003 <span class="comment"> * Copyright (C) 2005 Dmitry Adamushko &lt;dmitry.adamushko@gmail.com&gt;</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * Xenomai is free software; you can redistribute it and/or modify</span>
00006 <span class="comment"> * it under the terms of the GNU General Public License as published</span>
00007 <span class="comment"> * by the Free Software Foundation; either version 2 of the License,</span>
00008 <span class="comment"> * or (at your option) any later version.</span>
00009 <span class="comment"> *</span>
00010 <span class="comment"> * Xenomai is distributed in the hope that it will be useful, but</span>
00011 <span class="comment"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00013 <span class="comment"> * General Public License for more details.</span>
00014 <span class="comment"> *</span>
00015 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
00016 <span class="comment"> * along with Xenomai; if not, write to the Free Software</span>
00017 <span class="comment"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</span>
00018 <span class="comment"> * 02111-1307, USA.</span>
00019 <span class="comment"> */</span>
00020 
00021 <span class="preprocessor">#ifndef _XENO_NUCLEUS_QUEUE_H</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#define _XENO_NUCLEUS_QUEUE_H</span>
00023 <span class="preprocessor"></span>
00024 <span class="preprocessor">#include &lt;nucleus/types.h&gt;</span>
00025 <span class="preprocessor">#include &lt;nucleus/core.h&gt;</span>
00026 
00027 <span class="comment">/* Basic element holder */</span>
00028 
00029 <span class="keyword">typedef</span> <span class="keyword">struct </span>xnholder {
00030 
00031     <span class="keyword">struct </span>xnholder *next;
00032     <span class="keyword">struct </span>xnholder *last;
00033 
00034 } xnholder_t;
00035 
00036 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> inith (xnholder_t *holder)
00037 {
00038     <span class="comment">/* Holding queues are doubly-linked and circular */</span>
00039     holder-&gt;last = holder;
00040     holder-&gt;next = holder;
00041 }
00042 
00043 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ath (xnholder_t *head,
00044                         xnholder_t *holder)
00045 {
00046     <span class="comment">/* Inserts the new element right after the heading one  */</span>
00047     holder-&gt;last = head;
00048     holder-&gt;next = head-&gt;next;
00049     holder-&gt;next-&gt;last = holder;
00050     head-&gt;next = holder;
00051 }
00052 
00053 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> dth (xnholder_t *holder)
00054 {
00055     holder-&gt;last-&gt;next = holder-&gt;next;
00056     holder-&gt;next-&gt;last = holder-&gt;last;
00057 }
00058 
00059 <span class="comment">/* Basic element queue */</span>
00060 
00061 <span class="keyword">typedef</span> <span class="keyword">struct </span>xnqueue {
00062 
00063     xnholder_t head;
00064     <span class="keywordtype">int</span> elems;
00065 <span class="preprocessor">#if defined(__KERNEL__) &amp;&amp; defined(CONFIG_XENO_OPT_DEBUG_QUEUES) &amp;&amp; defined(CONFIG_SMP)</span>
00066 <span class="preprocessor"></span>    xnlock_t lock;
00067 <span class="preprocessor">#endif </span><span class="comment">/* __KERNEL__ &amp;&amp; CONFIG_XENO_OPT_DEBUG_QUEUES &amp;&amp; CONFIG_SMP */</span>
00068 
00069 } xnqueue_t;
00070 
00071 <span class="preprocessor">#if defined(CONFIG_XENO_OPT_DEBUG_QUEUES) &amp;&amp; defined(CONFIG_SMP)</span>
00072 <span class="preprocessor"></span><span class="preprocessor">#define DECLARE_XNQUEUE(q) xnqueue_t q = { { &amp;(q).head, &amp;(q).head }, 0, XNARCH_LOCK_UNLOCKED }</span>
00073 <span class="preprocessor"></span><span class="preprocessor">#else </span><span class="comment">/* !(CONFIG_XENO_OPT_DEBUG_QUEUES &amp;&amp; CONFIG_SMP) */</span>
00074 <span class="preprocessor">#define DECLARE_XNQUEUE(q) xnqueue_t q = { { &amp;(q).head, &amp;(q).head }, 0 }</span>
00075 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* CONFIG_XENO_OPT_DEBUG_QUEUES &amp;&amp; CONFIG_SMP */</span>
00076 
00077 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> initq (xnqueue_t *qslot)
00078 {
00079     inith(&amp;qslot-&gt;head);
00080     qslot-&gt;elems = 0;
00081 <span class="preprocessor">#if defined(__KERNEL__) &amp;&amp; defined(CONFIG_XENO_OPT_DEBUG_QUEUES) &amp;&amp; defined(CONFIG_SMP)</span>
00082 <span class="preprocessor"></span>    xnlock_init(&amp;qslot-&gt;lock);
00083 <span class="preprocessor">#endif </span><span class="comment">/* __KERNEL__ &amp;&amp; CONFIG_XENO_OPT_DEBUG_QUEUES &amp;&amp; CONFIG_SMP */</span>
00084 }
00085 
00086 <span class="preprocessor">#ifdef CONFIG_XENO_OPT_DEBUG_QUEUES</span>
00087 <span class="preprocessor"></span>
00088 <span class="preprocessor">#if defined(__KERNEL__) || defined(__XENO_UVM__) || defined(__XENO_SIM__)</span>
00089 <span class="preprocessor"></span>
00090 <span class="preprocessor">#define XENO_DEBUG_CHECK_QUEUE(__qslot)         \</span>
00091 <span class="preprocessor">do { \</span>
00092 <span class="preprocessor">    xnholder_t *curr; \</span>
00093 <span class="preprocessor">    spl_t s; \</span>
00094 <span class="preprocessor">    int nelems = 0; \</span>
00095 <span class="preprocessor">    xnlock_get_irqsave(&amp;(__qslot)-&gt;lock,s);     \</span>
00096 <span class="preprocessor">    curr = (__qslot)-&gt;head.last;                                  \</span>
00097 <span class="preprocessor">    while (curr != &amp;(__qslot)-&gt;head &amp;&amp; nelems &lt; (__qslot)-&gt;elems)       \</span>
00098 <span class="preprocessor">        curr = curr-&gt;last, nelems++; \</span>
00099 <span class="preprocessor">    if (curr != &amp;(__qslot)-&gt;head || nelems != (__qslot)-&gt;elems)   \</span>
00100 <span class="preprocessor">        xnpod_fatal("corrupted queue, qslot-&gt;elems=%d, qslot=%p at %s:%d", \</span>
00101 <span class="preprocessor">                    (__qslot)-&gt;elems,                             \</span>
00102 <span class="preprocessor">                    __qslot,                                      \</span>
00103 <span class="preprocessor">                    __FILE__,__LINE__);                           \</span>
00104 <span class="preprocessor">    xnlock_put_irqrestore(&amp;(__qslot)-&gt;lock,s);  \</span>
00105 <span class="preprocessor">} while(0)</span>
00106 <span class="preprocessor"></span>
00107 <span class="preprocessor">#define XENO_DEBUG_INSERT_QUEUE(__qslot,__holder)               \</span>
00108 <span class="preprocessor">do { \</span>
00109 <span class="preprocessor">    xnholder_t *curr; \</span>
00110 <span class="preprocessor">    spl_t s; \</span>
00111 <span class="preprocessor">    xnlock_get_irqsave(&amp;(__qslot)-&gt;lock,s);     \</span>
00112 <span class="preprocessor">    curr = (__qslot)-&gt;head.last;                           \</span>
00113 <span class="preprocessor">    while (curr != &amp;(__qslot)-&gt;head &amp;&amp; (__holder) != curr)      \</span>
00114 <span class="preprocessor">        curr = curr-&gt;last; \</span>
00115 <span class="preprocessor">    if (curr == (__holder))                                         \</span>
00116 <span class="preprocessor">        xnpod_fatal("inserting element twice, holder=%p, qslot=%p at %s:%d", \</span>
00117 <span class="preprocessor">                    __holder, \</span>
00118 <span class="preprocessor">                    __qslot, \</span>
00119 <span class="preprocessor">                    __FILE__,__LINE__); \</span>
00120 <span class="preprocessor">    if ((__holder)-&gt;last == NULL)                                  \</span>
00121 <span class="preprocessor">        xnpod_fatal("holder=%p not initialized, qslot=%p", \</span>
00122 <span class="preprocessor">                    __holder, \</span>
00123 <span class="preprocessor">                    __qslot); \</span>
00124 <span class="preprocessor">    xnlock_put_irqrestore(&amp;(__qslot)-&gt;lock,s);  \</span>
00125 <span class="preprocessor">} while(0)</span>
00126 <span class="preprocessor"></span>
00127 <span class="preprocessor">#define XENO_DEBUG_REMOVE_QUEUE(__qslot,__holder)       \</span>
00128 <span class="preprocessor">do { \</span>
00129 <span class="preprocessor">    xnholder_t *curr; \</span>
00130 <span class="preprocessor">    spl_t s; \</span>
00131 <span class="preprocessor">    xnlock_get_irqsave(&amp;(__qslot)-&gt;lock,s);     \</span>
00132 <span class="preprocessor">    curr = (__qslot)-&gt;head.last;                           \</span>
00133 <span class="preprocessor">    while (curr != &amp;(__qslot)-&gt;head &amp;&amp; (__holder) != curr)      \</span>
00134 <span class="preprocessor">        curr = curr-&gt;last; \</span>
00135 <span class="preprocessor">    if (curr == &amp;(__qslot)-&gt;head)                                               \</span>
00136 <span class="preprocessor">        xnpod_fatal("removing non-linked element, holder=%p, qslot=%p at %s:%d", \</span>
00137 <span class="preprocessor">                    __holder, \</span>
00138 <span class="preprocessor">                    __qslot,    \</span>
00139 <span class="preprocessor">                    __FILE__,__LINE__); \</span>
00140 <span class="preprocessor">    xnlock_put_irqrestore(&amp;(__qslot)-&gt;lock,s);  \</span>
00141 <span class="preprocessor">} while(0)</span>
00142 <span class="preprocessor"></span>
00143 <span class="preprocessor">#else </span><span class="comment">/* !(__KERNEL__ || __XENO_UVM__ || __XENO_SIM__) */</span>
00144 
00145 <span class="comment">/* Disable queue checks in user-space code which does not run as part</span>
00146 <span class="comment">   of any virtual machine, e.g. skin call interface libs. */</span>
00147 
00148 <span class="preprocessor">#define XENO_DEBUG_CHECK_QUEUE(__qslot)</span>
00149 <span class="preprocessor"></span><span class="preprocessor">#define XENO_DEBUG_INSERT_QUEUE(__qslot,__holder)</span>
00150 <span class="preprocessor"></span><span class="preprocessor">#define XENO_DEBUG_REMOVE_QUEUE(__qslot,__holder)</span>
00151 <span class="preprocessor"></span>
00152 <span class="preprocessor">#endif </span><span class="comment">/* __KERNEL__ || __XENO_UVM__ || __XENO_SIM__ */</span>
00153 
00154 <span class="comment">/* Write the following as macros so that line numbering information</span>
00155 <span class="comment">   keeps pointing at the real caller in diagnosis messages. */</span>
00156 
00157 <span class="preprocessor">#define insertq(__qslot,__head,__holder)        \</span>
00158 <span class="preprocessor">({ XENO_DEBUG_CHECK_QUEUE(__qslot);             \</span>
00159 <span class="preprocessor">   XENO_DEBUG_INSERT_QUEUE(__qslot,__holder);   \</span>
00160 <span class="preprocessor">   ath((__head)-&gt;last,__holder);                \</span>
00161 <span class="preprocessor">   ++(__qslot)-&gt;elems; })</span>
00162 <span class="preprocessor"></span>
00163 <span class="preprocessor">#define prependq(__qslot,__holder)              \</span>
00164 <span class="preprocessor">({ XENO_DEBUG_CHECK_QUEUE(__qslot);             \</span>
00165 <span class="preprocessor">   XENO_DEBUG_INSERT_QUEUE(__qslot,__holder);   \</span>
00166 <span class="preprocessor">   ath(&amp;(__qslot)-&gt;head,__holder);              \</span>
00167 <span class="preprocessor">   ++(__qslot)-&gt;elems; })</span>
00168 <span class="preprocessor"></span>
00169 <span class="preprocessor">#define appendq(__qslot,__holder)               \</span>
00170 <span class="preprocessor">({ XENO_DEBUG_CHECK_QUEUE(__qslot);             \</span>
00171 <span class="preprocessor">   XENO_DEBUG_INSERT_QUEUE(__qslot,__holder);   \</span>
00172 <span class="preprocessor">   ath((__qslot)-&gt;head.last,__holder);          \</span>
00173 <span class="preprocessor">   ++(__qslot)-&gt;elems; })</span>
00174 <span class="preprocessor"></span>
00175 <span class="preprocessor">#define removeq(__qslot,__holder)               \</span>
00176 <span class="preprocessor">({ XENO_DEBUG_CHECK_QUEUE(__qslot);             \</span>
00177 <span class="preprocessor">   XENO_DEBUG_REMOVE_QUEUE(__qslot,__holder);   \</span>
00178 <span class="preprocessor">   dth(__holder);                               \</span>
00179 <span class="preprocessor">   --(__qslot)-&gt;elems; })</span>
00180 <span class="preprocessor"></span>
00181 <span class="preprocessor">#else </span><span class="comment">/* !CONFIG_XENO_OPT_DEBUG_QUEUES */</span>
00182 
00183 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> insertq (xnqueue_t *qslot,
00184                             xnholder_t *head,
00185                             xnholder_t *holder)
00186 {
00187     <span class="comment">/* Insert the &lt;holder&gt; element before &lt;head&gt; */</span>
00188     ath(head-&gt;last,holder);
00189     ++qslot-&gt;elems;
00190 }
00191 
00192 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> prependq (xnqueue_t *qslot,
00193                              xnholder_t *holder)
00194 {
00195     <span class="comment">/* Prepend the element to the queue */</span>
00196     ath(&amp;qslot-&gt;head,holder);
00197     ++qslot-&gt;elems;
00198 }
00199 
00200 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> appendq (xnqueue_t *qslot,
00201                            xnholder_t *holder)
00202 {
00203     <span class="comment">/* Append the element to the queue */</span>
00204     ath(qslot-&gt;head.last,holder);
00205     ++qslot-&gt;elems;
00206 }
00207 
00208 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> removeq (xnqueue_t *qslot,
00209                             xnholder_t *holder)
00210 {
00211     dth(holder);
00212     --qslot-&gt;elems;
00213 }
00214 
00215 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_XENO_OPT_DEBUG_QUEUES */</span>
00216 
00217 <span class="keyword">static</span> <span class="keyword">inline</span> xnholder_t *getheadq (xnqueue_t *qslot)
00218 {
00219     xnholder_t *holder = qslot-&gt;head.next;
00220     <span class="keywordflow">return</span> holder == &amp;qslot-&gt;head ? NULL : holder;
00221 }
00222 
00223 <span class="keyword">static</span> <span class="keyword">inline</span> xnholder_t *getq (xnqueue_t *qslot)
00224 {
00225     xnholder_t *holder = getheadq(qslot);
00226     <span class="keywordflow">if</span> (holder) removeq(qslot,holder);
00227     <span class="keywordflow">return</span> holder;
00228 }
00229 
00230 <span class="keyword">static</span> <span class="keyword">inline</span> xnholder_t *nextq (xnqueue_t *qslot,
00231                                  xnholder_t *holder)
00232 {
00233     xnholder_t *nextholder = holder-&gt;next;
00234     <span class="keywordflow">return</span> nextholder == &amp;qslot-&gt;head ? NULL : nextholder;
00235 }
00236 
00237 <span class="keyword">static</span> <span class="keyword">inline</span> xnholder_t *popq (xnqueue_t *qslot,
00238                                 xnholder_t *holder)
00239 {
00240     xnholder_t *nextholder = nextq(qslot,holder);
00241     removeq(qslot,holder);
00242     <span class="keywordflow">return</span> nextholder;
00243 }
00244 
00245 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> countq (xnqueue_t *qslot)
00246 {
00247     <span class="keywordflow">return</span> qslot-&gt;elems;
00248 }
00249 
00250 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> emptyq_p (xnqueue_t *qslot)
00251 {
00252     <span class="keywordflow">return</span> qslot-&gt;head.next == &amp;qslot-&gt;head;
00253 }
00254 
00255 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> moveq (xnqueue_t *dstq, xnqueue_t *srcq)
00256 {
00257     xnholder_t *headsrc = srcq-&gt;head.next;
00258     xnholder_t *tailsrc = srcq-&gt;head.last-&gt;last;
00259     xnholder_t *headdst = &amp;dstq-&gt;head;
00260 
00261     headsrc-&gt;last-&gt;next = tailsrc-&gt;next;
00262     tailsrc-&gt;next-&gt;last = headsrc-&gt;last;
00263     headsrc-&gt;last = headdst;
00264     tailsrc-&gt;next = headdst-&gt;next;
00265     headdst-&gt;next-&gt;last = tailsrc;
00266     headdst-&gt;next = headsrc;
00267     dstq-&gt;elems += srcq-&gt;elems;
00268     srcq-&gt;elems = 0;
00269 }
00270 
00271 <span class="comment">/* Prioritized element holder */</span>
00272 
00273 <span class="keyword">typedef</span> <span class="keyword">struct </span>xnpholder {
00274 
00275     xnholder_t plink;
00276     <span class="keywordtype">int</span> prio;
00277 
00278 } xnpholder_t;
00279 
00280 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> initph (xnpholder_t *holder)
00281 {
00282     inith(&amp;holder-&gt;plink);
00283     <span class="comment">/* Priority is set upon queue insertion */</span>
00284 }
00285 
00286 <span class="comment">/* Prioritized element queue */</span>
00287 
00288 <span class="preprocessor">#define xnqueue_up   (-1)</span>
00289 <span class="preprocessor"></span><span class="preprocessor">#define xnqueue_down   1</span>
00290 <span class="preprocessor"></span>
00291 <span class="keyword">typedef</span> <span class="keyword">struct </span>xnpqueue {
00292 
00293     xnqueue_t pqueue;
00294     <span class="keywordtype">int</span> qdir;
00295 
00296 } xnpqueue_t;
00297 
00298 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> initpq (xnpqueue_t *pqslot,
00299                            <span class="keywordtype">int</span> qdir,
00300                            <span class="keywordtype">int</span> maxpri)
00301 {
00302     initq(&amp;pqslot-&gt;pqueue);
00303     pqslot-&gt;qdir = qdir;
00304 }
00305 
00306 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> insertpq (xnpqueue_t *pqslot,
00307                              xnpholder_t *head,
00308                              xnpholder_t *holder)
00309 {
00310     <span class="comment">/* Insert the &lt;holder&gt; element before &lt;head&gt; */</span>
00311     insertq(&amp;pqslot-&gt;pqueue,&amp;head-&gt;plink,&amp;holder-&gt;plink);
00312 }
00313 
00314 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> insertpqf (xnpqueue_t *pqslot,
00315                               xnpholder_t *holder,
00316                               <span class="keywordtype">int</span> prio)
00317 {
00318     <span class="comment">/* Insert the element at the end of its priority group (FIFO) */</span>
00319 
00320     xnholder_t *curr;
00321 
00322     <span class="keywordflow">if</span> (pqslot-&gt;qdir == xnqueue_down) {
00323         <span class="keywordflow">for</span> (curr = pqslot-&gt;pqueue.head.last;
00324              curr != &amp;pqslot-&gt;pqueue.head; curr = curr-&gt;last) {
00325                 <span class="keywordflow">if</span> (prio &lt;= ((xnpholder_t *)curr)-&gt;prio)
00326                     <span class="keywordflow">break</span>;
00327         }
00328     }
00329     <span class="keywordflow">else</span> {
00330         <span class="keywordflow">for</span> (curr = pqslot-&gt;pqueue.head.last;
00331              curr != &amp;pqslot-&gt;pqueue.head; curr = curr-&gt;last) {
00332                 <span class="keywordflow">if</span> (prio &gt;= ((xnpholder_t *)curr)-&gt;prio)
00333                     <span class="keywordflow">break</span>;
00334         }
00335     }
00336 
00337     holder-&gt;prio = prio;
00338 
00339     insertq(&amp;pqslot-&gt;pqueue,curr-&gt;next,&amp;holder-&gt;plink);
00340 }
00341 
00342 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> insertpql (xnpqueue_t *pqslot,
00343                               xnpholder_t *holder,
00344                               <span class="keywordtype">int</span> prio)
00345 {
00346     <span class="comment">/* Insert the element at the front of its priority group (LIFO) */</span>
00347 
00348     xnholder_t *curr;
00349 
00350     <span class="keywordflow">if</span> (pqslot-&gt;qdir == xnqueue_down) {
00351         <span class="keywordflow">for</span> (curr = pqslot-&gt;pqueue.head.next;
00352              curr != &amp;pqslot-&gt;pqueue.head; curr = curr-&gt;next) {
00353                 <span class="keywordflow">if</span> (prio &gt;= ((xnpholder_t *)curr)-&gt;prio)
00354                     <span class="keywordflow">break</span>;
00355         }
00356     }
00357     <span class="keywordflow">else</span> {
00358         <span class="keywordflow">for</span> (curr = pqslot-&gt;pqueue.head.next;
00359              curr != &amp;pqslot-&gt;pqueue.head; curr = curr-&gt;next) {
00360                 <span class="keywordflow">if</span> (prio &lt;= ((xnpholder_t *)curr)-&gt;prio)
00361                     <span class="keywordflow">break</span>;
00362         }
00363     }
00364 
00365     holder-&gt;prio = prio;
00366 
00367     insertq(&amp;pqslot-&gt;pqueue,curr,&amp;holder-&gt;plink);
00368 }
00369 
00370 <span class="keyword">static</span> <span class="keyword">inline</span> xnpholder_t *findpqh (xnpqueue_t *pqslot,
00371                                     <span class="keywordtype">int</span> prio)
00372 {
00373     <span class="comment">/* Find the element heading a given priority group */</span>
00374 
00375     xnholder_t *curr;
00376 
00377     <span class="keywordflow">if</span> (pqslot-&gt;qdir == xnqueue_down) {
00378         <span class="keywordflow">for</span> (curr = pqslot-&gt;pqueue.head.next;
00379              curr != &amp;pqslot-&gt;pqueue.head; curr = curr-&gt;next) {
00380                 <span class="keywordflow">if</span> (prio &gt;= ((xnpholder_t *)curr)-&gt;prio)
00381                     <span class="keywordflow">break</span>;
00382         }
00383     }
00384     <span class="keywordflow">else</span> {
00385         <span class="keywordflow">for</span> (curr = pqslot-&gt;pqueue.head.next;
00386              curr != &amp;pqslot-&gt;pqueue.head; curr = curr-&gt;next) {
00387                 <span class="keywordflow">if</span> (prio &lt;= ((xnpholder_t *)curr)-&gt;prio)
00388                     <span class="keywordflow">break</span>;
00389         }
00390     }
00391 
00392     <span class="keywordflow">if</span> (curr &amp;&amp; ((xnpholder_t *)curr)-&gt;prio == prio)
00393         <span class="keywordflow">return</span> (xnpholder_t *)curr;
00394 
00395     <span class="keywordflow">return</span> NULL;
00396 }
00397 
00398 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> appendpq (xnpqueue_t *pqslot,
00399                              xnpholder_t *holder)
00400 {
00401     holder-&gt;prio = 0;
00402     appendq(&amp;pqslot-&gt;pqueue,&amp;holder-&gt;plink);
00403 }
00404 
00405 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> prependpq (xnpqueue_t *pqslot,
00406                               xnpholder_t *holder)
00407 {
00408     holder-&gt;prio = 0;
00409     prependq(&amp;pqslot-&gt;pqueue,&amp;holder-&gt;plink);
00410 }
00411 
00412 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> removepq (xnpqueue_t *pqslot,
00413                              xnpholder_t *holder)
00414 {
00415     removeq(&amp;pqslot-&gt;pqueue,&amp;holder-&gt;plink);
00416 }
00417 
00418 <span class="keyword">static</span> <span class="keyword">inline</span> xnpholder_t *getheadpq (xnpqueue_t *pqslot)
00419 {
00420     <span class="keywordflow">return</span> (xnpholder_t *)getheadq(&amp;pqslot-&gt;pqueue);
00421 }
00422 
00423 <span class="keyword">static</span> <span class="keyword">inline</span> xnpholder_t *nextpq (xnpqueue_t *pqslot,
00424                                    xnpholder_t *holder)
00425 {
00426     <span class="keywordflow">return</span> (xnpholder_t *)nextq(&amp;pqslot-&gt;pqueue,&amp;holder-&gt;plink);
00427 }
00428 
00429 <span class="keyword">static</span> <span class="keyword">inline</span> xnpholder_t *getpq (xnpqueue_t *pqslot)
00430 {
00431     <span class="keywordflow">return</span> (xnpholder_t *)getq(&amp;pqslot-&gt;pqueue);
00432 }
00433 
00434 <span class="keyword">static</span> <span class="keyword">inline</span> xnpholder_t *poppq (xnpqueue_t *pqslot,
00435                                   xnpholder_t *holder)
00436 {
00437     <span class="keywordflow">return</span> (xnpholder_t *)popq(&amp;pqslot-&gt;pqueue,&amp;holder-&gt;plink);
00438 }
00439 
00440 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> countpq (xnpqueue_t *pqslot)
00441 {
00442     <span class="keywordflow">return</span> countq(&amp;pqslot-&gt;pqueue);
00443 }
00444 
00445 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> emptypq_p (xnpqueue_t *pqslot)
00446 {
00447     <span class="keywordflow">return</span> emptyq_p(&amp;pqslot-&gt;pqueue);
00448 }
00449 
00450 <span class="comment">/* Generic prioritized element holder */</span>
00451 
00452 <span class="keyword">typedef</span> <span class="keyword">struct </span>xngholder {
00453 
00454     xnpholder_t glink;
00455     <span class="keywordtype">void</span> *data;
00456 
00457 } xngholder_t;
00458 
00459 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> initgh (xngholder_t *holder, <span class="keywordtype">void</span> *data)
00460 {
00461     inith(&amp;holder-&gt;glink.plink);
00462     holder-&gt;data = data;
00463 }
00464 
00465 <span class="comment">/* Generic element queue */</span>
00466 
00467 <span class="keyword">typedef</span> <span class="keyword">struct </span>xngqueue {
00468 
00469     xnpqueue_t gqueue;
00470     xnqueue_t *freehq;
00471     void (*starvation)(xnqueue_t *);
00472     <span class="keywordtype">int</span> threshold;
00473 
00474 } xngqueue_t;
00475 
00476 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> initgq (xngqueue_t *gqslot,
00477                            xnqueue_t *freehq,
00478                            <span class="keywordtype">void</span> (*starvation)(xnqueue_t *),
00479                            <span class="keywordtype">int</span> threshold,
00480                            <span class="keywordtype">int</span> qdir,
00481                            <span class="keywordtype">int</span> maxpri)
00482 {
00483     initpq(&amp;gqslot-&gt;gqueue,qdir,maxpri);
00484     gqslot-&gt;freehq = freehq;
00485     gqslot-&gt;starvation = starvation;
00486     gqslot-&gt;threshold = threshold;
00487 }
00488 
00489 <span class="keyword">static</span> <span class="keyword">inline</span> xngholder_t *allocgh (xngqueue_t *gqslot)
00490 {
00491     <span class="keywordflow">if</span> (countq(gqslot-&gt;freehq) &lt; gqslot-&gt;threshold)
00492         gqslot-&gt;starvation(gqslot-&gt;freehq);
00493 
00494     <span class="keywordflow">return</span> (xngholder_t *)getq(gqslot-&gt;freehq);
00495 }
00496 
00497 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> *removegh (xngqueue_t *gqslot,
00498                               xngholder_t *holder)
00499 {
00500     removepq(&amp;gqslot-&gt;gqueue,&amp;holder-&gt;glink);
00501     appendq(gqslot-&gt;freehq,&amp;holder-&gt;glink.plink);
00502     <span class="keywordflow">return</span> holder-&gt;data;
00503 }
00504 
00505 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> insertgqf (xngqueue_t *gqslot,
00506                              <span class="keywordtype">void</span> *data,
00507                              <span class="keywordtype">int</span> prio)
00508 {
00509     xngholder_t *holder = allocgh(gqslot);
00510     holder-&gt;data = data;
00511     <span class="keywordflow">return</span> insertpqf(&amp;gqslot-&gt;gqueue,&amp;holder-&gt;glink,prio);
00512 }
00513 
00514 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> insertgql (xngqueue_t *gqslot,
00515                               <span class="keywordtype">void</span> *data,
00516                               <span class="keywordtype">int</span> prio)
00517 {
00518     xngholder_t *holder = allocgh(gqslot);
00519     holder-&gt;data = data;
00520     insertpql(&amp;gqslot-&gt;gqueue,&amp;holder-&gt;glink,prio);
00521 }
00522 
00523 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> appendgq (xngqueue_t *gqslot,
00524                              <span class="keywordtype">void</span> *data)
00525 {
00526     xngholder_t *holder = allocgh(gqslot);
00527     holder-&gt;data = data;
00528     appendpq(&amp;gqslot-&gt;gqueue,&amp;holder-&gt;glink);
00529 }
00530 
00531 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> prependgq (xngqueue_t *gqslot,
00532                               <span class="keywordtype">void</span> *data)
00533 {
00534     xngholder_t *holder = allocgh(gqslot);
00535     holder-&gt;data = data;
00536     prependpq(&amp;gqslot-&gt;gqueue,&amp;holder-&gt;glink);
00537 }
00538 
00539 <span class="keyword">static</span> <span class="keyword">inline</span> xngholder_t *getheadgq (xngqueue_t *gqslot)
00540 {
00541     <span class="keywordflow">return</span> (xngholder_t *)getheadpq(&amp;gqslot-&gt;gqueue);
00542 }
00543 
00544 <span class="keyword">static</span> <span class="keyword">inline</span> xngholder_t *nextgq (xngqueue_t *gqslot,
00545                                    xngholder_t *holder)
00546 {
00547     <span class="keywordflow">return</span> (xngholder_t *)nextpq(&amp;gqslot-&gt;gqueue,&amp;holder-&gt;glink);
00548 }
00549 
00550 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> *getgq (xngqueue_t *gqslot)
00551 {
00552     xngholder_t *holder = getheadgq(gqslot);
00553     <span class="keywordflow">if</span> (!holder) <span class="keywordflow">return</span> NULL;
00554     appendq(gqslot-&gt;freehq,&amp;getpq(&amp;gqslot-&gt;gqueue)-&gt;plink);
00555     <span class="keywordflow">return</span> holder-&gt;data;
00556 }
00557 
00558 <span class="keyword">static</span> <span class="keyword">inline</span> xngholder_t *popgq (xngqueue_t *gqslot,
00559                                   xngholder_t *holder)
00560 {
00561     xngholder_t *nextholder = nextgq(gqslot,holder);
00562     removegh(gqslot,holder);
00563     <span class="keywordflow">return</span> nextholder;
00564 }
00565 
00566 <span class="keyword">static</span> <span class="keyword">inline</span> xngholder_t *findgq (xngqueue_t *gqslot,
00567                                    <span class="keywordtype">void</span> *data)
00568 {
00569     xnholder_t *holder;
00570 
00571     <span class="keywordflow">for</span> (holder = gqslot-&gt;gqueue.pqueue.head.next;
00572          holder != &amp;gqslot-&gt;gqueue.pqueue.head; holder = holder-&gt;next) {
00573          <span class="keywordflow">if</span> (((xngholder_t *)holder)-&gt;data == data)
00574              <span class="keywordflow">return</span> (xngholder_t *)holder;
00575         }
00576 
00577     <span class="keywordflow">return</span> NULL;
00578 }
00579 
00580 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> *removegq (xngqueue_t *gqslot,
00581                               <span class="keywordtype">void</span> *data)
00582 {
00583     xngholder_t *holder = findgq(gqslot,data);
00584     <span class="keywordflow">return</span> holder ? removegh(gqslot,holder) : NULL;
00585 }
00586 
00587 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> countgq (xngqueue_t *gqslot)
00588 {
00589     <span class="keywordflow">return</span> countpq(&amp;gqslot-&gt;gqueue);
00590 }
00591 
00592 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> emptygq_p (xngqueue_t *gqslot)
00593 {
00594     <span class="keywordflow">return</span> emptypq_p(&amp;gqslot-&gt;gqueue);
00595 }
00596 
00597 <span class="preprocessor">#ifdef CONFIG_XENO_OPT_SCALABLE_SCHED</span>
00598 <span class="preprocessor"></span>
00599 <span class="comment">/* Multi-level priority queue, suitable for handling the runnable</span>
00600 <span class="comment">   thread queue. */</span>
00601 
00602 <span class="preprocessor">#if BITS_PER_LONG * BITS_PER_LONG &lt; XNCORE_NR_PRIO</span>
00603 <span class="preprocessor"></span><span class="preprocessor">#error "Internal bitmap cannot hold so many priority levels"</span>
00604 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00605 <span class="preprocessor"></span>
00606 <span class="preprocessor">#define __MLQ_LONGS ((XNCORE_NR_PRIO+BITS_PER_LONG-1)/BITS_PER_LONG)</span>
00607 <span class="preprocessor"></span>
00608 <span class="keyword">typedef</span> <span class="keyword">struct </span>xnmlqueue {
00609 
00610     <span class="keywordtype">int</span> qdir, maxpri;
00611 
00612     <span class="keywordtype">int</span> elems;
00613 
00614     u_long himap,
00615            lomap[__MLQ_LONGS];
00616 
00617     <span class="keyword">struct </span>xnqueue queue[XNCORE_NR_PRIO];
00618 
00619 } xnmlqueue_t;
00620 
00621 <span class="preprocessor">#undef __MLQ_LONGS</span>
00622 <span class="preprocessor"></span>
00623 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> countmlq(xnmlqueue_t *mlqslot)
00624 {
00625     <span class="keywordflow">return</span> mlqslot-&gt;elems;
00626 }
00627 
00628 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> emptymlq_p(xnmlqueue_t *mlqslot)
00629 {
00630     <span class="keywordflow">return</span> mlqslot-&gt;himap == 0;
00631 }
00632 
00633 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> indexmlq(xnmlqueue_t *mlqslot, <span class="keywordtype">int</span> prio)
00634 {
00635     <span class="keywordflow">if</span> (mlqslot-&gt;qdir == xnqueue_up) <span class="comment">/* minprio &gt; maxprio */</span>
00636         <span class="keywordflow">return</span> prio - mlqslot-&gt;maxpri;
00637     <span class="keywordflow">else</span>
00638         <span class="keywordflow">return</span> mlqslot-&gt;maxpri - prio;
00639 }
00640 
00641 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> ffsmlq(xnmlqueue_t *mlqslot)
00642 {
00643     <span class="keywordtype">int</span> hi = ffnz(mlqslot-&gt;himap);
00644     <span class="keywordtype">int</span> lo = ffnz(mlqslot-&gt;lomap[hi]);
00645     <span class="keywordflow">return</span> hi * BITS_PER_LONG + lo; <span class="comment">/* Result is undefined if none set. */</span>
00646 }
00647 
00648 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> initmlq(xnmlqueue_t *mlqslot, <span class="keywordtype">int</span> qdir, <span class="keywordtype">int</span> maxpri)
00649 {
00650     <span class="keywordtype">int</span> prio;
00651 
00652     mlqslot-&gt;elems = 0;
00653     mlqslot-&gt;qdir  = qdir;
00654     mlqslot-&gt;maxpri = maxpri;
00655     mlqslot-&gt;himap = 0;
00656     memset(&amp;mlqslot-&gt;lomap,0,<span class="keyword">sizeof</span>(mlqslot-&gt;lomap));
00657     
00658     <span class="keywordflow">for</span> (prio = 0; prio &lt; XNCORE_NR_PRIO; prio++)
00659         initq(&amp;mlqslot-&gt;queue[prio]);
00660 }
00661 
00662 <span class="preprocessor">#define XNMLQUEUE_APPEND   0</span>
00663 <span class="preprocessor"></span><span class="preprocessor">#define XNMLQUEUE_PREPEND  1</span>
00664 <span class="preprocessor"></span>
00665 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> addmlq(xnmlqueue_t *mlqslot,
00666                           xnpholder_t  *holder,
00667                           <span class="keywordtype">int</span> idx,
00668                           <span class="keywordtype">int</span> mode)
00669 {
00670     xnqueue_t *queue = &amp;mlqslot-&gt;queue[idx];
00671     <span class="keywordtype">int</span> hi = idx / BITS_PER_LONG;
00672     <span class="keywordtype">int</span> lo = idx % BITS_PER_LONG;
00673 
00674     <span class="keywordflow">if</span> (mode == XNMLQUEUE_PREPEND) <span class="comment">/* Hopefully, this should be optimized away. */</span>
00675         prependq(queue, &amp;holder-&gt;plink);
00676     <span class="keywordflow">else</span>
00677         appendq(queue, &amp;holder-&gt;plink);
00678 
00679     mlqslot-&gt;elems++;
00680     __setbits(mlqslot-&gt;himap,1 &lt;&lt; hi);
00681     __setbits(mlqslot-&gt;lomap[hi],1 &lt;&lt; lo);
00682 }
00683 
00684 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> insertmlql(xnmlqueue_t *mlqslot,
00685                               xnpholder_t *holder,
00686                               <span class="keywordtype">int</span> prio)
00687 {
00688     addmlq(mlqslot, holder, indexmlq(mlqslot,prio), XNMLQUEUE_PREPEND);
00689     holder-&gt;prio = prio;
00690 }
00691 
00692 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> insertmlqf(xnmlqueue_t *mlqslot,
00693                               xnpholder_t *holder,
00694                               <span class="keywordtype">int</span> prio)
00695 {
00696     addmlq(mlqslot, holder, indexmlq(mlqslot,prio), XNMLQUEUE_APPEND);
00697     holder-&gt;prio = prio;
00698 }
00699 
00700 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> appendmlq(xnmlqueue_t *mlqslot,
00701                              xnpholder_t *holder)
00702 {
00703     addmlq(mlqslot, holder, mlqslot-&gt;maxpri, XNMLQUEUE_APPEND);
00704     holder-&gt;prio = mlqslot-&gt;maxpri;
00705 }
00706 
00707 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> prependmlq(xnmlqueue_t *mlqslot,
00708                               xnpholder_t *holder)
00709 {
00710     addmlq(mlqslot, holder, 0, XNMLQUEUE_PREPEND);
00711     holder-&gt;prio = 0;
00712 }
00713 
00714 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> removemlq(xnmlqueue_t *mlqslot,
00715                              xnpholder_t *holder)
00716 {
00717     <span class="keywordtype">int</span> idx = indexmlq(mlqslot,holder-&gt;prio);
00718     xnqueue_t *queue = &amp;mlqslot-&gt;queue[idx];
00719 
00720     mlqslot-&gt;elems--;
00721     
00722     removeq(queue, &amp;holder-&gt;plink);
00723     
00724     <span class="keywordflow">if</span> (emptyq_p(queue)) {
00725         <span class="keywordtype">int</span> hi = idx / BITS_PER_LONG;
00726         <span class="keywordtype">int</span> lo = idx % BITS_PER_LONG;
00727         __clrbits(mlqslot-&gt;lomap[hi],1 &lt;&lt; lo);
00728         <span class="keywordflow">if</span> (mlqslot-&gt;lomap[hi] == 0)
00729             __clrbits(mlqslot-&gt;himap,1 &lt;&lt; hi);
00730     }
00731 }
00732 
00733 <span class="keyword">static</span> <span class="keyword">inline</span> xnpholder_t *findmlqh(xnmlqueue_t *mlqslot,
00734                                     <span class="keywordtype">int</span> prio)
00735 {
00736     xnqueue_t *queue = &amp;mlqslot-&gt;queue[indexmlq(mlqslot,prio)];
00737     <span class="keywordflow">return</span> (xnpholder_t *)getheadq(queue);
00738 }
00739 
00740 <span class="keyword">static</span> <span class="keyword">inline</span> xnpholder_t *getheadmlq(xnmlqueue_t *mlqslot)
00741 {
00742     xnqueue_t *queue;
00743 
00744     <span class="keywordflow">if</span> (emptymlq_p(mlqslot))
00745         <span class="keywordflow">return</span> NULL;
00746 
00747     queue = &amp;mlqslot-&gt;queue[ffsmlq(mlqslot)];
00748     
00749     <span class="keywordflow">return</span> (xnpholder_t *)getheadq(queue);
00750 }
00751 
00752 <span class="keyword">static</span> <span class="keyword">inline</span> xnpholder_t *getmlq(xnmlqueue_t *mlqslot)
00753 {
00754     xnholder_t *holder;
00755     xnqueue_t *queue;
00756     <span class="keywordtype">int</span> idx, hi, lo;
00757 
00758     <span class="keywordflow">if</span> (emptymlq_p(mlqslot))
00759         <span class="keywordflow">return</span> NULL;
00760 
00761     idx = ffsmlq(mlqslot);
00762     queue = &amp;mlqslot-&gt;queue[idx];
00763     holder = getq(queue);
00764 
00765 <span class="preprocessor">#ifdef CONFIG_XENO_OPT_DEBUG_QUEUES</span>
00766 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (!holder)
00767         xnpod_fatal(<span class="stringliteral">"corrupted multi-level queue, qslot=%p at %s:%d"</span>,
00768                     mlqslot,
00769                     __FILE__,__LINE__);
00770 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_XENO_OPT_DEBUG_QUEUES */</span>
00771         
00772     hi = idx / BITS_PER_LONG;
00773     lo = idx % BITS_PER_LONG;
00774 
00775     mlqslot-&gt;elems--;    
00776 
00777     <span class="keywordflow">if</span> (emptyq_p(queue)) {
00778         __clrbits(mlqslot-&gt;lomap[hi],1 &lt;&lt; lo);
00779         <span class="keywordflow">if</span> (mlqslot-&gt;lomap[hi] == 0)
00780             __clrbits(mlqslot-&gt;himap,1 &lt;&lt; hi);
00781     }
00782     
00783     <span class="keywordflow">return</span> (xnpholder_t *)holder;
00784 }
00785 
00786 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_XENO_OPT_SCALABLE_SCHED */</span>
00787 
00788 <span class="preprocessor">#endif </span><span class="comment">/* !_XENO_NUCLEUS_QUEUE_H */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Aug 16 16:25:50 2006 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
