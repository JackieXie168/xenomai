<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Xenomai API: Counting semaphore services.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Xenomai API"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Xenomai API
   &#160;<span id="projectnumber">2.6.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__semaphore.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Counting semaphore services.</div>  </div>
<div class="ingroups"><a class="el" href="group__native.html">Native Xenomai API.</a></div></div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Counting semaphore services.:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__semaphore.png" border="0" alt="" usemap="#group____semaphore"/>
<map name="group____semaphore" id="group____semaphore">
<area shape="rect" id="node1" href="group__native.html" title="Native Xenomai API." alt="" coords="7,13,151,43"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:ksrc_2skins_2native_2sem_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ksrc_2skins_2native_2sem_8c.html">sem.c</a></td></tr>
<tr class="memdesc:ksrc_2skins_2native_2sem_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file is part of the Xenomai project. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaba36e3ac8972ea74feb60640e58d1ceb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__semaphore.html#gaba36e3ac8972ea74feb60640e58d1ceb">rt_sem_create</a> (RT_SEM *sem, const char *name, unsigned long icount, int mode)</td></tr>
<tr class="memdesc:gaba36e3ac8972ea74feb60640e58d1ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a counting semaphore.  <a href="#gaba36e3ac8972ea74feb60640e58d1ceb"></a><br/></td></tr>
<tr class="memitem:gaa14cefc4dae46a7c95859e7fe46df888"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__semaphore.html#gaa14cefc4dae46a7c95859e7fe46df888">rt_sem_delete</a> (RT_SEM *sem)</td></tr>
<tr class="memdesc:gaa14cefc4dae46a7c95859e7fe46df888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a semaphore.  <a href="#gaa14cefc4dae46a7c95859e7fe46df888"></a><br/></td></tr>
<tr class="memitem:gadd299dfe4a53194870bf4e158ca89d1f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__semaphore.html#gadd299dfe4a53194870bf4e158ca89d1f">rt_sem_p</a> (RT_SEM *sem, RTIME timeout)</td></tr>
<tr class="memdesc:gadd299dfe4a53194870bf4e158ca89d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pend on a semaphore.  <a href="#gadd299dfe4a53194870bf4e158ca89d1f"></a><br/></td></tr>
<tr class="memitem:gac481c1f1a2184a998deb2110f2c5b04d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__semaphore.html#gac481c1f1a2184a998deb2110f2c5b04d">rt_sem_p_until</a> (RT_SEM *sem, RTIME timeout)</td></tr>
<tr class="memdesc:gac481c1f1a2184a998deb2110f2c5b04d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pend on a semaphore (with absolute timeout date).  <a href="#gac481c1f1a2184a998deb2110f2c5b04d"></a><br/></td></tr>
<tr class="memitem:gaa5a7927862a511a27741223e08e48270"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__semaphore.html#gaa5a7927862a511a27741223e08e48270">rt_sem_v</a> (RT_SEM *sem)</td></tr>
<tr class="memdesc:gaa5a7927862a511a27741223e08e48270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal a semaphore.  <a href="#gaa5a7927862a511a27741223e08e48270"></a><br/></td></tr>
<tr class="memitem:ga4a8963240e68d164a2e5bb148da44fbc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__semaphore.html#ga4a8963240e68d164a2e5bb148da44fbc">rt_sem_broadcast</a> (RT_SEM *sem)</td></tr>
<tr class="memdesc:ga4a8963240e68d164a2e5bb148da44fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast a semaphore.  <a href="#ga4a8963240e68d164a2e5bb148da44fbc"></a><br/></td></tr>
<tr class="memitem:ga48235bfa78df58a71d7a38582898cb07"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__semaphore.html#ga48235bfa78df58a71d7a38582898cb07">rt_sem_inquire</a> (RT_SEM *sem, RT_SEM_INFO *info)</td></tr>
<tr class="memdesc:ga48235bfa78df58a71d7a38582898cb07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inquire about a semaphore.  <a href="#ga48235bfa78df58a71d7a38582898cb07"></a><br/></td></tr>
<tr class="memitem:ga1520b55854f94b99852d24d1cbd0b29d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__semaphore.html#ga1520b55854f94b99852d24d1cbd0b29d">rt_sem_bind</a> (RT_SEM *sem, const char *name, RTIME timeout)</td></tr>
<tr class="memdesc:ga1520b55854f94b99852d24d1cbd0b29d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind to a semaphore.  <a href="#ga1520b55854f94b99852d24d1cbd0b29d"></a><br/></td></tr>
<tr class="memitem:ga851cc0b485d43b52f580f75c72afe2a3"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__semaphore.html#ga851cc0b485d43b52f580f75c72afe2a3">rt_sem_unbind</a> (RT_SEM *sem)</td></tr>
<tr class="memdesc:ga851cc0b485d43b52f580f75c72afe2a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unbind from a semaphore.  <a href="#ga851cc0b485d43b52f580f75c72afe2a3"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<p>A counting semaphore is a synchronization object granting Xenomai tasks a concurrent access to a given number of resources maintained in an internal counter variable. The semaphore is used through the P ("Proberen", from the Dutch "test and decrement") and V ("Verhogen", increment) operations. The P operation waits for a unit to become available from the count, and the V operation releases a resource by incrementing the unit count by one.</p>
<p>If no more than a single resource is made available at any point in time, the semaphore enforces mutual exclusion and thus can be used to serialize access to a critical section. However, mutexes should be used instead in order to prevent priority inversions. </p>
<h2>Function Documentation</h2>
<a class="anchor" id="ga1520b55854f94b99852d24d1cbd0b29d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_sem_bind </td>
          <td>(</td>
          <td class="paramtype">RT_SEM *&#160;</td>
          <td class="paramname"><em>sem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind to a semaphore. </p>
<p>This user-space only service retrieves the uniform descriptor of a given Xenomai semaphore identified by its symbolic name. If the semaphore does not exist on entry, this service blocks the caller until a semaphore of the given name is created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A valid NULL-terminated name which identifies the semaphore to bind to.</td></tr>
    <tr><td class="paramname">sem</td><td>The address of a semaphore descriptor retrieved by the operation. Contents of this memory is undefined upon failure.</td></tr>
    <tr><td class="paramname">timeout</td><td>The number of clock ticks to wait for the registration to occur (see note). Passing TM_INFINITE causes the caller to block indefinitely until the object is registered. Passing TM_NONBLOCK causes the service to return immediately without waiting if the object is not registered on entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EFAULT is returned if <em>sem</em> or <em>name</em> is referencing invalid memory.</li>
</ul>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task.">rt_task_unblock()</a> has been called for the waiting task before the retrieval has completed.</li>
</ul>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to TM_NONBLOCK and the searched object is not registered on entry.</li>
</ul>
<ul>
<li>-ETIMEDOUT is returned if the object cannot be retrieved within the specified amount of time.</li>
</ul>
<ul>
<li>-EPERM is returned if this service should block, but was called from a context which cannot sleep (e.g. interrupt, non-realtime context).</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>User-space task (switches to primary mode)</li>
</ul>
<p>Rescheduling: always unless the request is immediately satisfied or <em>timeout</em> specifies a non-blocking operation.</p>
<dl class="section note"><dt>Note</dt><dd>The <em>timeout</em> value will be interpreted as jiffies if the native skin is bound to a periodic time base (see CONFIG_XENO_OPT_NATIVE_PERIOD), or nanoseconds otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4a8963240e68d164a2e5bb148da44fbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_sem_broadcast </td>
          <td>(</td>
          <td class="paramtype">RT_SEM *&#160;</td>
          <td class="paramname"><em>sem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcast a semaphore. </p>
<p>Unblock all tasks waiting on a semaphore. Awaken tasks return from <a class="el" href="group__semaphore.html#gadd299dfe4a53194870bf4e158ca89d1f" title="Pend on a semaphore.">rt_sem_p()</a> as if the semaphore has been signaled. The semaphore count is zeroed as a result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>The descriptor address of the affected semaphore.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>sem</em> is not a semaphore descriptor.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>sem</em> is a deleted semaphore descriptor.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: possible. </p>

<p>References <a class="el" href="group__pod.html#gacf5b53f0405351327b89b0cc4976b962">xnpod_schedule()</a>, and <a class="el" href="group__synch.html#ga82beb68147bc5f0306ab02a61a9dc76b">xnsynch_flush()</a>.</p>

</div>
</div>
<a class="anchor" id="gaba36e3ac8972ea74feb60640e58d1ceb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_sem_create </td>
          <td>(</td>
          <td class="paramtype">RT_SEM *&#160;</td>
          <td class="paramname"><em>sem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>icount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a counting semaphore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>The address of a semaphore descriptor Xenomai will use to store the semaphore-related data. This descriptor must always be valid while the semaphore is active therefore it must be allocated in permanent memory.</td></tr>
    <tr><td class="paramname">name</td><td>An ASCII string standing for the symbolic name of the semaphore. When non-NULL and non-empty, this string is copied to a safe place into the descriptor, and passed to the registry package if enabled for indexing the created semaphore.</td></tr>
    <tr><td class="paramname">icount</td><td>The initial value of the semaphore count.</td></tr>
    <tr><td class="paramname">mode</td><td>The semaphore creation mode. The following flags can be OR'ed into this bitmask, each of them affecting the new semaphore:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>S_FIFO makes tasks pend in FIFO order on the semaphore.</li>
</ul>
<ul>
<li>S_PRIO makes tasks pend in priority order on the semaphore.</li>
</ul>
<ul>
<li>S_PULSE causes the semaphore to behave in "pulse" mode. In this mode, the V (signal) operation attempts to release a single waiter each time it is called, but without incrementing the semaphore count if no waiter is pending. For this reason, the semaphore count in pulse mode remains zero.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-ENOMEM is returned if the system fails to get enough dynamic memory from the global real-time heap in order to register the semaphore.</li>
</ul>
<ul>
<li>-EEXIST is returned if the <em>name</em> is already in use by some registered object.</li>
</ul>
<ul>
<li>-EINVAL is returned if the <em>icount</em> is non-zero and <em>mode</em> specifies a pulse semaphore.</li>
</ul>
<ul>
<li>-EPERM is returned if this service was called from an asynchronous context.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: possible. </p>

<p>References <a class="el" href="group__semaphore.html#gaa14cefc4dae46a7c95859e7fe46df888">rt_sem_delete()</a>, <a class="el" href="group__registry.html#ga28aefd9be7367aa495753142005e1d5a">xnregistry_enter()</a>, and <a class="el" href="group__synch.html#ga4c07b8ec87b14cf18ef512f0e0aade51">xnsynch_init()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa14cefc4dae46a7c95859e7fe46df888"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_sem_delete </td>
          <td>(</td>
          <td class="paramtype">RT_SEM *&#160;</td>
          <td class="paramname"><em>sem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a semaphore. </p>
<p>Destroy a semaphore and release all the tasks currently pending on it. A semaphore exists in the system since <a class="el" href="group__semaphore.html#gaba36e3ac8972ea74feb60640e58d1ceb" title="Create a counting semaphore.">rt_sem_create()</a> has been called to create it, so this service must be called in order to destroy it afterwards.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>The descriptor address of the affected semaphore.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>sem</em> is not a semaphore descriptor.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>sem</em> is a deleted semaphore descriptor.</li>
</ul>
<ul>
<li>-EPERM is returned if this service was called from an asynchronous context.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: possible. </p>

<p>References <a class="el" href="group__pod.html#gacf5b53f0405351327b89b0cc4976b962">xnpod_schedule()</a>, and <a class="el" href="group__registry.html#ga477bb20ccb4bcf87c343aca8e58f9ef9">xnregistry_remove()</a>.</p>

<p>Referenced by <a class="el" href="group__semaphore.html#gaba36e3ac8972ea74feb60640e58d1ceb">rt_sem_create()</a>.</p>

</div>
</div>
<a class="anchor" id="ga48235bfa78df58a71d7a38582898cb07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_sem_inquire </td>
          <td>(</td>
          <td class="paramtype">RT_SEM *&#160;</td>
          <td class="paramname"><em>sem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RT_SEM_INFO *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inquire about a semaphore. </p>
<p>Return various information about the status of a given semaphore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>The descriptor address of the inquired semaphore.</td></tr>
    <tr><td class="paramname">info</td><td>The address of a structure the semaphore information will be written to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned and status information is written to the structure pointed at by <em>info</em> upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>sem</em> is not a semaphore descriptor.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>sem</em> is a deleted semaphore descriptor.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="gadd299dfe4a53194870bf4e158ca89d1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_sem_p </td>
          <td>(</td>
          <td class="paramtype">RT_SEM *&#160;</td>
          <td class="paramname"><em>sem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pend on a semaphore. </p>
<p>Acquire a semaphore unit. If the semaphore value is greater than zero, it is decremented by one and the service immediately returns to the caller. Otherwise, the caller is blocked until the semaphore is either signaled or destroyed, unless a non-blocking operation has been required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>The descriptor address of the affected semaphore.</td></tr>
    <tr><td class="paramname">timeout</td><td>The number of clock ticks to wait for a semaphore unit to be available (see note). Passing TM_INFINITE causes the caller to block indefinitely until a unit is available. Passing TM_NONBLOCK causes the service to return immediately without waiting if no unit is available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>sem</em> is not a semaphore descriptor.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>sem</em> is a deleted semaphore descriptor, including if the deletion occurred while the caller was sleeping on it for a unit to become available.</li>
</ul>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to TM_NONBLOCK and the semaphore value is zero.</li>
</ul>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task.">rt_task_unblock()</a> has been called for the waiting task before a semaphore unit has become available.</li>
</ul>
<ul>
<li>-ETIMEDOUT is returned if no unit is available within the specified amount of time.</li>
</ul>
<ul>
<li>-EPERM is returned if this service should block, but was called from a context which cannot sleep (e.g. interrupt, non-realtime context).</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine only if <em>timeout</em> is equal to TM_NONBLOCK.</li>
</ul>
<ul>
<li>Kernel-based task</li>
<li>User-space task (switches to primary mode)</li>
</ul>
<p>Rescheduling: always unless the request is immediately satisfied or <em>timeout</em> specifies a non-blocking operation.</p>
<dl class="section note"><dt>Note</dt><dd>The <em>timeout</em> value will be interpreted as jiffies if the native skin is bound to a periodic time base (see CONFIG_XENO_OPT_NATIVE_PERIOD), or nanoseconds otherwise. </dd></dl>

<p>References <a class="el" href="group__posix__cancel.html#ga636480bad96654729ecf18017c2820cd">pthread_setcanceltype()</a>.</p>

</div>
</div>
<a class="anchor" id="gac481c1f1a2184a998deb2110f2c5b04d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_sem_p_until </td>
          <td>(</td>
          <td class="paramtype">RT_SEM *&#160;</td>
          <td class="paramname"><em>sem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pend on a semaphore (with absolute timeout date). </p>
<p>Acquire a semaphore unit. If the semaphore value is greater than zero, it is decremented by one and the service immediately returns to the caller. Otherwise, the caller is blocked until the semaphore is either signaled or destroyed, unless a non-blocking operation has been required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>The descriptor address of the affected semaphore.</td></tr>
    <tr><td class="paramname">timeout</td><td>The absolute date specifying a time limit to wait for a semaphore unit to be available (see note). Passing TM_INFINITE causes the caller to block indefinitely until a unit is available. Passing TM_NONBLOCK causes the service to return immediately without waiting if no unit is available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>sem</em> is not a semaphore descriptor.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>sem</em> is a deleted semaphore descriptor, including if the deletion occurred while the caller was sleeping on it for a unit to become available.</li>
</ul>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to TM_NONBLOCK and the semaphore value is zero.</li>
</ul>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task.">rt_task_unblock()</a> has been called for the waiting task before a semaphore unit has become available.</li>
</ul>
<ul>
<li>-ETIMEDOUT is returned if the absolute <em>timeout</em> date is reached before a semaphore unit is available.</li>
</ul>
<ul>
<li>-EPERM is returned if this service should block, but was called from a context which cannot sleep (e.g. interrupt, non-realtime context).</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine only if <em>timeout</em> is equal to TM_NONBLOCK.</li>
</ul>
<ul>
<li>Kernel-based task</li>
<li>User-space task (switches to primary mode)</li>
</ul>
<p>Rescheduling: always unless the request is immediately satisfied or <em>timeout</em> specifies a non-blocking operation.</p>
<dl class="section note"><dt>Note</dt><dd>The <em>timeout</em> value will be interpreted as jiffies if the native skin is bound to a periodic time base (see CONFIG_XENO_OPT_NATIVE_PERIOD), or nanoseconds otherwise. </dd></dl>

<p>References <a class="el" href="group__posix__cancel.html#ga636480bad96654729ecf18017c2820cd">pthread_setcanceltype()</a>.</p>

</div>
</div>
<a class="anchor" id="ga851cc0b485d43b52f580f75c72afe2a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int rt_sem_unbind </td>
          <td>(</td>
          <td class="paramtype">RT_SEM *&#160;</td>
          <td class="paramname"><em>sem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unbind from a semaphore. </p>
<p>This user-space only service unbinds the calling task from the semaphore object previously retrieved by a call to <a class="el" href="group__semaphore.html#ga1520b55854f94b99852d24d1cbd0b29d" title="Bind to a semaphore.">rt_sem_bind()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>The address of a semaphore descriptor to unbind from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is always returned.</dd></dl>
<p>This service can be called from:</p>
<ul>
<li>User-space task.</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="gaa5a7927862a511a27741223e08e48270"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_sem_v </td>
          <td>(</td>
          <td class="paramtype">RT_SEM *&#160;</td>
          <td class="paramname"><em>sem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal a semaphore. </p>
<p>Release a semaphore unit. If the semaphore is pended, the first waiting task (by queuing order) is immediately unblocked; otherwise, the semaphore value is incremented by one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>The descriptor address of the affected semaphore.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>sem</em> is not a semaphore descriptor.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>sem</em> is a deleted semaphore descriptor.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: possible. </p>

<p>References <a class="el" href="group__pod.html#gacf5b53f0405351327b89b0cc4976b962">xnpod_schedule()</a>, and <a class="el" href="group__synch.html#gad5992ddbdb81821cb29bae8900eb65ac">xnsynch_wakeup_one_sleeper()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Oct 4 2013 22:39:09 for Xenomai API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.2 </li>
  </ul>
</div>
</body>
</html>
