<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Xenomai API: Interrupt management.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1>Interrupt management.<br>
<small>
[<a class="el" href="group__nucleus.html">Xenomai nucleus.</a>]</small>
</h1>
<p>
Collaboration diagram for Interrupt management.:<center><table><tr><td><img src="group__intr.png" border="0" alt="" usemap="#group____intr_map">
<map name="group____intr_map">
<area href="group__nucleus.html" shape="rect" coords="5,5,147,32" alt="">
</map></td></tr></table></center>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Interrupt management. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ksrc_2nucleus_2intr_8c.html">intr.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interrupt management. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr.html#ga673686991a428c60b87c4bf429a3c7c">xnintr_init</a> (xnintr_t *intr, const char *name, unsigned irq, xnisr_t isr, xniack_t iack, xnflags_t flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize an interrupt object.  <a href="#ga673686991a428c60b87c4bf429a3c7c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr.html#g4a694d0c7f1c44fcb13f712844573ae2">xnintr_destroy</a> (xnintr_t *intr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy an interrupt object.  <a href="#g4a694d0c7f1c44fcb13f712844573ae2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr.html#gb1dbb1b6c8a55e58766db9391d1e74cc">xnintr_attach</a> (xnintr_t *intr, void *cookie)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attach an interrupt object.  <a href="#gb1dbb1b6c8a55e58766db9391d1e74cc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr.html#g03f5fa185b92179226f4833e3c63c7d7">xnintr_detach</a> (xnintr_t *intr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detach an interrupt object.  <a href="#g03f5fa185b92179226f4833e3c63c7d7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr.html#g75afffe32c35a0faa8d5ece37cdbec0b">xnintr_enable</a> (xnintr_t *intr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable an interrupt object.  <a href="#g75afffe32c35a0faa8d5ece37cdbec0b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr.html#g446b439e7b470cc077d477693f9af0e2">xnintr_disable</a> (xnintr_t *intr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable an interrupt object.  <a href="#g446b439e7b470cc077d477693f9af0e2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">xnarch_cpumask_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr.html#ga17541d81fe492b11061ee6e161d9978">xnintr_affinity</a> (xnintr_t *intr, xnarch_cpumask_t cpumask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set interrupt's processor affinity.  <a href="#ga17541d81fe492b11061ee6e161d9978"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga17541d81fe492b11061ee6e161d9978"></a><!-- doxytag: member="intr.c::xnintr_affinity" ref="ga17541d81fe492b11061ee6e161d9978" args="(xnintr_t *intr, xnarch_cpumask_t cpumask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xnarch_cpumask_t xnintr_affinity           </td>
          <td>(</td>
          <td class="paramtype">xnintr_t *&nbsp;</td>
          <td class="paramname"> <em>intr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnarch_cpumask_t&nbsp;</td>
          <td class="paramname"> <em>cpumask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set interrupt's processor affinity. 
<p>
Causes the IRQ associated with the interrupt object <em>intr</em> to be received only on processors which bits are set in <em>cpumask</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>intr</em>&nbsp;</td><td>The descriptor address of the interrupt object which affinity is to be changed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cpumask</em>&nbsp;</td><td>The new processor affinity of the interrupt object.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the previous cpumask on success, or an empty mask on failure.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Depending on architectures, setting more than one bit in <em>cpumask</em> could be meaningless. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb1dbb1b6c8a55e58766db9391d1e74cc"></a><!-- doxytag: member="intr.c::xnintr_attach" ref="gb1dbb1b6c8a55e58766db9391d1e74cc" args="(xnintr_t *intr, void *cookie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnintr_attach           </td>
          <td>(</td>
          <td class="paramtype">xnintr_t *&nbsp;</td>
          <td class="paramname"> <em>intr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cookie</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attach an interrupt object. 
<p>
Attach an interrupt object previously initialized by <a class="el" href="group__intr.html#ga673686991a428c60b87c4bf429a3c7c">xnintr_init()</a>. After this operation is completed, all IRQs received from the corresponding interrupt channel are directed to the object's ISR.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>intr</em>&nbsp;</td><td>The descriptor address of the interrupt object to attach.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cookie</em>&nbsp;</td><td>A user-defined opaque value which is stored into the interrupt object descriptor for further retrieval by the ISR/ISR handlers.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned on success. Otherwise, -EINVAL is returned if a low-level error occurred while attaching the interrupt. -EBUSY is specifically returned if the interrupt object was already attached.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The caller <b>must not</b> hold nklock when invoking this service, this would cause deadlocks.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Attaching an interrupt resets the tracked number of receipts to zero. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g4a694d0c7f1c44fcb13f712844573ae2"></a><!-- doxytag: member="intr.c::xnintr_destroy" ref="g4a694d0c7f1c44fcb13f712844573ae2" args="(xnintr_t *intr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnintr_destroy           </td>
          <td>(</td>
          <td class="paramtype">xnintr_t *&nbsp;</td>
          <td class="paramname"> <em>intr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroy an interrupt object. 
<p>
Destroys an interrupt object previously initialized by <a class="el" href="group__intr.html#ga673686991a428c60b87c4bf429a3c7c">xnintr_init()</a>. The interrupt object is automatically detached by a call to <a class="el" href="group__intr.html#g03f5fa185b92179226f4833e3c63c7d7">xnintr_detach()</a>. No more IRQs will be dispatched by this object after this service has returned.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>intr</em>&nbsp;</td><td>The descriptor address of the interrupt object to destroy.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned on success. Otherwise, -EBUSY is returned if an error occurred while detaching the interrupt (see <a class="el" href="group__intr.html#g03f5fa185b92179226f4833e3c63c7d7">xnintr_detach()</a>).</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="g03f5fa185b92179226f4833e3c63c7d7"></a><!-- doxytag: member="intr.c::xnintr_detach" ref="g03f5fa185b92179226f4833e3c63c7d7" args="(xnintr_t *intr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnintr_detach           </td>
          <td>(</td>
          <td class="paramtype">xnintr_t *&nbsp;</td>
          <td class="paramname"> <em>intr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Detach an interrupt object. 
<p>
Detach an interrupt object previously attached by <a class="el" href="group__intr.html#gb1dbb1b6c8a55e58766db9391d1e74cc">xnintr_attach()</a>. After this operation is completed, no more IRQs are directed to the object's ISR, but the interrupt object itself remains valid. A detached interrupt object can be attached again by a subsequent call to <a class="el" href="group__intr.html#gb1dbb1b6c8a55e58766db9391d1e74cc">xnintr_attach()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>intr</em>&nbsp;</td><td>The descriptor address of the interrupt object to detach.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned on success. Otherwise, -EINVAL is returned if a low-level error occurred while detaching the interrupt. Detaching a non-attached interrupt object leads to a null-effect and returns 0.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The caller <b>must not</b> hold nklock when invoking this service, this would cause deadlocks.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="g446b439e7b470cc077d477693f9af0e2"></a><!-- doxytag: member="intr.c::xnintr_disable" ref="g446b439e7b470cc077d477693f9af0e2" args="(xnintr_t *intr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnintr_disable           </td>
          <td>(</td>
          <td class="paramtype">xnintr_t *&nbsp;</td>
          <td class="paramname"> <em>intr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Disable an interrupt object. 
<p>
Disables the hardware interrupt line associated with an interrupt object. This operation invalidates further interrupt requests from the given source until the IRQ line is re-enabled anew.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>intr</em>&nbsp;</td><td>The descriptor address of the interrupt object to disable.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned on success. Otherwise, -EINVAL is returned if a low-level error occurred while disabling the interrupt.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="g75afffe32c35a0faa8d5ece37cdbec0b"></a><!-- doxytag: member="intr.c::xnintr_enable" ref="g75afffe32c35a0faa8d5ece37cdbec0b" args="(xnintr_t *intr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnintr_enable           </td>
          <td>(</td>
          <td class="paramtype">xnintr_t *&nbsp;</td>
          <td class="paramname"> <em>intr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable an interrupt object. 
<p>
Enables the hardware interrupt line associated with an interrupt object. Over real-time control layers which mask and acknowledge IRQs, this operation is necessary to revalidate the interrupt channel so that more interrupts can be notified.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>intr</em>&nbsp;</td><td>The descriptor address of the interrupt object to enable.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned on success. Otherwise, -EINVAL is returned if a low-level error occurred while enabling the interrupt.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="ga673686991a428c60b87c4bf429a3c7c"></a><!-- doxytag: member="intr.c::xnintr_init" ref="ga673686991a428c60b87c4bf429a3c7c" args="(xnintr_t *intr, const char *name, unsigned irq, xnisr_t isr, xniack_t iack, xnflags_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnintr_init           </td>
          <td>(</td>
          <td class="paramtype">xnintr_t *&nbsp;</td>
          <td class="paramname"> <em>intr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>irq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnisr_t&nbsp;</td>
          <td class="paramname"> <em>isr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xniack_t&nbsp;</td>
          <td class="paramname"> <em>iack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnflags_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize an interrupt object. 
<p>
Associates an interrupt object with an IRQ line.<p>
When an interrupt occurs on the given <em>irq</em> line, the ISR is fired in order to deal with the hardware event. The interrupt service code may call any non-suspensive service from the nucleus.<p>
Upon receipt of an IRQ, the ISR is immediately called on behalf of the interrupted stack context, the rescheduling procedure is locked, and the interrupt source is masked at hardware level. The status value returned by the ISR is then checked for the following values:<p>
<ul>
<li>XN_ISR_HANDLED indicates that the interrupt request has been fulfilled by the ISR.</li></ul>
<p>
<ul>
<li>XN_ISR_NONE indicates the opposite to XN_ISR_HANDLED. The ISR must always return this value when it determines that the interrupt request has not been issued by the dedicated hardware device.</li></ul>
<p>
In addition, one of the following bits may be set by the ISR :<p>
NOTE: use these bits with care and only when you do understand their effect on the system. The ISR is not encouraged to use these bits in case it shares the IRQ line with other ISRs in the real-time domain.<p>
<ul>
<li>XN_ISR_PROPAGATE tells the nucleus to require the real-time control layer to forward the IRQ. For instance, this would cause the Adeos control layer to propagate the interrupt down the interrupt pipeline to other Adeos domains, such as Linux. This is the regular way to share interrupts between the nucleus and the host system.</li></ul>
<p>
<ul>
<li>XN_ISR_NOENABLE causes the nucleus to ask the real-time control layer _not_ to re-enable the IRQ line (read the following section). xnarch_end_irq() must be called to re-enable the IRQ line later.</li></ul>
<p>
The nucleus re-enables the IRQ line by default. Over some real-time control layers which mask and acknowledge IRQs, this operation is necessary to revalidate the interrupt channel so that more interrupts can be notified.<p>
A count of interrupt receipts is tracked into the interrupt descriptor, and reset to zero each time the interrupt object is attached. Since this count could wrap around, it should be used as an indication of interrupt activity only.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>intr</em>&nbsp;</td><td>The address of a interrupt object descriptor the nucleus will use to store the object-specific data. This descriptor must always be valid while the object is active therefore it must be allocated in permanent memory.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>An ASCII string standing for the symbolic name of the interrupt object or NULL ("&lt;unknown&gt;" will be applied then).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>irq</em>&nbsp;</td><td>The hardware interrupt channel associated with the interrupt object. This value is architecture-dependent. An interrupt object must then be attached to the hardware interrupt vector using the <a class="el" href="group__intr.html#gb1dbb1b6c8a55e58766db9391d1e74cc">xnintr_attach()</a> service for the associated IRQs to be directed to this object.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>isr</em>&nbsp;</td><td>The address of a valid low-level interrupt service routine if this parameter is non-zero. This handler will be called each time the corresponding IRQ is delivered on behalf of an interrupt context. When called, the ISR is passed the descriptor address of the interrupt object.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iack</em>&nbsp;</td><td>The address of an optional interrupt acknowledge routine, aimed at replacing the default one. Only very specific situations actually require to override the default setting for this parameter, like having to acknowledge non-standard PIC hardware. <em>iack</em> should return a non-zero value to indicate that the interrupt has been properly acknowledged. If <em>iack</em> is NULL, the default routine will be used instead.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>A set of creation flags affecting the operation. The valid flags are:</td></tr>
  </table>
</dl>
<ul>
<li>XN_ISR_SHARED enables IRQ-sharing with other interrupt objects.</li></ul>
<p>
<ul>
<li>XN_ISR_EDGE is an additional flag need to be set together with XN_ISR_SHARED to enable IRQ-sharing of edge-triggered interrupts.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>No error condition being defined, 0 is always returned.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Sun Sep 16 18:34:37 2007 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
