<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Xenomai API: Subdevice management services</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Subdevice management services<br>
<small>
[<a class="el" href="group__driverfacilities.html">Driver API.</a>]</small>
</h1>
<p>
<div class="dynheader">
Collaboration diagram for Subdevice management services:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__subdevice.png" border="0" alt="" usemap="#group____subdevice_map">
<map name="group____subdevice_map">
<area shape="rect" href="group__driverfacilities.html" title="Driver API." alt="" coords="5,5,93,32"></map></td></tr></table></center>
</div>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Subdevice declaration in a driver<p>
The subdevice structure is the most complex one in the Analogy driver layer. It contains some description fields to fill and some callbacks to declare.<p>
The description fields are:<ul>
<li>flags: to define the subdevice type and its capabilities;</li><li>chan_desc: to describe the channels which compose the subdevice;</li><li>rng_desc: to declare the usable ranges;</li></ul>
<p>
The functions callbakcs are:<ul>
<li>do_cmd() and do_cmdtest(): to performe asynchronous acquisitions thanks to commands;</li><li>cancel(): to abort a working asynchronous acquisition;</li><li>munge(): to apply modifications on the data freshly acquired during an asynchronous transfer. Warning: using this feature with can significantly reduce the performances (if the munge operation is complex, it will trigger high CPU charge and if the acquisition device is DMA capable, many cache-misses and cache-replaces will occur (the benefits of the DMA controller will vanish);</li><li>trigger(): optionnaly to launch an asynchronous acquisition;</li><li>insn_read(), insn_write(), insn_bits(), insn_config(): to perform synchronous acquisition operations.</li></ul>
<p>
Once the subdevice is filled, it must be inserted into the driver structure thanks to <a class="el" href="group__subdevice.html#g229e7725db234534da6e6973c63f1cef" title="Add a subdevice to the driver descriptor.">a4l_add_subd()</a>. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structa4l__subdevice.html">a4l_subdevice</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure describing the subdevice.  <a href="structa4l__subdevice.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Subdevices types</h2></td></tr>
<tr><td colspan="2">Flags to define the subdevice type<p>
<a class="anchor" name="ANALOGY_SUBD_xxx"></a> <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g0c70964ed18393fdeb7f6b985d7ae4f1"></a><!-- doxytag: member="subdevice::A4L_SUBD_UNUSED" ref="g0c70964ed18393fdeb7f6b985d7ae4f1" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#g0c70964ed18393fdeb7f6b985d7ae4f1">A4L_SUBD_UNUSED</a>&nbsp;&nbsp;&nbsp;(A4L_SUBD_MASK_SPECIAL|0x1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unused subdevice. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gfe08fcb0bd2ac9015e058a1a38ebfade"></a><!-- doxytag: member="subdevice::A4L_SUBD_AI" ref="gfe08fcb0bd2ac9015e058a1a38ebfade" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#gfe08fcb0bd2ac9015e058a1a38ebfade">A4L_SUBD_AI</a>&nbsp;&nbsp;&nbsp;(A4L_SUBD_MASK_READ|0x2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Analog input subdevice. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g5285a5093bd9279588a4b8fd05bb7c3f"></a><!-- doxytag: member="subdevice::A4L_SUBD_AO" ref="g5285a5093bd9279588a4b8fd05bb7c3f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#g5285a5093bd9279588a4b8fd05bb7c3f">A4L_SUBD_AO</a>&nbsp;&nbsp;&nbsp;(A4L_SUBD_MASK_WRITE|0x4)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Analog output subdevice. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gd4b6ee48948dc35895606488de102e14"></a><!-- doxytag: member="subdevice::A4L_SUBD_DI" ref="gd4b6ee48948dc35895606488de102e14" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#gd4b6ee48948dc35895606488de102e14">A4L_SUBD_DI</a>&nbsp;&nbsp;&nbsp;(A4L_SUBD_MASK_READ|0x8)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Digital input subdevice. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gf86e53e7a480bfb73df538dfd230efa2"></a><!-- doxytag: member="subdevice::A4L_SUBD_DO" ref="gf86e53e7a480bfb73df538dfd230efa2" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#gf86e53e7a480bfb73df538dfd230efa2">A4L_SUBD_DO</a>&nbsp;&nbsp;&nbsp;(A4L_SUBD_MASK_WRITE|0x10)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Digital output subdevice. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g56fb70a0e2cf39e1be994d4b1e346162"></a><!-- doxytag: member="subdevice::A4L_SUBD_DIO" ref="g56fb70a0e2cf39e1be994d4b1e346162" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#g56fb70a0e2cf39e1be994d4b1e346162">A4L_SUBD_DIO</a>&nbsp;&nbsp;&nbsp;(A4L_SUBD_MASK_SPECIAL|0x20)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Digital input/output subdevice. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g9769a5004db6f3d45c1ac908fd1b9123"></a><!-- doxytag: member="subdevice::A4L_SUBD_COUNTER" ref="g9769a5004db6f3d45c1ac908fd1b9123" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#g9769a5004db6f3d45c1ac908fd1b9123">A4L_SUBD_COUNTER</a>&nbsp;&nbsp;&nbsp;(A4L_SUBD_MASK_SPECIAL|0x40)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Counter subdevice. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ge4e41940b17d812ba852ac8739165262"></a><!-- doxytag: member="subdevice::A4L_SUBD_TIMER" ref="ge4e41940b17d812ba852ac8739165262" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#ge4e41940b17d812ba852ac8739165262">A4L_SUBD_TIMER</a>&nbsp;&nbsp;&nbsp;(A4L_SUBD_MASK_SPECIAL|0x80)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Timer subdevice. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga38f1355eb6a7874ce5dcf8f90072d14"></a><!-- doxytag: member="subdevice::A4L_SUBD_MEMORY" ref="ga38f1355eb6a7874ce5dcf8f90072d14" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#ga38f1355eb6a7874ce5dcf8f90072d14">A4L_SUBD_MEMORY</a>&nbsp;&nbsp;&nbsp;(A4L_SUBD_MASK_SPECIAL|0x100)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Memory, EEPROM, DPRAM. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ge9eee756dede608de5263143191edec2"></a><!-- doxytag: member="subdevice::A4L_SUBD_CALIB" ref="ge9eee756dede608de5263143191edec2" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#ge9eee756dede608de5263143191edec2">A4L_SUBD_CALIB</a>&nbsp;&nbsp;&nbsp;(A4L_SUBD_MASK_SPECIAL|0x200)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calibration subdevice DACs. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gcf4d6837ce92a27aaf9b78d59fb6ba8e"></a><!-- doxytag: member="subdevice::A4L_SUBD_PROC" ref="gcf4d6837ce92a27aaf9b78d59fb6ba8e" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#gcf4d6837ce92a27aaf9b78d59fb6ba8e">A4L_SUBD_PROC</a>&nbsp;&nbsp;&nbsp;(A4L_SUBD_MASK_SPECIAL|0x400)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Processor, DSP. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g14c863f8e99d6be9a0d6371bcbe8fff1"></a><!-- doxytag: member="subdevice::A4L_SUBD_SERIAL" ref="g14c863f8e99d6be9a0d6371bcbe8fff1" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#g14c863f8e99d6be9a0d6371bcbe8fff1">A4L_SUBD_SERIAL</a>&nbsp;&nbsp;&nbsp;(A4L_SUBD_MASK_SPECIAL|0x800)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Serial IO subdevice. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gffcb131508d9920aa4436c7df18a8ab1"></a><!-- doxytag: member="subdevice::A4L_SUBD_TYPES" ref="gffcb131508d9920aa4436c7df18a8ab1" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#gffcb131508d9920aa4436c7df18a8ab1">A4L_SUBD_TYPES</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mask which gathers all the types. <br></td></tr>
<tr><td colspan="2"><br><h2>Subdevice features</h2></td></tr>
<tr><td colspan="2">Flags to define the subdevice's capabilities<p>
<a class="anchor" name="ANALOGY_SUBD_FT_xxx"></a> <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ge57f549ab2689782e35af2c8941aeecf"></a><!-- doxytag: member="subdevice::A4L_SUBD_CMD" ref="ge57f549ab2689782e35af2c8941aeecf" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#ge57f549ab2689782e35af2c8941aeecf">A4L_SUBD_CMD</a>&nbsp;&nbsp;&nbsp;0x1000</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The subdevice can handle command (i.e it can perform asynchronous acquisition). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g4ec26f0982c64fe7aab38678af7a20a4"></a><!-- doxytag: member="subdevice::A4L_SUBD_MMAP" ref="g4ec26f0982c64fe7aab38678af7a20a4" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#g4ec26f0982c64fe7aab38678af7a20a4">A4L_SUBD_MMAP</a>&nbsp;&nbsp;&nbsp;0x8000</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The subdevice support mmap operations (technically, any driver can do it; however, the developer might want that his driver must be accessed through read / write. <br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#g32595b3806dd3e73038a2022c0b1e204">a4l_alloc_subd</a> (int sizeof_priv, void(*setup)(<a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a subdevice descriptor.  <a href="#g32595b3806dd3e73038a2022c0b1e204"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#g229e7725db234534da6e6973c63f1cef">a4l_add_subd</a> (a4l_dev_t *dev, <a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *subd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a subdevice to the driver descriptor.  <a href="#g229e7725db234534da6e6973c63f1cef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subdevice.html#ga8b2dfadeac340e288725e1f2ce9b63b">a4l_get_subd</a> (a4l_dev_t *dev, int idx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a pointer to the subdevice descriptor referenced by its registration index.  <a href="#ga8b2dfadeac340e288725e1f2ce9b63b"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g229e7725db234534da6e6973c63f1cef"></a><!-- doxytag: member="driver_facilities.c::a4l_add_subd" ref="g229e7725db234534da6e6973c63f1cef" args="(a4l_dev_t *dev, a4l_subd_t *subd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int a4l_add_subd           </td>
          <td>(</td>
          <td class="paramtype">a4l_dev_t *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *&nbsp;</td>
          <td class="paramname"> <em>subd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a subdevice to the driver descriptor. 
<p>
Once the driver descriptor structure is initialized, the function <a class="el" href="group__subdevice.html#g229e7725db234534da6e6973c63f1cef" title="Add a subdevice to the driver descriptor.">a4l_add_subd()</a> must be used so to add some subdevices to the driver.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dev</em>&nbsp;</td><td>Device descriptor structure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>subd</em>&nbsp;</td><td>Subdevice descriptor structure</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the index with which the subdevice has been registered, in case of error a negative error code is returned. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g32595b3806dd3e73038a2022c0b1e204"></a><!-- doxytag: member="driver_facilities.c::a4l_alloc_subd" ref="g32595b3806dd3e73038a2022c0b1e204" args="(int sizeof_priv, void(*setup)(a4l_subd_t *))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a>* a4l_alloc_subd           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sizeof_priv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *)&nbsp;</td>
          <td class="paramname"> <em>setup</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate a subdevice descriptor. 
<p>
This is a helper function so as to get a suitable subdevice descriptor<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sizeof_priv</em>&nbsp;</td><td>Size of the subdevice's private data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>setup</em>&nbsp;</td><td>Setup function to be called after the allocation</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the index with which the subdevice has been registered, in case of error a negative error code is returned. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga8b2dfadeac340e288725e1f2ce9b63b"></a><!-- doxytag: member="driver_facilities.c::a4l_get_subd" ref="ga8b2dfadeac340e288725e1f2ce9b63b" args="(a4l_dev_t *dev, int idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a>* a4l_get_subd           </td>
          <td>(</td>
          <td class="paramtype">a4l_dev_t *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a pointer to the subdevice descriptor referenced by its registration index. 
<p>
This function is scarcely useful as all the drivers callbacks get the related subdevice descriptor as first argument. This function is not optimized, it goes through a linked list to get the proper pointer. So it must not be used in real-time context but at initialization / cleanup time (attach / detach).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dev</em>&nbsp;</td><td>Device descriptor structure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>idx</em>&nbsp;</td><td>Subdevice index</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise negative error code. </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed May 5 10:20:01 2010 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
