<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Xenomai API: Device Registration Services</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Device Registration Services<br>
<small>
[<a class="el" href="group__driverapi.html">Driver Development API</a>]</small>
</h1>
<p>
<div class="dynheader">
Collaboration diagram for Device Registration Services:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__devregister.png" border="0" alt="" usemap="#group____devregister_map">
<map name="group____devregister_map">
<area shape="rect" href="group__rtdmsync.html" title="Synchronisation Services" alt="" coords="477,5,659,32"><area shape="rect" href="group__driverapi.html" title="Driver Development API" alt="" coords="5,5,179,32"></map></td></tr></table></center>
</div>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Modules</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html">Synchronisation Services</a></td></tr>

<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrtdm__operations.html">rtdm_operations</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Device operations.  <a href="structrtdm__operations.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Device context.  <a href="structrtdm__dev__context.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrtdm__device.html">rtdm_device</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RTDM device.  <a href="structrtdm__device.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Operation Handler Prototypes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#gf987b1139579bdb16b4541ea76121fa6">rtdm_open_handler_t</a> )(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, int oflag)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Named device open handler.  <a href="#gf987b1139579bdb16b4541ea76121fa6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#g07b8dc34cfc42f6203c510d1e982edc5">rtdm_socket_handler_t</a> )(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, int protocol)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket creation handler for protocol devices.  <a href="#g07b8dc34cfc42f6203c510d1e982edc5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#g6bd6c0761590d59f67b2c1e87fdd8440">rtdm_close_handler_t</a> )(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close handler.  <a href="#g6bd6c0761590d59f67b2c1e87fdd8440"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#g3adab7928c65ee8ffd06c82c705d4804">rtdm_ioctl_handler_t</a> )(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, unsigned int request, void __user *arg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">IOCTL handler.  <a href="#g3adab7928c65ee8ffd06c82c705d4804"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#g462c61f19f6bc6a0ef93a57ab6b218bf">rtdm_select_bind_handler_t</a> )(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_selector_t *selector, enum <a class="el" href="group__rtdmsync.html#ge18228df8c70c9da1f90f61b01e92501">rtdm_selecttype</a> type, unsigned fd_index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Select binding handler.  <a href="#g462c61f19f6bc6a0ef93a57ab6b218bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef ssize_t(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#g1a2f92a5ebe9f4d46fb6722ed5da047c">rtdm_read_handler_t</a> )(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, void *buf, size_t nbyte)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read handler.  <a href="#g1a2f92a5ebe9f4d46fb6722ed5da047c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef ssize_t(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga2b3421e29ae63cf49622765a5bc9cee">rtdm_write_handler_t</a> )(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, const void *buf, size_t nbyte)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write handler.  <a href="#ga2b3421e29ae63cf49622765a5bc9cee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef ssize_t(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#g8e592853e1072c8b32e2263557990a66">rtdm_recvmsg_handler_t</a> )(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, struct msghdr *msg, int flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive message handler.  <a href="#g8e592853e1072c8b32e2263557990a66"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef ssize_t(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#g2f142d15145b97e837f5e26775a4b0f1">rtdm_sendmsg_handler_t</a> )(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, const struct msghdr *msg, int flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transmit message handler.  <a href="#g2f142d15145b97e837f5e26775a4b0f1"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Device Flags</h2></td></tr>
<tr><td colspan="2"><a class="anchor" name="dev_flags"></a> Static flags describing a RTDM device <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#g7c66ec8f269c701237437177af0704e8">RTDM_EXCLUSIVE</a>&nbsp;&nbsp;&nbsp;0x0001</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If set, only a single instance of the device can be requested by an application.  <a href="#g7c66ec8f269c701237437177af0704e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#g7651188ca1c05f7e68b36517874138b7">RTDM_NAMED_DEVICE</a>&nbsp;&nbsp;&nbsp;0x0010</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If set, the device is addressed via a clear-text name.  <a href="#g7651188ca1c05f7e68b36517874138b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#g43ced044106ae9c1f5500d0041307d8f">RTDM_PROTOCOL_DEVICE</a>&nbsp;&nbsp;&nbsp;0x0020</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If set, the device is addressed via a combination of protocol ID and socket type.  <a href="#g43ced044106ae9c1f5500d0041307d8f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#gfdb542eb46679916b0100969e1033bfc">RTDM_DEVICE_TYPE_MASK</a>&nbsp;&nbsp;&nbsp;0x00F0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mask selecting the device type.  <a href="#gfdb542eb46679916b0100969e1033bfc"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Context Flags</h2></td></tr>
<tr><td colspan="2"><a class="anchor" name="ctx_flags"></a> Dynamic flags describing the state of an open RTDM device (bit numbers) <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga6f17915089145982b04c51f202d950c">RTDM_CREATED_IN_NRT</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set by RTDM if the device instance was created in non-real-time context.  <a href="#ga6f17915089145982b04c51f202d950c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#g24b993fed8dae26b6597ba37f3f92eac">RTDM_CLOSING</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set by RTDM when the device is being closed.  <a href="#g24b993fed8dae26b6597ba37f3f92eac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g187778f8d7b6e5f0b459a526e6323471"></a><!-- doxytag: member="devregister::RTDM_USER_CONTEXT_FLAG" ref="g187778f8d7b6e5f0b459a526e6323471" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#g187778f8d7b6e5f0b459a526e6323471">RTDM_USER_CONTEXT_FLAG</a>&nbsp;&nbsp;&nbsp;8</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lowest bit number the driver developer can use freely. <br></td></tr>
<tr><td colspan="2"><br><h2>Driver Versioning</h2></td></tr>
<tr><td colspan="2"><a class="anchor" name="drv_versioning"></a> Current revisions of RTDM structures, encoding of driver versions. See <a class="el" href="group__rtdm.html#api_versioning">API Versioning</a> for the interface revision. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gb0f99b00be17869d5c9cd844825766f4"></a><!-- doxytag: member="devregister::RTDM_DEVICE_STRUCT_VER" ref="gb0f99b00be17869d5c9cd844825766f4" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#gb0f99b00be17869d5c9cd844825766f4">RTDM_DEVICE_STRUCT_VER</a>&nbsp;&nbsp;&nbsp;5</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Version of struct <a class="el" href="structrtdm__device.html" title="RTDM device.">rtdm_device</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gb127a755cab544c5b318d4f4a3578e9f"></a><!-- doxytag: member="devregister::RTDM_CONTEXT_STRUCT_VER" ref="gb127a755cab544c5b318d4f4a3578e9f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#gb127a755cab544c5b318d4f4a3578e9f">RTDM_CONTEXT_STRUCT_VER</a>&nbsp;&nbsp;&nbsp;3</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Version of struct <a class="el" href="structrtdm__dev__context.html" title="Device context.">rtdm_dev_context</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gdea320d3993937f37edc6fa39a29d379"></a><!-- doxytag: member="devregister::RTDM_SECURE_DEVICE" ref="gdea320d3993937f37edc6fa39a29d379" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#gdea320d3993937f37edc6fa39a29d379">RTDM_SECURE_DEVICE</a>&nbsp;&nbsp;&nbsp;0x80000000</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag indicating a secure variant of RTDM (not supported here). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="geddd03e63cdce1692edcc497a44756c2"></a><!-- doxytag: member="devregister::RTDM_DRIVER_VER" ref="geddd03e63cdce1692edcc497a44756c2" args="(major, minor, patch)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#geddd03e63cdce1692edcc497a44756c2">RTDM_DRIVER_VER</a>(major, minor, patch)&nbsp;&nbsp;&nbsp;(((major &amp; 0xFF) &lt;&lt; 16) | ((minor &amp; 0xFF) &lt;&lt; 8) | (patch &amp; 0xFF))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Version code constructor for driver revisions. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g4df977587f67fefde551a437848b9514"></a><!-- doxytag: member="devregister::RTDM_DRIVER_MAJOR_VER" ref="g4df977587f67fefde551a437848b9514" args="(ver)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#g4df977587f67fefde551a437848b9514">RTDM_DRIVER_MAJOR_VER</a>(ver)&nbsp;&nbsp;&nbsp;(((ver) &gt;&gt; 16) &amp; 0xFF)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get major version number from driver revision code. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g1c2cb29427406f0febbb1c143f76497f"></a><!-- doxytag: member="devregister::RTDM_DRIVER_MINOR_VER" ref="g1c2cb29427406f0febbb1c143f76497f" args="(ver)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#g1c2cb29427406f0febbb1c143f76497f">RTDM_DRIVER_MINOR_VER</a>(ver)&nbsp;&nbsp;&nbsp;(((ver) &gt;&gt; 8) &amp; 0xFF)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get minor version number from driver revision code. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g606a1554fc17b5b8d6c0fa8d6dbb8f9b"></a><!-- doxytag: member="devregister::RTDM_DRIVER_PATCH_VER" ref="g606a1554fc17b5b8d6c0fa8d6dbb8f9b" args="(ver)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#g606a1554fc17b5b8d6c0fa8d6dbb8f9b">RTDM_DRIVER_PATCH_VER</a>(ver)&nbsp;&nbsp;&nbsp;((ver) &amp; 0xFF)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get patch version number from driver revision code. <br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#g765ab311ea9024a7ff210e963acd7a14">rtdm_context_to_private</a> (struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Locate the driver private area associated to a device context structure.  <a href="#g765ab311ea9024a7ff210e963acd7a14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#gcc982b978fc3967b0e9d6d308f79c6ee">rtdm_private_to_context</a> (void *dev_private)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Locate a device context structure from its driver private area.  <a href="#gcc982b978fc3967b0e9d6d308f79c6ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#g6a191b3d206680c48cad2047adb9fc98">rtdm_dev_register</a> (struct <a class="el" href="structrtdm__device.html">rtdm_device</a> *device)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a RTDM device.  <a href="#g6a191b3d206680c48cad2047adb9fc98"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#g9cc04a9b6e1710d9ad3860de8d81bf14">rtdm_dev_unregister</a> (struct <a class="el" href="structrtdm__device.html">rtdm_device</a> *device, unsigned int poll_delay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unregisters a RTDM device.  <a href="#g9cc04a9b6e1710d9ad3860de8d81bf14"></a><br></td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="g24b993fed8dae26b6597ba37f3f92eac"></a><!-- doxytag: member="rtdm_driver.h::RTDM_CLOSING" ref="g24b993fed8dae26b6597ba37f3f92eac" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTDM_CLOSING&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set by RTDM when the device is being closed. 
<p>

</div>
</div><p>
<a class="anchor" name="ga6f17915089145982b04c51f202d950c"></a><!-- doxytag: member="rtdm_driver.h::RTDM_CREATED_IN_NRT" ref="ga6f17915089145982b04c51f202d950c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTDM_CREATED_IN_NRT&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set by RTDM if the device instance was created in non-real-time context. 
<p>

</div>
</div><p>
<a class="anchor" name="gfdb542eb46679916b0100969e1033bfc"></a><!-- doxytag: member="rtdm_driver.h::RTDM_DEVICE_TYPE_MASK" ref="gfdb542eb46679916b0100969e1033bfc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTDM_DEVICE_TYPE_MASK&nbsp;&nbsp;&nbsp;0x00F0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mask selecting the device type. 
<p>

<p>Referenced by <a class="el" href="skins_2rtdm_2device_8c-source.html#l00195">rtdm_dev_register()</a>, and <a class="el" href="skins_2rtdm_2device_8c-source.html#l00399">rtdm_dev_unregister()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g7c66ec8f269c701237437177af0704e8"></a><!-- doxytag: member="rtdm_driver.h::RTDM_EXCLUSIVE" ref="g7c66ec8f269c701237437177af0704e8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTDM_EXCLUSIVE&nbsp;&nbsp;&nbsp;0x0001          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If set, only a single instance of the device can be requested by an application. 
<p>

<p>Referenced by <a class="el" href="skins_2rtdm_2device_8c-source.html#l00195">rtdm_dev_register()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g7651188ca1c05f7e68b36517874138b7"></a><!-- doxytag: member="rtdm_driver.h::RTDM_NAMED_DEVICE" ref="g7651188ca1c05f7e68b36517874138b7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTDM_NAMED_DEVICE&nbsp;&nbsp;&nbsp;0x0010          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If set, the device is addressed via a clear-text name. 
<p>

<p>Referenced by <a class="el" href="skins_2rtdm_2device_8c-source.html#l00195">rtdm_dev_register()</a>, and <a class="el" href="skins_2rtdm_2device_8c-source.html#l00399">rtdm_dev_unregister()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g43ced044106ae9c1f5500d0041307d8f"></a><!-- doxytag: member="rtdm_driver.h::RTDM_PROTOCOL_DEVICE" ref="g43ced044106ae9c1f5500d0041307d8f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTDM_PROTOCOL_DEVICE&nbsp;&nbsp;&nbsp;0x0020          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If set, the device is addressed via a combination of protocol ID and socket type. 
<p>

<p>Referenced by <a class="el" href="skins_2rtdm_2device_8c-source.html#l00195">rtdm_dev_register()</a>.</p>

</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="g6bd6c0761590d59f67b2c1e87fdd8440"></a><!-- doxytag: member="rtdm_driver.h::rtdm_close_handler_t" ref="g6bd6c0761590d59f67b2c1e87fdd8440" args=")(struct rtdm_dev_context *context, rtdm_user_info_t *user_info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* <a class="el" href="group__devregister.html#g6bd6c0761590d59f67b2c1e87fdd8440">rtdm_close_handler_t</a>)(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close handler. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>context</em>&nbsp;</td><td>Context structure associated with opened device instance </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>user_info</em>&nbsp;</td><td>Opaque pointer to information about user mode caller, NULL if kernel mode or deferred user mode call</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success. On failure return either -ENOSYS, to request that this handler be called again from the opposite realtime/non-realtime context, -EAGAIN to request a recall after a grace period, or a valid negative error code according to IEEE Std 1003.1.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Drivers must be prepared for that case that the close handler is invoked more than once per open context (even if the handler already completed an earlier run successfully). The driver has to avoid releasing resources twice as well as returning false errors on successive close invocations.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><code><a class="el" href="group__posix__shm.html#gafbcde67669a1b96577e735ddebd8634" title="Close a file descriptor.">close()</a></code> in IEEE Std 1003.1, <a href="http://www.opengroup.org/onlinepubs/009695399">http://www.opengroup.org/onlinepubs/009695399</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g3adab7928c65ee8ffd06c82c705d4804"></a><!-- doxytag: member="rtdm_driver.h::rtdm_ioctl_handler_t" ref="g3adab7928c65ee8ffd06c82c705d4804" args=")(struct rtdm_dev_context *context, rtdm_user_info_t *user_info, unsigned int request, void __user *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* <a class="el" href="group__devregister.html#g3adab7928c65ee8ffd06c82c705d4804">rtdm_ioctl_handler_t</a>)(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, unsigned int request, void __user *arg)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
IOCTL handler. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>context</em>&nbsp;</td><td>Context structure associated with opened device instance </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>user_info</em>&nbsp;</td><td>Opaque pointer to information about user mode caller, NULL if kernel mode call </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>request</em>&nbsp;</td><td>Request number as passed by the user </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>arg</em>&nbsp;</td><td>Request argument as passed by the user</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A positive value or 0 on success. On failure return either -ENOSYS, to request that the function be called again from the opposite realtime/non-realtime context, or another negative error code.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><code>ioctl()</code> in IEEE Std 1003.1, <a href="http://www.opengroup.org/onlinepubs/009695399">http://www.opengroup.org/onlinepubs/009695399</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf987b1139579bdb16b4541ea76121fa6"></a><!-- doxytag: member="rtdm_driver.h::rtdm_open_handler_t" ref="gf987b1139579bdb16b4541ea76121fa6" args=")(struct rtdm_dev_context *context, rtdm_user_info_t *user_info, int oflag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* <a class="el" href="group__devregister.html#gf987b1139579bdb16b4541ea76121fa6">rtdm_open_handler_t</a>)(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, int oflag)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Named device open handler. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>context</em>&nbsp;</td><td>Context structure associated with opened device instance </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>user_info</em>&nbsp;</td><td>Opaque pointer to information about user mode caller, NULL if kernel mode call </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>oflag</em>&nbsp;</td><td>Open flags as passed by the user</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success. On failure return either -ENOSYS, to request that this handler be called again from the opposite realtime/non-realtime context, or another negative error code.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><code>open()</code> in IEEE Std 1003.1, <a href="http://www.opengroup.org/onlinepubs/009695399">http://www.opengroup.org/onlinepubs/009695399</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g1a2f92a5ebe9f4d46fb6722ed5da047c"></a><!-- doxytag: member="rtdm_driver.h::rtdm_read_handler_t" ref="g1a2f92a5ebe9f4d46fb6722ed5da047c" args=")(struct rtdm_dev_context *context, rtdm_user_info_t *user_info, void *buf, size_t nbyte)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ssize_t(* <a class="el" href="group__devregister.html#g1a2f92a5ebe9f4d46fb6722ed5da047c">rtdm_read_handler_t</a>)(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, void *buf, size_t nbyte)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read handler. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>context</em>&nbsp;</td><td>Context structure associated with opened device instance </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>user_info</em>&nbsp;</td><td>Opaque pointer to information about user mode caller, NULL if kernel mode call </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>buf</em>&nbsp;</td><td>Input buffer as passed by the user </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbyte</em>&nbsp;</td><td>Number of bytes the user requests to read</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>On success, the number of bytes read. On failure return either -ENOSYS, to request that this handler be called again from the opposite realtime/non-realtime context, or another negative error code.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><code>read()</code> in IEEE Std 1003.1, <a href="http://www.opengroup.org/onlinepubs/009695399">http://www.opengroup.org/onlinepubs/009695399</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g8e592853e1072c8b32e2263557990a66"></a><!-- doxytag: member="rtdm_driver.h::rtdm_recvmsg_handler_t" ref="g8e592853e1072c8b32e2263557990a66" args=")(struct rtdm_dev_context *context, rtdm_user_info_t *user_info, struct msghdr *msg, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ssize_t(* <a class="el" href="group__devregister.html#g8e592853e1072c8b32e2263557990a66">rtdm_recvmsg_handler_t</a>)(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, struct msghdr *msg, int flags)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Receive message handler. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>context</em>&nbsp;</td><td>Context structure associated with opened device instance </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>user_info</em>&nbsp;</td><td>Opaque pointer to information about user mode caller, NULL if kernel mode call </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>msg</em>&nbsp;</td><td>Message descriptor as passed by the user, automatically mirrored to safe kernel memory in case of user mode call </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>Message flags as passed by the user</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>On success, the number of bytes received. On failure return either -ENOSYS, to request that this handler be called again from the opposite realtime/non-realtime context, or another negative error code.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><code>recvmsg()</code> in IEEE Std 1003.1, <a href="http://www.opengroup.org/onlinepubs/009695399">http://www.opengroup.org/onlinepubs/009695399</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g462c61f19f6bc6a0ef93a57ab6b218bf"></a><!-- doxytag: member="rtdm_driver.h::rtdm_select_bind_handler_t" ref="g462c61f19f6bc6a0ef93a57ab6b218bf" args=")(struct rtdm_dev_context *context, rtdm_selector_t *selector, enum rtdm_selecttype type, unsigned fd_index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* <a class="el" href="group__devregister.html#g462c61f19f6bc6a0ef93a57ab6b218bf">rtdm_select_bind_handler_t</a>)(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_selector_t *selector, enum <a class="el" href="group__rtdmsync.html#ge18228df8c70c9da1f90f61b01e92501">rtdm_selecttype</a> type, unsigned fd_index)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Select binding handler. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>context</em>&nbsp;</td><td>Context structure associated with opened device instance </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>selector</em>&nbsp;</td><td>Object that shall be bound to the given event </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>Event type the selector is interested in </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fd_index</em>&nbsp;</td><td>Opaque value, to be passed to rtdm_event_select_bind or rtdm_sem_select_bind unmodfied</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success. On failure return either -ENOSYS, to request that this handler be called again from the opposite realtime/non-realtime context, or another negative error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g2f142d15145b97e837f5e26775a4b0f1"></a><!-- doxytag: member="rtdm_driver.h::rtdm_sendmsg_handler_t" ref="g2f142d15145b97e837f5e26775a4b0f1" args=")(struct rtdm_dev_context *context, rtdm_user_info_t *user_info, const struct msghdr *msg, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ssize_t(* <a class="el" href="group__devregister.html#g2f142d15145b97e837f5e26775a4b0f1">rtdm_sendmsg_handler_t</a>)(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, const struct msghdr *msg, int flags)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transmit message handler. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>context</em>&nbsp;</td><td>Context structure associated with opened device instance </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>user_info</em>&nbsp;</td><td>Opaque pointer to information about user mode caller, NULL if kernel mode call </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>msg</em>&nbsp;</td><td>Message descriptor as passed by the user, automatically mirrored to safe kernel memory in case of user mode call </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>Message flags as passed by the user</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>On success, the number of bytes transmitted. On failure return either -ENOSYS, to request that this handler be called again from the opposite realtime/non-realtime context, or another negative error code.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><code>sendmsg()</code> in IEEE Std 1003.1, <a href="http://www.opengroup.org/onlinepubs/009695399">http://www.opengroup.org/onlinepubs/009695399</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g07b8dc34cfc42f6203c510d1e982edc5"></a><!-- doxytag: member="rtdm_driver.h::rtdm_socket_handler_t" ref="g07b8dc34cfc42f6203c510d1e982edc5" args=")(struct rtdm_dev_context *context, rtdm_user_info_t *user_info, int protocol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* <a class="el" href="group__devregister.html#g07b8dc34cfc42f6203c510d1e982edc5">rtdm_socket_handler_t</a>)(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, int protocol)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket creation handler for protocol devices. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>context</em>&nbsp;</td><td>Context structure associated with opened device instance </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>user_info</em>&nbsp;</td><td>Opaque pointer to information about user mode caller, NULL if kernel mode call </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>protocol</em>&nbsp;</td><td>Protocol number as passed by the user</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success. On failure return either -ENOSYS, to request that this handler be called again from the opposite realtime/non-realtime context, or another negative error code.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><code>socket()</code> in IEEE Std 1003.1, <a href="http://www.opengroup.org/onlinepubs/009695399">http://www.opengroup.org/onlinepubs/009695399</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga2b3421e29ae63cf49622765a5bc9cee"></a><!-- doxytag: member="rtdm_driver.h::rtdm_write_handler_t" ref="ga2b3421e29ae63cf49622765a5bc9cee" args=")(struct rtdm_dev_context *context, rtdm_user_info_t *user_info, const void *buf, size_t nbyte)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ssize_t(* <a class="el" href="group__devregister.html#ga2b3421e29ae63cf49622765a5bc9cee">rtdm_write_handler_t</a>)(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, const void *buf, size_t nbyte)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write handler. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>context</em>&nbsp;</td><td>Context structure associated with opened device instance </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>user_info</em>&nbsp;</td><td>Opaque pointer to information about user mode caller, NULL if kernel mode call </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buf</em>&nbsp;</td><td>Output buffer as passed by the user </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbyte</em>&nbsp;</td><td>Number of bytes the user requests to write</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>On success, the number of bytes written. On failure return either -ENOSYS, to request that this handler be called again from the opposite realtime/non-realtime context, or another negative error code.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><code>write()</code> in IEEE Std 1003.1, <a href="http://www.opengroup.org/onlinepubs/009695399">http://www.opengroup.org/onlinepubs/009695399</a> </dd></dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g765ab311ea9024a7ff210e963acd7a14"></a><!-- doxytag: member="rtdm_driver.h::rtdm_context_to_private" ref="g765ab311ea9024a7ff210e963acd7a14" args="(struct rtdm_dev_context *context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void* rtdm_context_to_private           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *&nbsp;</td>
          <td class="paramname"> <em>context</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Locate the driver private area associated to a device context structure. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>context</em>&nbsp;</td><td>Context structure associated with opened device instance</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The address of the private driver area associated to <em>context</em>. </dd></dl>

<p>References <a class="el" href="rtdm__driver_8h-source.html#l00417">rtdm_dev_context::dev_private</a>.</p>

</div>
</div><p>
<a class="anchor" name="g6a191b3d206680c48cad2047adb9fc98"></a><!-- doxytag: member="device.c::rtdm_dev_register" ref="g6a191b3d206680c48cad2047adb9fc98" args="(struct rtdm_device *device)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_dev_register           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrtdm__device.html">rtdm_device</a> *&nbsp;</td>
          <td class="paramname"> <em>device</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a RTDM device. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>device</em>&nbsp;</td><td>Pointer to structure describing the new device.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if the device structure contains invalid entries. Check kernel log in this case.</li></ul>
<p>
<ul>
<li>-ENOMEM is returned if the context for an exclusive device cannot be allocated.</li></ul>
<p>
<ul>
<li>-EEXIST is returned if the specified device name of protocol ID is already in use.</li></ul>
<p>
<ul>
<li>-EAGAIN is returned if some /proc entry cannot be created.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li></ul>
<p>
Rescheduling: never. 
<p>References <a class="el" href="rtdm__driver_8h-source.html#l00342">rtdm_operations::close_nrt</a>, <a class="el" href="rtdm__driver_8h-source.html#l00340">rtdm_operations::close_rt</a>, <a class="el" href="rtdm__driver_8h-source.html#l00469">rtdm_device::context_size</a>, <a class="el" href="rtdm__driver_8h-source.html#l00502">rtdm_device::device_class</a>, <a class="el" href="rtdm__driver_8h-source.html#l00467">rtdm_device::device_flags</a>, <a class="el" href="rtdm__driver_8h-source.html#l00472">rtdm_device::device_name</a>, <a class="el" href="rtdm__driver_8h-source.html#l00505">rtdm_device::device_sub_class</a>, <a class="el" href="rtdm__driver_8h-source.html#l00511">rtdm_device::driver_version</a>, <a class="el" href="rtdm__driver_8h-source.html#l00483">rtdm_device::open_rt</a>, <a class="el" href="rtdm__driver_8h-source.html#l00499">rtdm_device::ops</a>, <a class="el" href="rtdm__driver_8h-source.html#l00519">rtdm_device::proc_name</a>, <a class="el" href="rtdm__driver_8h-source.html#l00507">rtdm_device::profile_version</a>, <a class="el" href="rtdm__driver_8h-source.html#l00475">rtdm_device::protocol_family</a>, <a class="el" href="rtdm__driver_8h-source.html#l00529">rtdm_device::reserved</a>, <a class="el" href="rtdm__driver_8h-source.html#l00106">RTDM_DEVICE_STRUCT_VER</a>, <a class="el" href="rtdm__driver_8h-source.html#l00080">RTDM_DEVICE_TYPE_MASK</a>, <a class="el" href="rtdm__driver_8h-source.html#l00070">RTDM_EXCLUSIVE</a>, <a class="el" href="rtdm__driver_8h-source.html#l00073">RTDM_NAMED_DEVICE</a>, <a class="el" href="rtdm__driver_8h-source.html#l00077">RTDM_PROTOCOL_DEVICE</a>, <a class="el" href="rtdm__driver_8h-source.html#l00350">rtdm_operations::select_bind</a>, <a class="el" href="rtdm__driver_8h-source.html#l00493">rtdm_device::socket_rt</a>, <a class="el" href="rtdm__driver_8h-source.html#l00477">rtdm_device::socket_type</a>, and <a class="el" href="rtdm__driver_8h-source.html#l00464">rtdm_device::struct_version</a>.</p>

</div>
</div><p>
<a class="anchor" name="g9cc04a9b6e1710d9ad3860de8d81bf14"></a><!-- doxytag: member="device.c::rtdm_dev_unregister" ref="g9cc04a9b6e1710d9ad3860de8d81bf14" args="(struct rtdm_device *device, unsigned int poll_delay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_dev_unregister           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrtdm__device.html">rtdm_device</a> *&nbsp;</td>
          <td class="paramname"> <em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>poll_delay</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unregisters a RTDM device. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>device</em>&nbsp;</td><td>Pointer to structure describing the device to be unregistered. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>poll_delay</em>&nbsp;</td><td>Polling delay in milliseconds to check repeatedly for open instances of <em>device</em>, or 0 for non-blocking mode.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-ENODEV is returned if the device was not registered.</li></ul>
<p>
<ul>
<li>-EAGAIN is returned if the device is busy with open instances and 0 has been passed for <em>poll_delay</em>.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li></ul>
<p>
Rescheduling: never. 
<p>References <a class="el" href="rtdm__driver_8h-source.html#l00467">rtdm_device::device_flags</a>, <a class="el" href="rtdm__driver_8h-source.html#l00472">rtdm_device::device_name</a>, <a class="el" href="rtdm__driver_8h-source.html#l00521">rtdm_device::proc_entry</a>, <a class="el" href="rtdm__driver_8h-source.html#l00519">rtdm_device::proc_name</a>, <a class="el" href="rtdm__driver_8h-source.html#l00475">rtdm_device::protocol_family</a>, <a class="el" href="rtdm__driver_8h-source.html#l00529">rtdm_device::reserved</a>, <a class="el" href="rtdm__driver_8h-source.html#l00080">RTDM_DEVICE_TYPE_MASK</a>, <a class="el" href="rtdm__driver_8h-source.html#l00073">RTDM_NAMED_DEVICE</a>, and <a class="el" href="rtdm__driver_8h-source.html#l00477">rtdm_device::socket_type</a>.</p>

</div>
</div><p>
<a class="anchor" name="gcc982b978fc3967b0e9d6d308f79c6ee"></a><!-- doxytag: member="rtdm_driver.h::rtdm_private_to_context" ref="gcc982b978fc3967b0e9d6d308f79c6ee" args="(void *dev_private)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a>* rtdm_private_to_context           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>dev_private</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Locate a device context structure from its driver private area. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dev_private</em>&nbsp;</td><td>Address of a private context area</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The address of the device context structure defining <em>dev_private</em>. </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed May 5 10:20:00 2010 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
