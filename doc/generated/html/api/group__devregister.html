<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Xenomai API: Device Registration Services</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Xenomai API"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Xenomai API
   &#160;<span id="projectnumber">2.6.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__devregister.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Device Registration Services</div>  </div>
<div class="ingroups"><a class="el" href="group__driverapi.html">Driver Development API</a></div></div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Device Registration Services:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__devregister.png" border="0" alt="" usemap="#group____devregister"/>
<map name="group____devregister" id="group____devregister">
<area shape="rect" id="node1" href="group__rtdmsync.html" title="Synchronisation Services" alt="" coords="405,13,576,43"/><area shape="rect" id="node3" href="group__driverapi.html" title="Driver Development API" alt="" coords="7,13,169,43"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__rtdmsync"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html">Synchronisation Services</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrtdm__operations.html">rtdm_operations</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device operations.  <a href="structrtdm__operations.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device context.  <a href="structrtdm__dev__context.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrtdm__device.html">rtdm_device</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RTDM device.  <a href="structrtdm__device.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga765ab311ea9024a7ff210e963acd7a14"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga765ab311ea9024a7ff210e963acd7a14">rtdm_context_to_private</a> (struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context)</td></tr>
<tr class="memdesc:ga765ab311ea9024a7ff210e963acd7a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locate the driver private area associated to a device context structure.  <a href="#ga765ab311ea9024a7ff210e963acd7a14"></a><br/></td></tr>
<tr class="memitem:gacc982b978fc3967b0e9d6d308f79c6ee"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#gacc982b978fc3967b0e9d6d308f79c6ee">rtdm_private_to_context</a> (void *dev_private)</td></tr>
<tr class="memdesc:gacc982b978fc3967b0e9d6d308f79c6ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locate a device context structure from its driver private area.  <a href="#gacc982b978fc3967b0e9d6d308f79c6ee"></a><br/></td></tr>
<tr class="memitem:ga6a191b3d206680c48cad2047adb9fc98"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga6a191b3d206680c48cad2047adb9fc98">rtdm_dev_register</a> (struct <a class="el" href="structrtdm__device.html">rtdm_device</a> *device)</td></tr>
<tr class="memdesc:ga6a191b3d206680c48cad2047adb9fc98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a RTDM device.  <a href="#ga6a191b3d206680c48cad2047adb9fc98"></a><br/></td></tr>
<tr class="memitem:ga9cc04a9b6e1710d9ad3860de8d81bf14"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga9cc04a9b6e1710d9ad3860de8d81bf14">rtdm_dev_unregister</a> (struct <a class="el" href="structrtdm__device.html">rtdm_device</a> *device, unsigned int poll_delay)</td></tr>
<tr class="memdesc:ga9cc04a9b6e1710d9ad3860de8d81bf14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters a RTDM device.  <a href="#ga9cc04a9b6e1710d9ad3860de8d81bf14"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="member-group"></a>
Device Flags</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpc95384c55dfa1b32ba3c6b72b61e79b7"></a><a class="anchor" id="dev_flags"></a> Static flags describing a RTDM device </p>
</td></tr>
<tr class="memitem:ga7c66ec8f269c701237437177af0704e8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga7c66ec8f269c701237437177af0704e8">RTDM_EXCLUSIVE</a>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:ga7c66ec8f269c701237437177af0704e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">If set, only a single instance of the device can be requested by an application.  <a href="#ga7c66ec8f269c701237437177af0704e8"></a><br/></td></tr>
<tr class="memitem:ga7651188ca1c05f7e68b36517874138b7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga7651188ca1c05f7e68b36517874138b7">RTDM_NAMED_DEVICE</a>&#160;&#160;&#160;0x0010</td></tr>
<tr class="memdesc:ga7651188ca1c05f7e68b36517874138b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">If set, the device is addressed via a clear-text name.  <a href="#ga7651188ca1c05f7e68b36517874138b7"></a><br/></td></tr>
<tr class="memitem:ga43ced044106ae9c1f5500d0041307d8f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga43ced044106ae9c1f5500d0041307d8f">RTDM_PROTOCOL_DEVICE</a>&#160;&#160;&#160;0x0020</td></tr>
<tr class="memdesc:ga43ced044106ae9c1f5500d0041307d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If set, the device is addressed via a combination of protocol ID and socket type.  <a href="#ga43ced044106ae9c1f5500d0041307d8f"></a><br/></td></tr>
<tr class="memitem:gafdb542eb46679916b0100969e1033bfc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#gafdb542eb46679916b0100969e1033bfc">RTDM_DEVICE_TYPE_MASK</a>&#160;&#160;&#160;0x00F0</td></tr>
<tr class="memdesc:gafdb542eb46679916b0100969e1033bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask selecting the device type.  <a href="#gafdb542eb46679916b0100969e1033bfc"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="member-group"></a>
Context Flags</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpa55fb86227c85483b85d2d9a0769033c"></a><a class="anchor" id="ctx_flags"></a> Dynamic flags describing the state of an open RTDM device (bit numbers) </p>
</td></tr>
<tr class="memitem:gaa6f17915089145982b04c51f202d950c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#gaa6f17915089145982b04c51f202d950c">RTDM_CREATED_IN_NRT</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gaa6f17915089145982b04c51f202d950c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set by RTDM if the device instance was created in non-real-time context.  <a href="#gaa6f17915089145982b04c51f202d950c"></a><br/></td></tr>
<tr class="memitem:ga24b993fed8dae26b6597ba37f3f92eac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga24b993fed8dae26b6597ba37f3f92eac">RTDM_CLOSING</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga24b993fed8dae26b6597ba37f3f92eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set by RTDM when the device is being closed.  <a href="#ga24b993fed8dae26b6597ba37f3f92eac"></a><br/></td></tr>
<tr class="memitem:ga187778f8d7b6e5f0b459a526e6323471"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga187778f8d7b6e5f0b459a526e6323471"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga187778f8d7b6e5f0b459a526e6323471">RTDM_USER_CONTEXT_FLAG</a>&#160;&#160;&#160;8  /* first user-definable flag */</td></tr>
<tr class="memdesc:ga187778f8d7b6e5f0b459a526e6323471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowest bit number the driver developer can use freely. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="member-group"></a>
Driver Versioning</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp23ea1d5e756ac16354b2dad1e19b079d"></a><a class="anchor" id="drv_versioning"></a> Current revisions of RTDM structures, encoding of driver versions. See <a class="el" href="group__rtdm.html#api_versioning">API Versioning</a> for the interface revision. </p>
</td></tr>
<tr class="memitem:gab0f99b00be17869d5c9cd844825766f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab0f99b00be17869d5c9cd844825766f4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#gab0f99b00be17869d5c9cd844825766f4">RTDM_DEVICE_STRUCT_VER</a>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:gab0f99b00be17869d5c9cd844825766f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of struct <a class="el" href="structrtdm__device.html" title="RTDM device.">rtdm_device</a>. <br/></td></tr>
<tr class="memitem:gab127a755cab544c5b318d4f4a3578e9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab127a755cab544c5b318d4f4a3578e9f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#gab127a755cab544c5b318d4f4a3578e9f">RTDM_CONTEXT_STRUCT_VER</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:gab127a755cab544c5b318d4f4a3578e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of struct <a class="el" href="structrtdm__dev__context.html" title="Device context.">rtdm_dev_context</a>. <br/></td></tr>
<tr class="memitem:gadea320d3993937f37edc6fa39a29d379"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadea320d3993937f37edc6fa39a29d379"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#gadea320d3993937f37edc6fa39a29d379">RTDM_SECURE_DEVICE</a>&#160;&#160;&#160;0x80000000</td></tr>
<tr class="memdesc:gadea320d3993937f37edc6fa39a29d379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag indicating a secure variant of RTDM (not supported here) <br/></td></tr>
<tr class="memitem:gaeddd03e63cdce1692edcc497a44756c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaeddd03e63cdce1692edcc497a44756c2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#gaeddd03e63cdce1692edcc497a44756c2">RTDM_DRIVER_VER</a>(major, minor, patch)&#160;&#160;&#160;(((major &amp; 0xFF) &lt;&lt; 16) | ((minor &amp; 0xFF) &lt;&lt; 8) | (patch &amp; 0xFF))</td></tr>
<tr class="memdesc:gaeddd03e63cdce1692edcc497a44756c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version code constructor for driver revisions. <br/></td></tr>
<tr class="memitem:ga4df977587f67fefde551a437848b9514"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4df977587f67fefde551a437848b9514"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga4df977587f67fefde551a437848b9514">RTDM_DRIVER_MAJOR_VER</a>(ver)&#160;&#160;&#160;(((ver) &gt;&gt; 16) &amp; 0xFF)</td></tr>
<tr class="memdesc:ga4df977587f67fefde551a437848b9514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get major version number from driver revision code. <br/></td></tr>
<tr class="memitem:ga1c2cb29427406f0febbb1c143f76497f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1c2cb29427406f0febbb1c143f76497f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga1c2cb29427406f0febbb1c143f76497f">RTDM_DRIVER_MINOR_VER</a>(ver)&#160;&#160;&#160;(((ver) &gt;&gt; 8) &amp; 0xFF)</td></tr>
<tr class="memdesc:ga1c2cb29427406f0febbb1c143f76497f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get minor version number from driver revision code. <br/></td></tr>
<tr class="memitem:ga606a1554fc17b5b8d6c0fa8d6dbb8f9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga606a1554fc17b5b8d6c0fa8d6dbb8f9b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga606a1554fc17b5b8d6c0fa8d6dbb8f9b">RTDM_DRIVER_PATCH_VER</a>(ver)&#160;&#160;&#160;((ver) &amp; 0xFF)</td></tr>
<tr class="memdesc:ga606a1554fc17b5b8d6c0fa8d6dbb8f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get patch version number from driver revision code. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="member-group"></a>
Operation Handler Prototypes</h2></td></tr>
<tr class="memitem:gaf987b1139579bdb16b4541ea76121fa6"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#gaf987b1139579bdb16b4541ea76121fa6">rtdm_open_handler_t</a> )(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, int oflag)</td></tr>
<tr class="memdesc:gaf987b1139579bdb16b4541ea76121fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Named device open handler.  <a href="#gaf987b1139579bdb16b4541ea76121fa6"></a><br/></td></tr>
<tr class="memitem:ga07b8dc34cfc42f6203c510d1e982edc5"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga07b8dc34cfc42f6203c510d1e982edc5">rtdm_socket_handler_t</a> )(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, int protocol)</td></tr>
<tr class="memdesc:ga07b8dc34cfc42f6203c510d1e982edc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket creation handler for protocol devices.  <a href="#ga07b8dc34cfc42f6203c510d1e982edc5"></a><br/></td></tr>
<tr class="memitem:ga6bd6c0761590d59f67b2c1e87fdd8440"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga6bd6c0761590d59f67b2c1e87fdd8440">rtdm_close_handler_t</a> )(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info)</td></tr>
<tr class="memdesc:ga6bd6c0761590d59f67b2c1e87fdd8440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close handler.  <a href="#ga6bd6c0761590d59f67b2c1e87fdd8440"></a><br/></td></tr>
<tr class="memitem:ga3adab7928c65ee8ffd06c82c705d4804"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga3adab7928c65ee8ffd06c82c705d4804">rtdm_ioctl_handler_t</a> )(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, unsigned int request, void __user *arg)</td></tr>
<tr class="memdesc:ga3adab7928c65ee8ffd06c82c705d4804"><td class="mdescLeft">&#160;</td><td class="mdescRight">IOCTL handler.  <a href="#ga3adab7928c65ee8ffd06c82c705d4804"></a><br/></td></tr>
<tr class="memitem:ga462c61f19f6bc6a0ef93a57ab6b218bf"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga462c61f19f6bc6a0ef93a57ab6b218bf">rtdm_select_bind_handler_t</a> )(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_selector_t *selector, enum <a class="el" href="group__rtdmsync.html#gae18228df8c70c9da1f90f61b01e92501">rtdm_selecttype</a> type, unsigned fd_index)</td></tr>
<tr class="memdesc:ga462c61f19f6bc6a0ef93a57ab6b218bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select binding handler.  <a href="#ga462c61f19f6bc6a0ef93a57ab6b218bf"></a><br/></td></tr>
<tr class="memitem:ga1a2f92a5ebe9f4d46fb6722ed5da047c"><td class="memItemLeft" align="right" valign="top">typedef ssize_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga1a2f92a5ebe9f4d46fb6722ed5da047c">rtdm_read_handler_t</a> )(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, void *buf, size_t nbyte)</td></tr>
<tr class="memdesc:ga1a2f92a5ebe9f4d46fb6722ed5da047c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read handler.  <a href="#ga1a2f92a5ebe9f4d46fb6722ed5da047c"></a><br/></td></tr>
<tr class="memitem:gaa2b3421e29ae63cf49622765a5bc9cee"><td class="memItemLeft" align="right" valign="top">typedef ssize_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#gaa2b3421e29ae63cf49622765a5bc9cee">rtdm_write_handler_t</a> )(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, const void *buf, size_t nbyte)</td></tr>
<tr class="memdesc:gaa2b3421e29ae63cf49622765a5bc9cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write handler.  <a href="#gaa2b3421e29ae63cf49622765a5bc9cee"></a><br/></td></tr>
<tr class="memitem:ga8e592853e1072c8b32e2263557990a66"><td class="memItemLeft" align="right" valign="top">typedef ssize_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga8e592853e1072c8b32e2263557990a66">rtdm_recvmsg_handler_t</a> )(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, struct msghdr *msg, int flags)</td></tr>
<tr class="memdesc:ga8e592853e1072c8b32e2263557990a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive message handler.  <a href="#ga8e592853e1072c8b32e2263557990a66"></a><br/></td></tr>
<tr class="memitem:ga2f142d15145b97e837f5e26775a4b0f1"><td class="memItemLeft" align="right" valign="top">typedef ssize_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga2f142d15145b97e837f5e26775a4b0f1">rtdm_sendmsg_handler_t</a> )(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, const struct msghdr *msg, int flags)</td></tr>
<tr class="memdesc:ga2f142d15145b97e837f5e26775a4b0f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit message handler.  <a href="#ga2f142d15145b97e837f5e26775a4b0f1"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<h2>Macro Definition Documentation</h2>
<a class="anchor" id="ga24b993fed8dae26b6597ba37f3f92eac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTDM_CLOSING&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set by RTDM when the device is being closed. </p>

</div>
</div>
<a class="anchor" id="gaa6f17915089145982b04c51f202d950c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTDM_CREATED_IN_NRT&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set by RTDM if the device instance was created in non-real-time context. </p>

</div>
</div>
<a class="anchor" id="gafdb542eb46679916b0100969e1033bfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTDM_DEVICE_TYPE_MASK&#160;&#160;&#160;0x00F0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask selecting the device type. </p>

<p>Referenced by <a class="el" href="group__devregister.html#ga6a191b3d206680c48cad2047adb9fc98">rtdm_dev_register()</a>, and <a class="el" href="group__devregister.html#ga9cc04a9b6e1710d9ad3860de8d81bf14">rtdm_dev_unregister()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7c66ec8f269c701237437177af0704e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTDM_EXCLUSIVE&#160;&#160;&#160;0x0001</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If set, only a single instance of the device can be requested by an application. </p>

<p>Referenced by <a class="el" href="group__devregister.html#ga6a191b3d206680c48cad2047adb9fc98">rtdm_dev_register()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7651188ca1c05f7e68b36517874138b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTDM_NAMED_DEVICE&#160;&#160;&#160;0x0010</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If set, the device is addressed via a clear-text name. </p>

<p>Referenced by <a class="el" href="group__devregister.html#ga6a191b3d206680c48cad2047adb9fc98">rtdm_dev_register()</a>, and <a class="el" href="group__devregister.html#ga9cc04a9b6e1710d9ad3860de8d81bf14">rtdm_dev_unregister()</a>.</p>

</div>
</div>
<a class="anchor" id="ga43ced044106ae9c1f5500d0041307d8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTDM_PROTOCOL_DEVICE&#160;&#160;&#160;0x0020</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If set, the device is addressed via a combination of protocol ID and socket type. </p>

<p>Referenced by <a class="el" href="group__devregister.html#ga6a191b3d206680c48cad2047adb9fc98">rtdm_dev_register()</a>.</p>

</div>
</div>
<h2>Typedef Documentation</h2>
<a class="anchor" id="ga6bd6c0761590d59f67b2c1e87fdd8440"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* rtdm_close_handler_t)(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Context structure associated with opened device instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_info</td><td>Opaque pointer to information about user mode caller, NULL if kernel mode or deferred user mode call</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On failure return either -ENOSYS, to request that this handler be called again from the opposite realtime/non-realtime context, -EAGAIN to request a recall after a grace period, or a valid negative error code according to IEEE Std 1003.1.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Drivers must be prepared for that case that the close handler is invoked more than once per open context (even if the handler already completed an earlier run successfully). The driver has to avoid releasing resources twice as well as returning false errors on successive close invocations.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="group__posix__shm.html#gaafbcde67669a1b96577e735ddebd8634" title="Close a file descriptor.">close()</a></code> in IEEE Std 1003.1, <a href="http://www.opengroup.org/onlinepubs/009695399">http://www.opengroup.org/onlinepubs/009695399</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3adab7928c65ee8ffd06c82c705d4804"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* rtdm_ioctl_handler_t)(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, unsigned int request, void __user *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IOCTL handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Context structure associated with opened device instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_info</td><td>Opaque pointer to information about user mode caller, NULL if kernel mode call </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>Request number as passed by the user </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">arg</td><td>Request argument as passed by the user</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A positive value or 0 on success. On failure return either -ENOSYS, to request that the function be called again from the opposite realtime/non-realtime context, or another negative error code.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><code>ioctl()</code> in IEEE Std 1003.1, <a href="http://www.opengroup.org/onlinepubs/009695399">http://www.opengroup.org/onlinepubs/009695399</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf987b1139579bdb16b4541ea76121fa6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* rtdm_open_handler_t)(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, int oflag)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Named device open handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Context structure associated with opened device instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_info</td><td>Opaque pointer to information about user mode caller, NULL if kernel mode call </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oflag</td><td>Open flags as passed by the user</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On failure return either -ENOSYS, to request that this handler be called again from the opposite realtime/non-realtime context, or another negative error code.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><code>open()</code> in IEEE Std 1003.1, <a href="http://www.opengroup.org/onlinepubs/009695399">http://www.opengroup.org/onlinepubs/009695399</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga1a2f92a5ebe9f4d46fb6722ed5da047c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ssize_t(* rtdm_read_handler_t)(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, void *buf, size_t nbyte)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Context structure associated with opened device instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_info</td><td>Opaque pointer to information about user mode caller, NULL if kernel mode call </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Input buffer as passed by the user </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbyte</td><td>Number of bytes the user requests to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the number of bytes read. On failure return either -ENOSYS, to request that this handler be called again from the opposite realtime/non-realtime context, or another negative error code.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><code>read()</code> in IEEE Std 1003.1, <a href="http://www.opengroup.org/onlinepubs/009695399">http://www.opengroup.org/onlinepubs/009695399</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8e592853e1072c8b32e2263557990a66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ssize_t(* rtdm_recvmsg_handler_t)(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, struct msghdr *msg, int flags)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive message handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Context structure associated with opened device instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_info</td><td>Opaque pointer to information about user mode caller, NULL if kernel mode call </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Message descriptor as passed by the user, automatically mirrored to safe kernel memory in case of user mode call </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Message flags as passed by the user</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the number of bytes received. On failure return either -ENOSYS, to request that this handler be called again from the opposite realtime/non-realtime context, or another negative error code.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><code>recvmsg()</code> in IEEE Std 1003.1, <a href="http://www.opengroup.org/onlinepubs/009695399">http://www.opengroup.org/onlinepubs/009695399</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga462c61f19f6bc6a0ef93a57ab6b218bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* rtdm_select_bind_handler_t)(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_selector_t *selector, enum <a class="el" href="group__rtdmsync.html#gae18228df8c70c9da1f90f61b01e92501">rtdm_selecttype</a> type, unsigned fd_index)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select binding handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Context structure associated with opened device instance </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">selector</td><td>Object that shall be bound to the given event </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Event type the selector is interested in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fd_index</td><td>Opaque value, to be passed to rtdm_event_select_bind or rtdm_sem_select_bind unmodfied</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On failure return either -ENOSYS, to request that this handler be called again from the opposite realtime/non-realtime context, or another negative error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2f142d15145b97e837f5e26775a4b0f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ssize_t(* rtdm_sendmsg_handler_t)(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, const struct msghdr *msg, int flags)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit message handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Context structure associated with opened device instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_info</td><td>Opaque pointer to information about user mode caller, NULL if kernel mode call </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Message descriptor as passed by the user, automatically mirrored to safe kernel memory in case of user mode call </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Message flags as passed by the user</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the number of bytes transmitted. On failure return either -ENOSYS, to request that this handler be called again from the opposite realtime/non-realtime context, or another negative error code.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><code>sendmsg()</code> in IEEE Std 1003.1, <a href="http://www.opengroup.org/onlinepubs/009695399">http://www.opengroup.org/onlinepubs/009695399</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga07b8dc34cfc42f6203c510d1e982edc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* rtdm_socket_handler_t)(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, int protocol)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Socket creation handler for protocol devices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Context structure associated with opened device instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_info</td><td>Opaque pointer to information about user mode caller, NULL if kernel mode call </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">protocol</td><td>Protocol number as passed by the user</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On failure return either -ENOSYS, to request that this handler be called again from the opposite realtime/non-realtime context, or another negative error code.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><code>socket()</code> in IEEE Std 1003.1, <a href="http://www.opengroup.org/onlinepubs/009695399">http://www.opengroup.org/onlinepubs/009695399</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa2b3421e29ae63cf49622765a5bc9cee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ssize_t(* rtdm_write_handler_t)(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, const void *buf, size_t nbyte)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Context structure associated with opened device instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_info</td><td>Opaque pointer to information about user mode caller, NULL if kernel mode call </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Output buffer as passed by the user </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbyte</td><td>Number of bytes the user requests to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the number of bytes written. On failure return either -ENOSYS, to request that this handler be called again from the opposite realtime/non-realtime context, or another negative error code.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><code>write()</code> in IEEE Std 1003.1, <a href="http://www.opengroup.org/onlinepubs/009695399">http://www.opengroup.org/onlinepubs/009695399</a> </dd></dl>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="ga765ab311ea9024a7ff210e963acd7a14"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* rtdm_context_to_private </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locate the driver private area associated to a device context structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Context structure associated with opened device instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The address of the private driver area associated to <em>context</em>. </dd></dl>

<p>References <a class="el" href="structrtdm__dev__context.html#a720bc9395d80f0dea40c7ac3e449ea25">rtdm_dev_context::dev_private</a>.</p>

</div>
</div>
<a class="anchor" id="ga6a191b3d206680c48cad2047adb9fc98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_dev_register </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrtdm__device.html">rtdm_device</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a RTDM device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Pointer to structure describing the new device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if the device structure contains invalid entries. Check kernel log in this case.</li>
</ul>
<ul>
<li>-ENOMEM is returned if the context for an exclusive device cannot be allocated.</li>
</ul>
<ul>
<li>-EEXIST is returned if the specified device name of protocol ID is already in use.</li>
</ul>
<ul>
<li>-EAGAIN is returned if some /proc entry cannot be created.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
</ul>
<p>Rescheduling: never. </p>

<p>References <a class="el" href="structrtdm__operations.html#a218dceb0ad1125f2c1c3e3e95a8d4894">rtdm_operations::close_nrt</a>, <a class="el" href="structrtdm__operations.html#a23a81aa4c48d55c937c2763c27c8372c">rtdm_operations::close_rt</a>, <a class="el" href="structrtdm__device.html#a48d67f835c341c5d27bc5886920a11da">rtdm_device::context_size</a>, <a class="el" href="structrtdm__device.html#a94aa3100258b43c812c5240b55777f07">rtdm_device::device_class</a>, <a class="el" href="structrtdm__device.html#af459bf86f0d037c99bb669f627d78764">rtdm_device::device_flags</a>, <a class="el" href="structrtdm__device.html#a376a833e95ff75eb9c8033895bc5e102">rtdm_device::device_name</a>, <a class="el" href="structrtdm__device.html#aece6c5135a6256dbb3636f66eb97cb40">rtdm_device::device_sub_class</a>, <a class="el" href="structrtdm__device.html#aebcb235c789d0698fd821124817e2330">rtdm_device::driver_version</a>, <a class="el" href="structrtdm__device.html#af05d59487bedf7d79dc6b1858c0353c9">rtdm_device::open_rt</a>, <a class="el" href="structrtdm__device.html#a5f92064ba1e7eb351b00277b17d513ef">rtdm_device::ops</a>, <a class="el" href="structrtdm__device.html#a0df5612d6bfcf6421509345384467392">rtdm_device::proc_name</a>, <a class="el" href="structrtdm__device.html#a157db58bb0025b832ca409bc40735ae9">rtdm_device::profile_version</a>, <a class="el" href="structrtdm__device.html#ae58c050e09a79b277f718d796eda2072">rtdm_device::protocol_family</a>, <a class="el" href="structrtdm__device.html#a548f89224ffc7146fd46c53a0eb48040">rtdm_device::reserved</a>, <a class="el" href="group__devregister.html#gab0f99b00be17869d5c9cd844825766f4">RTDM_DEVICE_STRUCT_VER</a>, <a class="el" href="group__devregister.html#gafdb542eb46679916b0100969e1033bfc">RTDM_DEVICE_TYPE_MASK</a>, <a class="el" href="group__devregister.html#ga7c66ec8f269c701237437177af0704e8">RTDM_EXCLUSIVE</a>, <a class="el" href="group__devregister.html#ga7651188ca1c05f7e68b36517874138b7">RTDM_NAMED_DEVICE</a>, <a class="el" href="group__devregister.html#ga43ced044106ae9c1f5500d0041307d8f">RTDM_PROTOCOL_DEVICE</a>, <a class="el" href="structrtdm__operations.html#aa052e237d48e04bfb777fde1b6eb83e7">rtdm_operations::select_bind</a>, <a class="el" href="structrtdm__device.html#ad83a8dff6e8705e442f9a7d352556267">rtdm_device::socket_rt</a>, <a class="el" href="structrtdm__device.html#a02552f2d91052bd801576b3a132ba3f9">rtdm_device::socket_type</a>, and <a class="el" href="structrtdm__device.html#aaa2844f98d874f16d802b4e0b693e4e2">rtdm_device::struct_version</a>.</p>

</div>
</div>
<a class="anchor" id="ga9cc04a9b6e1710d9ad3860de8d81bf14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_dev_unregister </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrtdm__device.html">rtdm_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>poll_delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregisters a RTDM device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Pointer to structure describing the device to be unregistered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">poll_delay</td><td>Polling delay in milliseconds to check repeatedly for open instances of <em>device</em>, or 0 for non-blocking mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-ENODEV is returned if the device was not registered.</li>
</ul>
<ul>
<li>-EAGAIN is returned if the device is busy with open instances and 0 has been passed for <em>poll_delay</em>.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
</ul>
<p>Rescheduling: never. </p>

<p>References <a class="el" href="structrtdm__device.html#af459bf86f0d037c99bb669f627d78764">rtdm_device::device_flags</a>, <a class="el" href="structrtdm__device.html#a376a833e95ff75eb9c8033895bc5e102">rtdm_device::device_name</a>, <a class="el" href="structrtdm__device.html#ae58c050e09a79b277f718d796eda2072">rtdm_device::protocol_family</a>, <a class="el" href="structrtdm__device.html#a548f89224ffc7146fd46c53a0eb48040">rtdm_device::reserved</a>, <a class="el" href="group__devregister.html#gafdb542eb46679916b0100969e1033bfc">RTDM_DEVICE_TYPE_MASK</a>, <a class="el" href="group__devregister.html#ga7651188ca1c05f7e68b36517874138b7">RTDM_NAMED_DEVICE</a>, and <a class="el" href="structrtdm__device.html#a02552f2d91052bd801576b3a132ba3f9">rtdm_device::socket_type</a>.</p>

</div>
</div>
<a class="anchor" id="gacc982b978fc3967b0e9d6d308f79c6ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a>* rtdm_private_to_context </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dev_private</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locate a device context structure from its driver private area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_private</td><td>Address of a private context area</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The address of the device context structure defining <em>dev_private</em>. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Oct 4 2013 22:39:09 for Xenomai API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.2 </li>
  </ul>
</div>
</body>
</html>
