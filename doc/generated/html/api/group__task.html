<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Xenomai API: Task management services.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Task management services.<br/>
<small>
[<a class="el" href="group__native.html">Native Xenomai API.</a>]</small>
</h1>
<p><div class="dynheader">
Collaboration diagram for Task management services.:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__task.png" border="0" alt="" usemap="#group____task_map"/>
<map name="group____task_map" id="group____task">
<area shape="rect" href="group__native.html" title="Native Xenomai API." alt="" coords="7,5,148,35"/></map></td></tr></table></center>
</div>
</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ksrc_2skins_2native_2task_8c.html">task.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>This file is part of the Xenomai project. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#ga03387550693c21d0223f739570ccd992">rt_task_create</a> (RT_TASK *task, const char *name, int stksize, int prio, int mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new real-time task.  <a href="#ga03387550693c21d0223f739570ccd992"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#gac9638918b8310a430088f5c9a04d2bb7">rt_task_start</a> (RT_TASK *task, void(*entry)(void *cookie), void *cookie)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start a real-time task.  <a href="#gac9638918b8310a430088f5c9a04d2bb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#ga926a4b10e3631f76c5f38910e6eea24c">rt_task_suspend</a> (RT_TASK *task)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Suspend a real-time task.  <a href="#ga926a4b10e3631f76c5f38910e6eea24c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#ga1fab1aa24ef6f199546fd9669ae711be">rt_task_resume</a> (RT_TASK *task)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resume a real-time task.  <a href="#ga1fab1aa24ef6f199546fd9669ae711be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#gab6e0d411830710e8cc82d77b9df19510">rt_task_delete</a> (RT_TASK *task)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a real-time task.  <a href="#gab6e0d411830710e8cc82d77b9df19510"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#ga31e44b069b2486c2d2bdfb8a0a3557c8">rt_task_yield</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Manual round-robin.  <a href="#ga31e44b069b2486c2d2bdfb8a0a3557c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#gababee94264156693cd4f5b9b70d3c5a1">rt_task_set_periodic</a> (RT_TASK *task, RTIME idate, RTIME period)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a real-time task periodic.  <a href="#gababee94264156693cd4f5b9b70d3c5a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#ga1645d3a072ef3cefeed3bcbb27dcf108">rt_task_wait_period</a> (unsigned long *overruns_r)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for the next periodic release point.  <a href="#ga1645d3a072ef3cefeed3bcbb27dcf108"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#ga3bed8d001e212a3328a4e7e73f1765e8">rt_task_set_priority</a> (RT_TASK *task, int prio)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the base priority of a real-time task.  <a href="#ga3bed8d001e212a3328a4e7e73f1765e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#gad5225e5fb8d583fbdfa5299f322b8366">rt_task_sleep</a> (RTIME delay)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delay the calling task (relative).  <a href="#gad5225e5fb8d583fbdfa5299f322b8366"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#ga0dc2deebe7500c9d21ff05d51d5efaa8">rt_task_sleep_until</a> (RTIME date)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delay the calling task (absolute).  <a href="#ga0dc2deebe7500c9d21ff05d51d5efaa8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#ga770281eeca009c0a08a7c4a9fd849ac1">rt_task_unblock</a> (RT_TASK *task)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unblock a real-time task.  <a href="#ga770281eeca009c0a08a7c4a9fd849ac1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#ga53bad6acf5496f8008e594954507dce8">rt_task_inquire</a> (RT_TASK *task, <a class="el" href="structrt__task__info.html">RT_TASK_INFO</a> *info)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inquire about a real-time task.  <a href="#ga53bad6acf5496f8008e594954507dce8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#ga7452f367f9e17bf2fc0b70f717b96dd8">rt_task_add_hook</a> (int type, void(*routine)(void *cookie))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Install a task hook.  <a href="#ga7452f367f9e17bf2fc0b70f717b96dd8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#ga585bcffb3757845534eed69edd1a27d2">rt_task_remove_hook</a> (int type, void(*routine)(void *cookie))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a task hook.  <a href="#ga585bcffb3757845534eed69edd1a27d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#ga8e17be7a49ac32bbeb3085b3cd1a9915">rt_task_catch</a> (void(*handler)(rt_sigset_t))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Install a signal handler.  <a href="#ga8e17be7a49ac32bbeb3085b3cd1a9915"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#ga70e65c2efb499c48c6d15010a1c630a3">rt_task_notify</a> (RT_TASK *task, rt_sigset_t signals)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send signals to a task.  <a href="#ga70e65c2efb499c48c6d15010a1c630a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#ga915e7edfb0aaddb643794d7abc7093bf">rt_task_set_mode</a> (int clrmask, int setmask, int *mode_r)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change task mode bits.  <a href="#ga915e7edfb0aaddb643794d7abc7093bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#gaaf5467af966c9980da9e489aeacf9aa3">rt_task_self</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the current task.  <a href="#gaaf5467af966c9980da9e489aeacf9aa3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#ga9250436d7bd9e49a0320161d2e9373ae">rt_task_slice</a> (RT_TASK *task, RTIME quantum)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a task's round-robin quantum.  <a href="#ga9250436d7bd9e49a0320161d2e9373ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#ga99a89c21c9866e2784860e100a444b49">rt_task_send</a> (RT_TASK *task, <a class="el" href="structrt__task__mcb.html">RT_TASK_MCB</a> *mcb_s, <a class="el" href="structrt__task__mcb.html">RT_TASK_MCB</a> *mcb_r, RTIME timeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a message to a task.  <a href="#ga99a89c21c9866e2784860e100a444b49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#gaa152f8f41876fc3a828a8eba74d493fe">rt_task_receive</a> (<a class="el" href="structrt__task__mcb.html">RT_TASK_MCB</a> *mcb_r, RTIME timeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive a message from a task.  <a href="#gaa152f8f41876fc3a828a8eba74d493fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#gacd8a4fb2d11f0548bd053dfbf92f9e9d">rt_task_reply</a> (int flowid, <a class="el" href="structrt__task__mcb.html">RT_TASK_MCB</a> *mcb_s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reply to a task.  <a href="#gacd8a4fb2d11f0548bd053dfbf92f9e9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#ga520e6fad1decc5beff58b394ff443265">rt_task_spawn</a> (RT_TASK *task, const char *name, int stksize, int prio, int mode, void(*entry)(void *cookie), void *cookie)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Spawn a new real-time task.  <a href="#ga520e6fad1decc5beff58b394ff443265"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#ga72e0a9355d06c346a95bf88b857a9749">rt_task_shadow</a> (RT_TASK *task, const char *name, int prio, int mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Turns the current Linux task into a native Xenomai task.  <a href="#ga72e0a9355d06c346a95bf88b857a9749"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#gab6bd973c22a6f66e28653922c53e0385">rt_task_bind</a> (RT_TASK *task, const char *name, RTIME timeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bind to a real-time task.  <a href="#gab6bd973c22a6f66e28653922c53e0385"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#ga2038cbe2350a8e2558330a3f45953865">rt_task_unbind</a> (RT_TASK *task)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unbind from a real-time task.  <a href="#ga2038cbe2350a8e2558330a3f45953865"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#ga8c77d57638578a126812e29429f61fe7">rt_task_join</a> (RT_TASK *task)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait on the termination of a real-time task.  <a href="#ga8c77d57638578a126812e29429f61fe7"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Xenomai provides a set of multitasking mechanisms. The basic process object performing actions in Xenomai is a task, a logically complete path of application code. Each Xenomai task is an independent portion of the overall application code embodied in a C procedure, which executes on its own stack context.</p>
<p>The Xenomai scheduler ensures that concurrent tasks are run according to one of the supported scheduling policies. Currently, the Xenomai scheduler supports fixed priority-based FIFO and round-robin policies. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga7452f367f9e17bf2fc0b70f717b96dd8"></a><!-- doxytag: member="task.c::rt_task_add_hook" ref="ga7452f367f9e17bf2fc0b70f717b96dd8" args="(int type, void(*routine)(void *cookie))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_add_hook </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *cookie)&nbsp;</td>
          <td class="paramname"> <em>routine</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Install a task hook. </p>
<p>The real-time kernel allows to register user-defined routines which get called whenever a specific scheduling event occurs. Multiple hooks can be chained for a single event type, and get called on a FIFO basis.</p>
<p>The scheduling is locked while a hook is executing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>Defines the kind of hook to install:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>T_HOOK_START: The user-defined routine will be called on behalf of the starter task whenever a new task starts. An opaque cookie is passed to the routine which can use it to retrieve the descriptor address of the started task through the T_DESC() macro.</li>
</ul>
<ul>
<li>T_HOOK_DELETE: The user-defined routine will be called on behalf of the deletor task whenever a task is deleted. An opaque cookie is passed to the routine which can use it to retrieve the descriptor address of the deleted task through the T_DESC() macro.</li>
</ul>
<ul>
<li>T_HOOK_SWITCH: The user-defined routine will be called on behalf of the resuming task whenever a context switch takes place. An opaque cookie is passed to the routine which can use it to retrieve the descriptor address of the task which has been switched in through the T_DESC() macro.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>routine</em>&nbsp;</td><td>The address of the user-supplied routine to call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise, one of the following error codes indicates the cause of the failure:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>type</em> is incorrect.</li>
</ul>
<ul>
<li>-ENOMEM is returned if not enough memory is available from the system heap to add the new hook.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
</ul>
<p>Rescheduling: never. </p>

<p>References <a class="el" href="pod_8c_source.html#l02768">xnpod_add_hook()</a>.</p>

</div>
</div>
<a class="anchor" id="gab6bd973c22a6f66e28653922c53e0385"></a><!-- doxytag: member="task.h::rt_task_bind" ref="gab6bd973c22a6f66e28653922c53e0385" args="(RT_TASK *task, const char *name, RTIME timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_bind </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&nbsp;</td>
          <td class="paramname"> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bind to a real-time task. </p>
<p>This user-space only service retrieves the uniform descriptor of a given Xenomai task identified by its symbolic name. If the task does not exist on entry, this service blocks the caller until a task of the given name is created.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>A valid NULL-terminated name which identifies the task to bind to.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>The address of a task descriptor retrieved by the operation. Contents of this memory is undefined upon failure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The number of clock ticks to wait for the registration to occur (see note). Passing TM_INFINITE causes the caller to block indefinitely until the object is registered. Passing TM_NONBLOCK causes the service to return immediately without waiting if the object is not registered on entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EFAULT is returned if <em>task</em> or <em>name</em> is referencing invalid memory.</li>
</ul>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task.">rt_task_unblock()</a> has been called for the waiting task before the retrieval has completed.</li>
</ul>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to TM_NONBLOCK and the searched object is not registered on entry.</li>
</ul>
<ul>
<li>-ETIMEDOUT is returned if the object cannot be retrieved within the specified amount of time.</li>
</ul>
<ul>
<li>-EPERM is returned if this service should block, but was called from a context which cannot sleep (e.g. interrupt, non-realtime or scheduler locked).</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>User-space task (switches to primary mode)</li>
</ul>
<p>Rescheduling: always unless the request is immediately satisfied or <em>timeout</em> specifies a non-blocking operation.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The <em>timeout</em> value will be interpreted as jiffies if the native skin is bound to a periodic time base (see CONFIG_XENO_OPT_NATIVE_PERIOD), or nanoseconds otherwise. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="bound__task_8c-example.html#a0">bound_task.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga8e17be7a49ac32bbeb3085b3cd1a9915"></a><!-- doxytag: member="task.c::rt_task_catch" ref="ga8e17be7a49ac32bbeb3085b3cd1a9915" args="(void(*handler)(rt_sigset_t))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_catch </td>
          <td>(</td>
          <td class="paramtype">void(*)(rt_sigset_t)&nbsp;</td>
          <td class="paramname"> <em>handler</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Install a signal handler. </p>
<p>This service installs a signal handler for the current task. Signals are discrete events tasks can receive each time they resume execution. When signals are pending upon resumption, <em>handler</em> is fired to process them. Signals can be sent using <a class="el" href="group__task.html#ga70e65c2efb499c48c6d15010a1c630a3" title="Send signals to a task.">rt_task_notify()</a>. A task can block the signal delivery by passing the T_NOSIG bit to <a class="el" href="group__task.html#ga915e7edfb0aaddb643794d7abc7093bf" title="Change task mode bits.">rt_task_set_mode()</a>.</p>
<p>Calling this service implicitely unblocks the signal delivery for the caller.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The address of the user-supplied routine to fire when signals are pending for the task. This handler is passed the set of pending signals as its first and only argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 upon success, or:</dd></dl>
<ul>
<li>-EPERM is returned if this service was not called from a real-time task context.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel-based task</li>
</ul>
<p>Rescheduling: possible. </p>

<p>References <a class="el" href="include_2nucleus_2thread_8h_source.html#l00049">XNASDI</a>, and <a class="el" href="pod_8c_source.html#l02379">xnpod_schedule()</a>.</p>

</div>
</div>
<a class="anchor" id="ga03387550693c21d0223f739570ccd992"></a><!-- doxytag: member="task.c::rt_task_create" ref="ga03387550693c21d0223f739570ccd992" args="(RT_TASK *task, const char *name, int stksize, int prio, int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_create </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&nbsp;</td>
          <td class="paramname"> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>stksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>prio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new real-time task. </p>
<p>Creates a real-time task, either running in a kernel module or in user-space depending on the caller's context.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>The address of a task descriptor Xenomai will use to store the task-related data. This descriptor must always be valid while the task is active therefore it must be allocated in permanent memory.</td></tr>
  </table>
  </dd>
</dl>
<p>The task is left in an innocuous state until it is actually started by <a class="el" href="group__task.html#gac9638918b8310a430088f5c9a04d2bb7" title="Start a real-time task.">rt_task_start()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>An ASCII string standing for the symbolic name of the task. When non-NULL and non-empty, this string is copied to a safe place into the descriptor, and passed to the registry package if enabled for indexing the created task.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stksize</em>&nbsp;</td><td>The size of the stack (in bytes) for the new task. If zero is passed, a reasonable pre-defined size will be substituted.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prio</em>&nbsp;</td><td>The base priority of the new task. This value must range from [1 .. 99] (inclusive) where 1 is the lowest effective priority.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>The task creation mode. The following flags can be OR'ed into this bitmask, each of them affecting the new task:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>T_FPU allows the task to use the FPU whenever available on the platform. This flag is forced for user-space tasks.</li>
</ul>
<ul>
<li>T_SUSP causes the task to start in suspended mode. In such a case, the thread will have to be explicitly resumed using the <a class="el" href="group__task.html#ga1fab1aa24ef6f199546fd9669ae711be" title="Resume a real-time task.">rt_task_resume()</a> service for its execution to actually begin.</li>
</ul>
<ul>
<li>T_CPU(cpuid) makes the new task affine to CPU # <b>cpuid</b>. CPU identifiers range from 0 to RTHAL_NR_CPUS - 1 (inclusive).</li>
</ul>
<ul>
<li>T_JOINABLE (user-space only) allows another task to wait on the termination of the new task. This implies that <a class="el" href="group__task.html#ga8c77d57638578a126812e29429f61fe7" title="Wait on the termination of a real-time task.">rt_task_join()</a> is actually called for this task to clean up any user-space located resources after its termination.</li>
</ul>
<p>Passing T_FPU|T_CPU(1) in the <em>mode</em> parameter thus creates a task with FPU support enabled and which will be affine to CPU #1.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-ENOMEM is returned if the system fails to get enough dynamic memory from the global real-time heap in order to create or register the task.</li>
</ul>
<ul>
<li>-EEXIST is returned if the <em>name</em> is already in use by some registered object.</li>
</ul>
<ul>
<li>-EPERM is returned if this service was called from an asynchronous context.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: possible. </p>

<p>References <a class="el" href="thread__attr_8c_source.html#l00081">pthread_attr_init()</a>, <a class="el" href="thread__attr_8c_source.html#l00197">pthread_attr_setdetachstate()</a>, <a class="el" href="thread__attr_8c_source.html#l00373">pthread_attr_setinheritsched()</a>, <a class="el" href="thread__attr_8c_source.html#l00571">pthread_attr_setschedparam()</a>, <a class="el" href="thread__attr_8c_source.html#l00467">pthread_attr_setschedpolicy()</a>, <a class="el" href="thread__attr_8c_source.html#l00283">pthread_attr_setstacksize()</a>, <a class="el" href="include_2nucleus_2thread_8h_source.html#l00059">XNFPU</a>, <a class="el" href="pod_8c_source.html#l01118">xnpod_delete_thread()</a>, <a class="el" href="pod_8c_source.html#l00683">xnpod_init_thread()</a>, <a class="el" href="nucleus_2registry_8c_source.html#l00582">xnregistry_enter()</a>, <a class="el" href="include_2nucleus_2thread_8h_source.html#l00060">XNSHADOW</a>, <a class="el" href="include_2nucleus_2thread_8h_source.html#l00055">XNSHIELD</a>, <a class="el" href="include_2nucleus_2thread_8h_source.html#l00033">XNSUSP</a>, and <a class="el" href="synch_8c_source.html#l00087">xnsynch_init()</a>.</p>

<p>Referenced by <a class="el" href="task_8h_source.html#l00314">rt_task_spawn()</a>.</p>

</div>
</div>
<a class="anchor" id="gab6e0d411830710e8cc82d77b9df19510"></a><!-- doxytag: member="task.c::rt_task_delete" ref="gab6e0d411830710e8cc82d77b9df19510" args="(RT_TASK *task)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_delete </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&nbsp;</td>
          <td class="paramname"> <em>task</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete a real-time task. </p>
<p>Terminate a task and release all the real-time kernel resources it currently holds. A task exists in the system since <a class="el" href="group__task.html#ga03387550693c21d0223f739570ccd992" title="Create a new real-time task.">rt_task_create()</a> has been called to create it, so this service must be called in order to destroy it afterwards.</p>
<p>Native tasks implement a mechanism by which they are immune from deletion by other tasks while they run into a deemed safe section of code. This feature is used internally by the native skin in order to prevent tasks from being deleted in the middle of a critical section, without resorting to interrupt masking when the latter is not an option. For this reason, the caller of <a class="el" href="group__task.html#gab6e0d411830710e8cc82d77b9df19510" title="Delete a real-time task.">rt_task_delete()</a> might be blocked and a rescheduling take place, waiting for the target task to exit such critical section.</p>
<p>The DELETE hooks are called on behalf of the calling context (if any). The information stored in the task control block remains valid until all hooks have been called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>The descriptor address of the affected task. If <em>task</em> is NULL, the current task is deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>task</em> is not a task descriptor.</li>
</ul>
<ul>
<li>-EPERM is returned if <em>task</em> is NULL but not called from a task context, or this service was called from an asynchronous context.</li>
</ul>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task.">rt_task_unblock()</a> has been invoked for the caller while it was waiting for <em>task</em> to exit a safe section. In such a case, the deletion process has been aborted and <em>task</em> remains unaffected.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>task</em> is a deleted task descriptor.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code only if <em>task</em> is non-NULL.</li>
</ul>
<ul>
<li>Kernel-based task</li>
<li>Any user-space context (conforming call)</li>
</ul>
<p>Rescheduling: always if <em>task</em> is NULL, and possible if the deleted task is currently running into a safe section. </p>

<p>References <a class="el" href="cancel_8c_source.html#l00089">pthread_cancel()</a>, <a class="el" href="skins_2posix_2thread_8c_source.html#l00341">pthread_exit()</a>, and <a class="el" href="pod_8c_source.html#l01118">xnpod_delete_thread()</a>.</p>

</div>
</div>
<a class="anchor" id="ga53bad6acf5496f8008e594954507dce8"></a><!-- doxytag: member="task.c::rt_task_inquire" ref="ga53bad6acf5496f8008e594954507dce8" args="(RT_TASK *task, RT_TASK_INFO *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_inquire </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&nbsp;</td>
          <td class="paramname"> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrt__task__info.html">RT_TASK_INFO</a> *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inquire about a real-time task. </p>
<p>Return various information about the status of a given task.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>The descriptor address of the inquired task. If <em>task</em> is NULL, the current task is inquired.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>The address of a structure the task information will be written to. Passing NULL is valid, in which case the system is only probed for existence of the specified task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned if the task exists, and status information is written to the structure pointed at by <em>info</em> if non-NULL. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>task</em> is not a task descriptor.</li>
</ul>
<ul>
<li>-EPERM is returned if <em>task</em> is NULL but not called from a task context.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>task</em> is a deleted task descriptor.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine only if <em>task</em> is non-NULL.</li>
</ul>
<ul>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: never. </p>

<p>References <a class="el" href="task_8h_source.html#l00083">rt_task_info::bprio</a>, <a class="el" href="task_8h_source.html#l00085">rt_task_info::cprio</a>, <a class="el" href="task_8h_source.html#l00097">rt_task_info::ctxswitches</a>, <a class="el" href="task_8h_source.html#l00093">rt_task_info::exectime</a>, <a class="el" href="task_8h_source.html#l00095">rt_task_info::modeswitches</a>, <a class="el" href="task_8h_source.html#l00091">rt_task_info::name</a>, <a class="el" href="task_8h_source.html#l00099">rt_task_info::pagefaults</a>, <a class="el" href="task_8h_source.html#l00089">rt_task_info::relpoint</a>, <a class="el" href="task_8h_source.html#l00087">rt_task_info::status</a>, and <a class="el" href="include_2nucleus_2timer_8h_source.html#l00540">xntimer_get_date()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8c77d57638578a126812e29429f61fe7"></a><!-- doxytag: member="task.h::rt_task_join" ref="ga8c77d57638578a126812e29429f61fe7" args="(RT_TASK *task)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_join </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&nbsp;</td>
          <td class="paramname"> <em>task</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait on the termination of a real-time task. </p>
<p>This user-space only service blocks the caller in non-real-time context until <em>task</em> has terminated. Note that the specified task must have been created with the T_JOINABLE mode flag set.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>The address of a task descriptor to join.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if the task was not created with T_JOINABLE set or some other task is already waiting on the termination.</li>
</ul>
<ul>
<li>-EDEADLK is returned if <em>task</em> refers to the caller.</li>
</ul>
<p>This service can be called from:</p>
<ul>
<li>User-space task.</li>
</ul>
<p>Rescheduling: always unless the task was already terminated. </p>

<p>References <a class="el" href="skins_2posix_2thread_8c_source.html#l00399">pthread_join()</a>.</p>

</div>
</div>
<a class="anchor" id="ga70e65c2efb499c48c6d15010a1c630a3"></a><!-- doxytag: member="task.c::rt_task_notify" ref="ga70e65c2efb499c48c6d15010a1c630a3" args="(RT_TASK *task, rt_sigset_t signals)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_notify </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&nbsp;</td>
          <td class="paramname"> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_sigset_t&nbsp;</td>
          <td class="paramname"> <em>signals</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send signals to a task. </p>
<p>This service sends a set of signals to a given task. A task can install a signal handler using the <a class="el" href="group__task.html#ga8e17be7a49ac32bbeb3085b3cd1a9915" title="Install a signal handler.">rt_task_catch()</a> service to process them.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>The descriptor address of the affected task which must have been previously created by the <a class="el" href="group__task.html#ga03387550693c21d0223f739570ccd992" title="Create a new real-time task.">rt_task_create()</a> service.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>signals</em>&nbsp;</td><td>The set of signals to make pending for the task. This set is OR'ed with the current set of pending signals for the task; there is no count of occurence maintained for each available signal, which is either pending or cleared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>task</em> is not a task descriptor.</li>
</ul>
<ul>
<li>-EPERM is returned if <em>task</em> is NULL but not called from a real-time task context.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>task</em> is a deleted task descriptor.</li>
</ul>
<ul>
<li>-ESRCH is returned if <em>task</em> has not set any signal handler.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine only if <em>task</em> is non-NULL.</li>
</ul>
<ul>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: possible. </p>

<p>References <a class="el" href="pod_8c_source.html#l02379">xnpod_schedule()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa152f8f41876fc3a828a8eba74d493fe"></a><!-- doxytag: member="task.c::rt_task_receive" ref="gaa152f8f41876fc3a828a8eba74d493fe" args="(RT_TASK_MCB *mcb_r, RTIME timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_receive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__task__mcb.html">RT_TASK_MCB</a> *&nbsp;</td>
          <td class="paramname"> <em>mcb_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receive a message from a task. </p>
<p>This service is part of the synchronous message passing support available to Xenomai tasks. It allows the caller to receive a variable-sized message sent from another task using the <a class="el" href="group__task.html#ga99a89c21c9866e2784860e100a444b49" title="Send a message to a task.">rt_task_send()</a> service. The sending task is blocked until the caller invokes <a class="el" href="group__task.html#gacd8a4fb2d11f0548bd053dfbf92f9e9d" title="Reply to a task.">rt_task_reply()</a> to finish the transaction.</p>
<p>A basic message control block is used to store the location and size of the data area to receive from the client, in addition to a user-defined operation code.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mcb_r</em>&nbsp;</td><td>The address of a message control block referring to the receive message area. The fields from this control block should be set as follows:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>mcb_r-&gt;data should contain the address of a buffer large enough to collect the data sent by the remote task;</li>
</ul>
<ul>
<li>mcb_r-&gt;size should contain the size in bytes of the buffer space pointed at by mcb_r-&gt;data. If mcb_r-&gt;size is lower than the actual size of the received message, no data copy takes place and -ENOBUFS is returned to the caller. See note.</li>
</ul>
<p>Upon return, mcb_r-&gt;opcode will contain the operation code sent from the remote task using <a class="el" href="group__task.html#ga99a89c21c9866e2784860e100a444b49" title="Send a message to a task.">rt_task_send()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The number of clock ticks to wait for receiving a message (see note). Passing TM_INFINITE causes the caller to block indefinitely until a remote task eventually sends a message. Passing TM_NONBLOCK causes the service to return immediately without waiting if no remote task is currently waiting for sending a message.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A strictly positive value is returned upon success, representing a flow identifier for the opening transaction; this token should be passed to <a class="el" href="group__task.html#gacd8a4fb2d11f0548bd053dfbf92f9e9d" title="Reply to a task.">rt_task_reply()</a>, in order to send back a reply to and unblock the remote task appropriately. Otherwise:</dd></dl>
<ul>
<li>-ENOBUFS is returned if <em>mcb_r</em> does not point at a message area large enough to collect the remote task's message.</li>
</ul>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to TM_NONBLOCK and no remote task is currently waiting for sending a message to the caller.</li>
</ul>
<ul>
<li>-ETIMEDOUT is returned if no message was received within the <em>timeout</em>.</li>
</ul>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task.">rt_task_unblock()</a> has been called for the caller before any message was available.</li>
</ul>
<ul>
<li>-EPERM is returned if this service was called from a context which cannot sleep (e.g. interrupt, non-realtime or scheduler locked).</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel-based task</li>
<li>User-space task (switches to primary mode)</li>
</ul>
<p>Rescheduling: Always.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The <em>timeout</em> value will be interpreted as jiffies if the native skin is bound to a periodic time base (see CONFIG_XENO_OPT_NATIVE_PERIOD), or nanoseconds otherwise.</dd>
<dd>
When called from a user-space task, this service may need to allocate some temporary buffer space from the system heap to hold the received data if the size of the latter exceeds a certain amount; the threshold before allocation is currently set to 64 bytes. </dd></dl>

<p>References <a class="el" href="task_8h_source.html#l00114">rt_task_mcb::data</a>, <a class="el" href="task_8h_source.html#l00112">rt_task_mcb::opcode</a>, <a class="el" href="task_8h_source.html#l00116">rt_task_mcb::size</a>, <a class="el" href="include_2nucleus_2thread_8h_source.html#l00112">XNBREAK</a>, <a class="el" href="synch_8c_source.html#l00168">xnsynch_sleep_on()</a>, and <a class="el" href="include_2nucleus_2thread_8h_source.html#l00110">XNTIMEO</a>.</p>

</div>
</div>
<a class="anchor" id="ga585bcffb3757845534eed69edd1a27d2"></a><!-- doxytag: member="task.c::rt_task_remove_hook" ref="ga585bcffb3757845534eed69edd1a27d2" args="(int type, void(*routine)(void *cookie))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_remove_hook </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *cookie)&nbsp;</td>
          <td class="paramname"> <em>routine</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a task hook. </p>
<p>This service allows to remove a task hook previously registered using <a class="el" href="group__task.html#ga7452f367f9e17bf2fc0b70f717b96dd8" title="Install a task hook.">rt_task_add_hook()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>Defines the kind of hook to uninstall. Possible values are:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>T_HOOK_START</li>
<li>T_HOOK_DELETE</li>
<li>T_HOOK_SWITCH</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>routine</em>&nbsp;</td><td>The address of the user-supplied routine to remove from the hook list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise, one of the following error codes indicates the cause of the failure:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>type</em> is incorrect.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
</ul>
<p>Rescheduling: never. </p>

<p>References <a class="el" href="pod_8c_source.html#l02838">xnpod_remove_hook()</a>.</p>

</div>
</div>
<a class="anchor" id="gacd8a4fb2d11f0548bd053dfbf92f9e9d"></a><!-- doxytag: member="task.c::rt_task_reply" ref="gacd8a4fb2d11f0548bd053dfbf92f9e9d" args="(int flowid, RT_TASK_MCB *mcb_s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_reply </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flowid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrt__task__mcb.html">RT_TASK_MCB</a> *&nbsp;</td>
          <td class="paramname"> <em>mcb_s</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reply to a task. </p>
<p>This service is part of the synchronous message passing support available to Xenomai tasks. It allows the caller to send back a variable-sized message to the client task, once the initial message from this task has been pulled using <a class="el" href="group__task.html#gaa152f8f41876fc3a828a8eba74d493fe" title="Receive a message from a task.">rt_task_receive()</a> and processed. As a consequence of this call, the remote task will be unblocked from the <a class="el" href="group__task.html#ga99a89c21c9866e2784860e100a444b49" title="Send a message to a task.">rt_task_send()</a> service.</p>
<p>A basic message control block is used to store the location and size of the data area to send back, in addition to a user-defined status code.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flowid</em>&nbsp;</td><td>The flow identifier returned by a previous call to <a class="el" href="group__task.html#gaa152f8f41876fc3a828a8eba74d493fe" title="Receive a message from a task.">rt_task_receive()</a> which uniquely identifies the current transaction.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mcb_s</em>&nbsp;</td><td>The address of an optional message control block referring to the message to be sent back. If <em>mcb_s</em> is NULL, the client will be unblocked without getting any reply data. When <em>mcb_s</em> is valid, the fields from this control block should be set as follows:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>mcb_s-&gt;data should contain the address of the payload data to send to the remote task.</li>
</ul>
<ul>
<li>mcb_s-&gt;size should contain the size in bytes of the payload data pointed at by mcb_s-&gt;data. 0 is a legitimate value, and indicates that no payload data will be transferred. In the latter case, mcb_s-&gt;data will be ignored. See note.</li>
</ul>
<ul>
<li>mcb_s-&gt;opcode is an opaque status code carried during the message transfer the caller can fill with any appropriate value. It will be made available "as is" to the remote task into the status code field by the <a class="el" href="group__task.html#ga99a89c21c9866e2784860e100a444b49" title="Send a message to a task.">rt_task_send()</a> service. If <em>mcb_s</em> is NULL, 0 will be returned to the client into the status code field.</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>O is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-ENXIO is returned if <em>flowid</em> does not match the expected identifier returned from the latest call of the current task to <a class="el" href="group__task.html#gaa152f8f41876fc3a828a8eba74d493fe" title="Receive a message from a task.">rt_task_receive()</a>, or if the remote task stopped waiting for the reply in the meantime (e.g. the client could have been deleted or forcibly unblocked).</li>
</ul>
<ul>
<li>-EPERM is returned if this service was called from an invalid context (e.g. interrupt, or non-primary).</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel-based task</li>
<li>User-space task (switches to primary mode)</li>
</ul>
<p>Rescheduling: Always.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>When called from a user-space task, this service may need to allocate some temporary buffer space from the system heap to hold the reply data if the size of the latter exceeds a certain amount; the threshold before allocation is currently set to 64 bytes. </dd></dl>

<p>References <a class="el" href="task_8h_source.html#l00114">rt_task_mcb::data</a>, <a class="el" href="task_8h_source.html#l00112">rt_task_mcb::opcode</a>, <a class="el" href="task_8h_source.html#l00116">rt_task_mcb::size</a>, <a class="el" href="include_2nucleus_2thread_8h_source.html#l00034">XNPEND</a>, <a class="el" href="pod_8c_source.html#l01562">xnpod_resume_thread()</a>, and <a class="el" href="pod_8c_source.html#l02379">xnpod_schedule()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1fab1aa24ef6f199546fd9669ae711be"></a><!-- doxytag: member="task.c::rt_task_resume" ref="ga1fab1aa24ef6f199546fd9669ae711be" args="(RT_TASK *task)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_resume </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&nbsp;</td>
          <td class="paramname"> <em>task</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resume a real-time task. </p>
<p>Forcibly resume the execution of a task which has been previously suspended by a call to <a class="el" href="group__task.html#ga926a4b10e3631f76c5f38910e6eea24c" title="Suspend a real-time task.">rt_task_suspend()</a>.</p>
<p>The suspension nesting count is decremented so that <a class="el" href="group__task.html#ga1fab1aa24ef6f199546fd9669ae711be" title="Resume a real-time task.">rt_task_resume()</a> will only resume the task if this count falls down to zero as a result of the current invocation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>The descriptor address of the affected task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>task</em> is not a task descriptor.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>task</em> is a deleted task descriptor.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: possible if the suspension nesting level falls down to zero as a result of the current invocation. </p>

<p>References <a class="el" href="pod_8c_source.html#l01562">xnpod_resume_thread()</a>, <a class="el" href="pod_8c_source.html#l02379">xnpod_schedule()</a>, and <a class="el" href="include_2nucleus_2thread_8h_source.html#l00033">XNSUSP</a>.</p>

</div>
</div>
<a class="anchor" id="gaaf5467af966c9980da9e489aeacf9aa3"></a><!-- doxytag: member="task.c::rt_task_self" ref="gaaf5467af966c9980da9e489aeacf9aa3" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RT_TASK* rt_task_self </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve the current task. </p>
<p>Return the current task descriptor address.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The address of the caller's task descriptor is returned upon success, or NULL if the calling context is asynchronous (i.e. not a Xenomai task).</dd></dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine Those will cause a NULL return.</li>
</ul>
<ul>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: never. </p>

<p>References <a class="el" href="tsd_8c_source.html#l00215">pthread_getspecific()</a>, and <a class="el" href="tsd_8c_source.html#l00174">pthread_setspecific()</a>.</p>

</div>
</div>
<a class="anchor" id="ga99a89c21c9866e2784860e100a444b49"></a><!-- doxytag: member="task.c::rt_task_send" ref="ga99a89c21c9866e2784860e100a444b49" args="(RT_TASK *task, RT_TASK_MCB *mcb_s, RT_TASK_MCB *mcb_r, RTIME timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_task_send </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&nbsp;</td>
          <td class="paramname"> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrt__task__mcb.html">RT_TASK_MCB</a> *&nbsp;</td>
          <td class="paramname"> <em>mcb_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrt__task__mcb.html">RT_TASK_MCB</a> *&nbsp;</td>
          <td class="paramname"> <em>mcb_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send a message to a task. </p>
<p>This service is part of the synchronous message passing support available to Xenomai tasks. It allows the caller to send a variable-sized message to another task, waiting for the remote to receive the initial message by a call to <a class="el" href="group__task.html#gaa152f8f41876fc3a828a8eba74d493fe" title="Receive a message from a task.">rt_task_receive()</a>, then reply to it using <a class="el" href="group__task.html#gacd8a4fb2d11f0548bd053dfbf92f9e9d" title="Reply to a task.">rt_task_reply()</a>.</p>
<p>A basic message control block is used to store the location and size of the data area to send or retrieve upon reply, in addition to a user-defined operation code.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>The descriptor address of the recipient task.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mcb_s</em>&nbsp;</td><td>The address of the message control block referring to the message to be sent. The fields from this control block should be set as follows:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>mcb_s-&gt;data should contain the address of the payload data to send to the remote task.</li>
</ul>
<ul>
<li>mcb_s-&gt;size should contain the size in bytes of the payload data pointed at by mcb_s-&gt;data. 0 is a legitimate value, and indicates that no payload data will be transferred. In the latter case, mcb_s-&gt;data will be ignored. See note.</li>
</ul>
<ul>
<li>mcb_s-&gt;opcode is an opaque operation code carried during the message transfer the caller can fill with any appropriate value. It will be made available "as is" to the remote task into the operation code field by the <a class="el" href="group__task.html#gaa152f8f41876fc3a828a8eba74d493fe" title="Receive a message from a task.">rt_task_receive()</a> service.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mcb_r</em>&nbsp;</td><td>The address of an optional message control block referring to the reply message area. If <em>mcb_r</em> is NULL and a reply is sent back by the remote task, the reply message will be discarded, and -ENOBUFS will be returned to the caller. When <em>mcb_r</em> is valid, the fields from this control block should be set as follows:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>mcb_r-&gt;data should contain the address of a buffer large enough to collect the reply data from the remote task.</li>
</ul>
<ul>
<li>mcb_r-&gt;size should contain the size in bytes of the buffer space pointed at by mcb_r-&gt;data. If mcb_r-&gt;size is lower than the actual size of the reply message, no data copy takes place and -ENOBUFS is returned to the caller. See note.</li>
</ul>
<p>Upon return, mcb_r-&gt;opcode will contain the status code sent back from the remote task using <a class="el" href="group__task.html#gacd8a4fb2d11f0548bd053dfbf92f9e9d" title="Reply to a task.">rt_task_reply()</a>, or 0 if unspecified.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The number of clock ticks to wait for the remote task to reply to the initial message (see note). Passing TM_INFINITE causes the caller to block indefinitely until the remote task eventually replies. Passing TM_NONBLOCK causes the service to return immediately without waiting if the remote task is not waiting for messages (i.e. if <em>task</em> is not currently blocked on the <a class="el" href="group__task.html#gaa152f8f41876fc3a828a8eba74d493fe" title="Receive a message from a task.">rt_task_receive()</a> service); however, the caller will wait indefinitely for a reply from that remote task if present.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A positive value is returned upon success, representing the length (in bytes) of the reply message returned by the remote task. 0 is a success status, meaning either that <em>mcb_r</em> was NULL on entry, or that no actual message was passed to the remote call to <a class="el" href="group__task.html#gacd8a4fb2d11f0548bd053dfbf92f9e9d" title="Reply to a task.">rt_task_reply()</a>. Otherwise:</dd></dl>
<ul>
<li>-ENOBUFS is returned if <em>mcb_r</em> does not point at a message area large enough to collect the remote task's reply. This includes the case where <em>mcb_r</em> is NULL on entry albeit the remote task attempts to send a reply message.</li>
</ul>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to TM_NONBLOCK and <em>task</em> is not currently blocked on the <a class="el" href="group__task.html#gaa152f8f41876fc3a828a8eba74d493fe" title="Receive a message from a task.">rt_task_receive()</a> service.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>task</em> has been deleted while waiting for a reply.</li>
</ul>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task.">rt_task_unblock()</a> has been called for the caller before any reply was available.</li>
</ul>
<ul>
<li>-EPERM is returned if this service should block, but was called from a context which cannot sleep (e.g. interrupt, non-realtime or scheduler locked).</li>
</ul>
<ul>
<li>-ESRCH is returned if <em>task</em> cannot be found (when called from user-space only).</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel-based task</li>
<li>User-space task (switches to primary mode)</li>
</ul>
<p>Rescheduling: Always.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The <em>timeout</em> value will be interpreted as jiffies if the native skin is bound to a periodic time base (see CONFIG_XENO_OPT_NATIVE_PERIOD), or nanoseconds otherwise.</dd>
<dd>
When called from a user-space task, this service may need to allocate some temporary buffer space from the system heap to hold both the sent and the reply data if this cumulated size exceeds a certain amount; the threshold before allocation is currently set to 64 bytes. </dd></dl>

<p>References <a class="el" href="task_8h_source.html#l00114">rt_task_mcb::data</a>, <a class="el" href="task_8h_source.html#l00110">rt_task_mcb::flowid</a>, <a class="el" href="task_8h_source.html#l00112">rt_task_mcb::opcode</a>, <a class="el" href="task_8h_source.html#l00116">rt_task_mcb::size</a>, <a class="el" href="include_2nucleus_2thread_8h_source.html#l00112">XNBREAK</a>, <a class="el" href="include_2nucleus_2thread_8h_source.html#l00111">XNRMID</a>, <a class="el" href="synch_8c_source.html#l00571">xnsynch_flush()</a>, <a class="el" href="synch_8c_source.html#l00168">xnsynch_sleep_on()</a>, and <a class="el" href="include_2nucleus_2thread_8h_source.html#l00110">XNTIMEO</a>.</p>

</div>
</div>
<a class="anchor" id="ga915e7edfb0aaddb643794d7abc7093bf"></a><!-- doxytag: member="task.c::rt_task_set_mode" ref="ga915e7edfb0aaddb643794d7abc7093bf" args="(int clrmask, int setmask, int *mode_r)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_set_mode </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>clrmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>setmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>mode_r</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change task mode bits. </p>
<p>Each Xenomai task has a set of internal bits determining various operating conditions; the <a class="el" href="group__task.html#ga915e7edfb0aaddb643794d7abc7093bf" title="Change task mode bits.">rt_task_set_mode()</a> service allows to alter three of them, respectively controlling:</p>
<ul>
<li>whether the task locks the rescheduling procedure,</li>
<li>whether the task undergoes a round-robin scheduling,</li>
<li>whether the task blocks the delivery of signals.</li>
</ul>
<p>To this end, <a class="el" href="group__task.html#ga915e7edfb0aaddb643794d7abc7093bf" title="Change task mode bits.">rt_task_set_mode()</a> takes a bitmask of mode bits to clear for disabling the corresponding modes, and another one to set for enabling them. The mode bits which were previously in effect can be returned upon request.</p>
<p>The following bits can be part of the bitmask:</p>
<ul>
<li>T_LOCK causes the current task to lock the scheduler. Clearing this bit unlocks the scheduler.</li>
</ul>
<ul>
<li>T_RRB causes the current task to be marked as undergoing the round-robin scheduling policy. If the task is already undergoing the round-robin scheduling policy at the time this service is called, the time quantum remains unchanged.</li>
</ul>
<ul>
<li>T_NOSIG disables the asynchronous signal delivery for the current task.</li>
</ul>
<ul>
<li>T_SHIELD enables the interrupt shield for the current user-space task. When engaged, the interrupt shield protects the Xenomai task running in secondary mode from any preemption by the regular Linux interrupt handlers, without delaying in any way the Xenomai interrupt handling. The shield is operated on a per-task basis at each context switch, depending on the setting of this flag. This flag is cleared by default for new user-space tasks. This feature is only available if the CONFIG_XENO_OPT_ISHIELD option has been enabled at configuration time; otherwise, this flag is simply ignored.</li>
</ul>
<ul>
<li>When set, T_WARNSW causes the SIGXCPU signal to be sent to the current user-space task whenever it switches to the secondary mode. This feature is useful to detect unwanted migrations to the Linux domain.</li>
</ul>
<ul>
<li>T_RPIOFF disables thread priority coupling between Xenomai and Linux schedulers. This bit prevents the root Linux thread from inheriting the priority of the running shadow Xenomai thread. Use CONFIG_XENO_OPT_RPIOFF to globally disable priority coupling.</li>
</ul>
<ul>
<li>T_PRIMARY can be passed to switch the current user-space task to primary mode (setmask |= T_PRIMARY), or secondary mode (clrmask |= T_PRIMARY). Upon return from <a class="el" href="group__task.html#ga915e7edfb0aaddb643794d7abc7093bf" title="Change task mode bits.">rt_task_set_mode()</a>, the user-space task will run into the specified domain.</li>
</ul>
<p>Normally, this service can only be called on behalf of a regular real-time task, either running in kernel or user-space. However, as a special exception, requests for setting/clearing the T_LOCK bit from asynchronous contexts are silently dropped, and the call returns successfully if no other mode bits have been specified. This is consistent with the fact that Xenomai enforces a scheduler lock until the outer interrupt handler has returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clrmask</em>&nbsp;</td><td>A bitmask of mode bits to clear for the current task, before <em>setmask</em> is applied. 0 is an acceptable value which leads to a no-op.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>setmask</em>&nbsp;</td><td>A bitmask of mode bits to set for the current task. 0 is an acceptable value which leads to a no-op.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode_r</em>&nbsp;</td><td>If non-NULL, <em>mode_r</em> must be a pointer to a memory location which will be written upon success with the previous set of active mode bits. If NULL, the previous set of active mode bits will not be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success, or:</dd></dl>
<ul>
<li>-EINVAL if either <em>setmask</em> or <em>clrmask</em> specifies invalid bits. T_PRIMARY is invalid for kernel-based tasks.</li>
</ul>
<ul>
<li>-EPERM is returned if this service was not called from a real-time task context.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: possible, if T_LOCK has been passed into <em>clrmask</em> and the calling context is a task. </p>

<p>References <a class="el" href="task_8h_source.html#l00049">T_LOCK</a>, <a class="el" href="task_8h_source.html#l00051">T_NOSIG</a>, <a class="el" href="task_8h_source.html#l00050">T_RRB</a>, <a class="el" href="task_8h_source.html#l00052">T_SHIELD</a>, <a class="el" href="task_8h_source.html#l00053">T_WARNSW</a>, <a class="el" href="pod_8c_source.html#l02379">xnpod_schedule()</a>, and <a class="el" href="pod_8c_source.html#l01038">xnpod_set_thread_mode()</a>.</p>

</div>
</div>
<a class="anchor" id="gababee94264156693cd4f5b9b70d3c5a1"></a><!-- doxytag: member="task.c::rt_task_set_periodic" ref="gababee94264156693cd4f5b9b70d3c5a1" args="(RT_TASK *task, RTIME idate, RTIME period)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_set_periodic </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&nbsp;</td>
          <td class="paramname"> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&nbsp;</td>
          <td class="paramname"> <em>idate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&nbsp;</td>
          <td class="paramname"> <em>period</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a real-time task periodic. </p>
<p>Make a task periodic by programing its first release point and its period in the processor time line. Subsequent calls to <a class="el" href="group__task.html#ga1645d3a072ef3cefeed3bcbb27dcf108" title="Wait for the next periodic release point.">rt_task_wait_period()</a> will delay the task until the next periodic release point in the processor timeline is reached.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>The descriptor address of the affected task. This task is immediately delayed until the first periodic release point is reached. If <em>task</em> is NULL, the current task is set periodic.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>idate</em>&nbsp;</td><td>The initial (absolute) date of the first release point, expressed in clock ticks (see note). The affected task will be delayed until this point is reached. If <em>idate</em> is equal to TM_NOW, the current system date is used, and no initial delay takes place.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>period</em>&nbsp;</td><td>The period of the task, expressed in clock ticks (see note). Passing TM_INFINITE attempts to stop the task's periodic timer; in the latter case, the routine always exits succesfully, regardless of the previous state of this timer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>task</em> is not a task descriptor, or <em>period</em> is different from TM_INFINITE but shorter than the scheduling latency value for the target system, as available from /proc/xenomai/latency.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>task</em> is a deleted task descriptor.</li>
</ul>
<ul>
<li>-ETIMEDOUT is returned if <em>idate</em> is different from TM_INFINITE and represents a date in the past.</li>
</ul>
<ul>
<li>-EWOULDBLOCK is returned if the system timer is not active.</li>
</ul>
<ul>
<li>-EPERM is returned if <em>task</em> is NULL but not called from a task context.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code or interrupt only if <em>task</em> is non-NULL.</li>
</ul>
<ul>
<li>Kernel-based task</li>
<li>User-space task (switches to primary mode)</li>
</ul>
<p>Rescheduling: always if the operation affects the current task and <em>idate</em> has not elapsed yet.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The <em>idate</em> and <em>period</em> values will be interpreted as jiffies if the native skin is bound to a periodic time base (see CONFIG_XENO_OPT_NATIVE_PERIOD), or nanoseconds otherwise. </dd></dl>

<p>References <a class="el" href="pod_8c_source.html#l03244">xnpod_set_thread_periodic()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3bed8d001e212a3328a4e7e73f1765e8"></a><!-- doxytag: member="task.c::rt_task_set_priority" ref="ga3bed8d001e212a3328a4e7e73f1765e8" args="(RT_TASK *task, int prio)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_set_priority </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&nbsp;</td>
          <td class="paramname"> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>prio</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the base priority of a real-time task. </p>
<p>Changing the base priority of a task does not affect the priority boost the target task might have obtained as a consequence of a previous priority inheritance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>The descriptor address of the affected task.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prio</em>&nbsp;</td><td>The new task priority. This value must range from [1 .. 99] (inclusive) where 1 is the lowest effective priority.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>task</em> is not a task descriptor, or if <em>prio</em> is invalid.</li>
</ul>
<ul>
<li>-EPERM is returned if <em>task</em> is NULL but not called from a task context.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>task</em> is a deleted task descriptor.</li>
</ul>
<p>Side-effects:</p>
<ul>
<li>This service calls the rescheduling procedure.</li>
</ul>
<ul>
<li>Assigning the same priority to a running or ready task moves it to the end of its priority group, thus causing a manual round-robin.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine only if <em>task</em> is non-NULL.</li>
</ul>
<ul>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: possible if <em>task</em> is the current one. </p>

<p>References <a class="el" href="pod_8c_source.html#l01786">xnpod_renice_thread()</a>, and <a class="el" href="pod_8c_source.html#l02379">xnpod_schedule()</a>.</p>

</div>
</div>
<a class="anchor" id="ga72e0a9355d06c346a95bf88b857a9749"></a><!-- doxytag: member="task.h::rt_task_shadow" ref="ga72e0a9355d06c346a95bf88b857a9749" args="(RT_TASK *task, const char *name, int prio, int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_shadow </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&nbsp;</td>
          <td class="paramname"> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>prio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Turns the current Linux task into a native Xenomai task. </p>
<p>Creates a real-time task running in the context of the calling regular Linux task in user-space.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>The address of a task descriptor Xenomai will use to store the task-related data. This descriptor must always be valid while the task is active therefore it must be allocated in permanent memory.</td></tr>
  </table>
  </dd>
</dl>
<p>The current context is switched to primary execution mode and returns immediately, unless T_SUSP has been passed in the <em>mode</em> parameter.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>An ASCII string standing for the symbolic name of the task. When non-NULL and non-empty, this string is copied to a safe place into the descriptor, and passed to the registry package if enabled for indexing the created task.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prio</em>&nbsp;</td><td>The base priority which will be set for the current task. This value must range from [1 .. 99] (inclusive) where 1 is the lowest effective priority.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>The task creation mode. The following flags can be OR'ed into this bitmask, each of them affecting the new task:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>T_FPU allows the task to use the FPU whenever available on the platform. This flag is forced for this call, therefore it can be omitted.</li>
</ul>
<ul>
<li>T_SUSP causes the task to enter the suspended mode after it has been put under Xenomai's control. In such a case, a call to <a class="el" href="group__task.html#ga1fab1aa24ef6f199546fd9669ae711be" title="Resume a real-time task.">rt_task_resume()</a> will be needed to wake up the current task.</li>
</ul>
<ul>
<li>T_CPU(cpuid) makes the current task affine to CPU # <b>cpuid</b>. CPU identifiers range from 0 to RTHAL_NR_CPUS - 1 (inclusive). The calling task will migrate to another processor before this service returns if the current one is not part of the CPU affinity mask.</li>
</ul>
<p>Passing T_CPU(0)|T_CPU(1) in the <em>mode</em> parameter thus defines a task affine to CPUs #0 and #1.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EBUSY is returned if the current Linux task is already mapped to a Xenomai context.</li>
</ul>
<ul>
<li>-ENOMEM is returned if the system fails to get enough dynamic memory from the global real-time heap in order to create or register the task.</li>
</ul>
<ul>
<li>-EEXIST is returned if the <em>name</em> is already in use by some registered object.</li>
</ul>
<ul>
<li>-EPERM is returned if this service was called from an asynchronous context.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>User-space task (enters primary mode)</li>
</ul>
<p>Rescheduling: possible. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="rtcanrecv_8c-example.html#a26">rtcanrecv.c</a>, and <a class="el" href="rtcansend_8c-example.html#a22">rtcansend.c</a>.</dd>
</dl>
<p>References <a class="el" href="skins_2posix_2thread_8c_source.html#l00508">pthread_self()</a>, and <a class="el" href="cancel_8c_source.html#l00279">pthread_setcanceltype()</a>.</p>

</div>
</div>
<a class="anchor" id="gad5225e5fb8d583fbdfa5299f322b8366"></a><!-- doxytag: member="task.c::rt_task_sleep" ref="gad5225e5fb8d583fbdfa5299f322b8366" args="(RTIME delay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_sleep </td>
          <td>(</td>
          <td class="paramtype">RTIME&nbsp;</td>
          <td class="paramname"> <em>delay</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delay the calling task (relative). </p>
<p>Delay the execution of the calling task for a number of internal clock ticks.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>delay</em>&nbsp;</td><td>The number of clock ticks to wait before resuming the task (see note). Passing zero causes the task to return immediately with no delay.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task.">rt_task_unblock()</a> has been called for the sleeping task before the sleep time has elapsed.</li>
</ul>
<ul>
<li>-EWOULDBLOCK is returned if the system timer is inactive.</li>
</ul>
<ul>
<li>-EPERM is returned if this service was called from a context which cannot sleep (e.g. interrupt, non-realtime or scheduler locked).</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel-based task</li>
<li>User-space task (switches to primary mode)</li>
</ul>
<p>Rescheduling: always unless a null delay is given.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The <em>delay</em> value will be interpreted as jiffies if the native skin is bound to a periodic time base (see CONFIG_XENO_OPT_NATIVE_PERIOD), or nanoseconds otherwise. </dd></dl>

<p>References <a class="el" href="include_2nucleus_2thread_8h_source.html#l00112">XNBREAK</a>, <a class="el" href="include_2nucleus_2thread_8h_source.html#l00035">XNDELAY</a>, and <a class="el" href="pod_8c_source.html#l01363">xnpod_suspend_thread()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0dc2deebe7500c9d21ff05d51d5efaa8"></a><!-- doxytag: member="task.c::rt_task_sleep_until" ref="ga0dc2deebe7500c9d21ff05d51d5efaa8" args="(RTIME date)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_sleep_until </td>
          <td>(</td>
          <td class="paramtype">RTIME&nbsp;</td>
          <td class="paramname"> <em>date</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delay the calling task (absolute). </p>
<p>Delay the execution of the calling task until a given date is reached.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>date</em>&nbsp;</td><td>The absolute date in clock ticks to wait before resuming the task (see note). As a special case, TM_INFINITE is an acceptable value that makes the caller block indefinitely, until <a class="el" href="group__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task.">rt_task_unblock()</a> is called against it. Otherwise, any wake up date in the past causes the task to return immediately with no delay.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task.">rt_task_unblock()</a> has been called for the sleeping task before the sleep time has elapsed.</li>
</ul>
<ul>
<li>-ETIMEDOUT is returned if <em>date</em> has already elapsed.</li>
</ul>
<ul>
<li>-EWOULDBLOCK is returned if the system timer is inactive, and <dl class="date"><dt><b>Date:</b></dt><dd>is valid but different from TM_INFINITE.</dd></dl>
</li>
<li>-EPERM is returned if this service was called from a context which cannot sleep (e.g. interrupt, non-realtime or scheduler locked).</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel-based task</li>
<li>User-space task (switches to primary mode)</li>
</ul>
<p>Rescheduling: always unless a date in the past is given.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The <em>date</em> value will be interpreted as jiffies if the native skin is bound to a periodic time base (see CONFIG_XENO_OPT_NATIVE_PERIOD), or nanoseconds otherwise. </dd></dl>

<p>References <a class="el" href="include_2nucleus_2thread_8h_source.html#l00112">XNBREAK</a>, <a class="el" href="include_2nucleus_2thread_8h_source.html#l00035">XNDELAY</a>, <a class="el" href="pod_8c_source.html#l01363">xnpod_suspend_thread()</a>, and <a class="el" href="timebase_8h_source.html#l00344">xntbase_get_time()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9250436d7bd9e49a0320161d2e9373ae"></a><!-- doxytag: member="task.c::rt_task_slice" ref="ga9250436d7bd9e49a0320161d2e9373ae" args="(RT_TASK *task, RTIME quantum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_slice </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&nbsp;</td>
          <td class="paramname"> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&nbsp;</td>
          <td class="paramname"> <em>quantum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a task's round-robin quantum. </p>
<p>Set the time credit allotted to a task undergoing the round-robin scheduling. As a side-effect, <a class="el" href="group__task.html#ga9250436d7bd9e49a0320161d2e9373ae" title="Set a task&#39;s round-robin quantum.">rt_task_slice()</a> refills the current quantum of the target task.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>The descriptor address of the affected task. If <em>task</em> is NULL, the current task is considered.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>quantum</em>&nbsp;</td><td>The round-robin quantum for the task expressed in clock ticks (see note).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>task</em> is not a task descriptor, or if <em>quantum</em> is zero.</li>
</ul>
<ul>
<li>-ENODEV is returned if the native skin is not bound to a periodic time base (see CONFIG_XENO_OPT_NATIVE_PERIOD), in which case round-robin scheduling is not available.</li>
</ul>
<ul>
<li>-EPERM is returned if <em>task</em> is NULL but not called from a task context.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine only if <em>task</em> is non-NULL.</li>
</ul>
<ul>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: never.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The <em>quantum</em> value is always interpreted as a count of jiffies. </dd></dl>

</div>
</div>
<a class="anchor" id="ga520e6fad1decc5beff58b394ff443265"></a><!-- doxytag: member="task.h::rt_task_spawn" ref="ga520e6fad1decc5beff58b394ff443265" args="(RT_TASK *task, const char *name, int stksize, int prio, int mode, void(*entry)(void *cookie), void *cookie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_spawn </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&nbsp;</td>
          <td class="paramname"> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>stksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>prio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *cookie)&nbsp;</td>
          <td class="paramname"> <em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cookie</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Spawn a new real-time task. </p>
<p>Creates and immediately starts a real-time task, either running in a kernel module or in user-space depending on the caller's context. This service is a simple shorthand for <a class="el" href="group__task.html#ga03387550693c21d0223f739570ccd992" title="Create a new real-time task.">rt_task_create()</a> followed by a call to <a class="el" href="group__task.html#gac9638918b8310a430088f5c9a04d2bb7" title="Start a real-time task.">rt_task_start()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>The address of a task descriptor Xenomai will use to store the task-related data. This descriptor must always be valid while the task is active therefore it must be allocated in permanent memory.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>An ASCII string standing for the symbolic name of the task. When non-NULL and non-empty, this string is copied to a safe place into the descriptor, and passed to the registry package if enabled for indexing the created task.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stksize</em>&nbsp;</td><td>The size of the stack (in bytes) for the new task. If zero is passed, a reasonable pre-defined size will be substituted.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prio</em>&nbsp;</td><td>The base priority of the new task. This value must range from [1 .. 99] (inclusive) where 1 is the lowest effective priority.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>The task creation mode. The following flags can be OR'ed into this bitmask, each of them affecting the new task:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>T_FPU allows the task to use the FPU whenever available on the platform. This flag is forced for user-space tasks.</li>
</ul>
<ul>
<li>T_SUSP causes the task to start in suspended mode. In such a case, the thread will have to be explicitly resumed using the <a class="el" href="group__task.html#ga1fab1aa24ef6f199546fd9669ae711be" title="Resume a real-time task.">rt_task_resume()</a> service for its execution to actually begin.</li>
</ul>
<ul>
<li>T_CPU(cpuid) makes the new task affine to CPU # <b>cpuid</b>. CPU identifiers range from 0 to RTHAL_NR_CPUS - 1 (inclusive).</li>
</ul>
<ul>
<li>T_JOINABLE (user-space only) allows another task to wait on the termination of the new task. This implies that <a class="el" href="group__task.html#ga8c77d57638578a126812e29429f61fe7" title="Wait on the termination of a real-time task.">rt_task_join()</a> is actually called for this task to clean up any user-space located resources after its termination.</li>
</ul>
<p>Passing T_FPU|T_CPU(1) in the <em>mode</em> parameter thus creates a task with FPU support enabled and which will be affine to CPU #1.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>entry</em>&nbsp;</td><td>The address of the task's body routine. In other words, it is the task entry point.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cookie</em>&nbsp;</td><td>A user-defined opaque cookie the real-time kernel will pass to the emerging task as the sole argument of its entry point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-ENOMEM is returned if the system fails to get enough dynamic memory from the global real-time heap in order to create the new task's stack space or register the task.</li>
</ul>
<ul>
<li>-EEXIST is returned if the <em>name</em> is already in use by some registered object.</li>
</ul>
<ul>
<li>-EPERM is returned if this service was called from an asynchronous context.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: possible. </p>

<p>References <a class="el" href="src_2skins_2native_2task_8c_source.html#l00107">rt_task_create()</a>, and <a class="el" href="src_2skins_2native_2task_8c_source.html#l00159">rt_task_start()</a>.</p>

</div>
</div>
<a class="anchor" id="gac9638918b8310a430088f5c9a04d2bb7"></a><!-- doxytag: member="task.c::rt_task_start" ref="gac9638918b8310a430088f5c9a04d2bb7" args="(RT_TASK *task, void(*entry)(void *cookie), void *cookie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_start </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&nbsp;</td>
          <td class="paramname"> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *cookie)&nbsp;</td>
          <td class="paramname"> <em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cookie</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start a real-time task. </p>
<p>Start a (newly) created task, scheduling it for the first time. This call releases the target task from the dormant state.</p>
<p>The TSTART hooks are called on behalf of the calling context (if any, see <a class="el" href="group__task.html#ga7452f367f9e17bf2fc0b70f717b96dd8" title="Install a task hook.">rt_task_add_hook()</a>).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>The descriptor address of the affected task which must have been previously created by the <a class="el" href="group__task.html#ga03387550693c21d0223f739570ccd992" title="Create a new real-time task.">rt_task_create()</a> service.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>entry</em>&nbsp;</td><td>The address of the task's body routine. In other words, it is the task entry point.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cookie</em>&nbsp;</td><td>A user-defined opaque cookie the real-time kernel will pass to the emerging task as the sole argument of its entry point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>task</em> is not a task descriptor.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>task</em> is a deleted task descriptor.</li>
</ul>
<ul>
<li>-EBUSY is returned if <em>task</em> is already started.</li>
</ul>
<ul>
<li>-EPERM is returned if this service was called from an asynchronous context.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: possible. </p>

<p>References <a class="el" href="include_2nucleus_2thread_8h_source.html#l00037">XNDORMANT</a>, and <a class="el" href="pod_8c_source.html#l00797">xnpod_start_thread()</a>.</p>

<p>Referenced by <a class="el" href="task_8h_source.html#l00314">rt_task_spawn()</a>.</p>

</div>
</div>
<a class="anchor" id="ga926a4b10e3631f76c5f38910e6eea24c"></a><!-- doxytag: member="task.c::rt_task_suspend" ref="ga926a4b10e3631f76c5f38910e6eea24c" args="(RT_TASK *task)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_suspend </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&nbsp;</td>
          <td class="paramname"> <em>task</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Suspend a real-time task. </p>
<p>Forcibly suspend the execution of a task. This task will not be eligible for scheduling until it is explicitly resumed by a call to <a class="el" href="group__task.html#ga1fab1aa24ef6f199546fd9669ae711be" title="Resume a real-time task.">rt_task_resume()</a>. In other words, the suspended state caused by a call to <a class="el" href="group__task.html#ga926a4b10e3631f76c5f38910e6eea24c" title="Suspend a real-time task.">rt_task_suspend()</a> is cumulative with respect to the delayed and blocked states caused by other services, and is managed separately from them.</p>
<p>A nesting count is maintained so that <a class="el" href="group__task.html#ga926a4b10e3631f76c5f38910e6eea24c" title="Suspend a real-time task.">rt_task_suspend()</a> and <a class="el" href="group__task.html#ga1fab1aa24ef6f199546fd9669ae711be" title="Resume a real-time task.">rt_task_resume()</a> must be used in pairs.</p>
<p>Receiving a Linux signal causes the suspended task to resume immediately.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>The descriptor address of the affected task. If <em>task</em> is NULL, the current task is suspended.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if a Linux signal has been received by the suspended task.</li>
</ul>
<ul>
<li>-EINVAL is returned if <em>task</em> is not a task descriptor.</li>
</ul>
<ul>
<li>-EPERM is returned if the addressed <em>task</em> is not allowed to sleep (i.e. scheduler locked).</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>task</em> is a deleted task descriptor.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine only if <em>task</em> is non-NULL.</li>
</ul>
<ul>
<li>Kernel-based task</li>
<li>User-space task (switches to primary mode)</li>
</ul>
<p>Rescheduling: always if <em>task</em> is NULL. </p>

<p>References <a class="el" href="include_2nucleus_2thread_8h_source.html#l00112">XNBREAK</a>, <a class="el" href="include_2nucleus_2thread_8h_source.html#l00047">XNLOCK</a>, <a class="el" href="pod_8c_source.html#l01363">xnpod_suspend_thread()</a>, and <a class="el" href="include_2nucleus_2thread_8h_source.html#l00033">XNSUSP</a>.</p>

</div>
</div>
<a class="anchor" id="ga2038cbe2350a8e2558330a3f45953865"></a><!-- doxytag: member="task.h::rt_task_unbind" ref="ga2038cbe2350a8e2558330a3f45953865" args="(RT_TASK *task)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_unbind </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&nbsp;</td>
          <td class="paramname"> <em>task</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unbind from a real-time task. </p>
<p>This user-space only service unbinds the calling task from the task object previously retrieved by a call to <a class="el" href="group__task.html#gab6bd973c22a6f66e28653922c53e0385" title="Bind to a real-time task.">rt_task_bind()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>The address of a task descriptor to unbind from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is always returned.</dd></dl>
<p>This service can be called from:</p>
<ul>
<li>User-space task.</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="ga770281eeca009c0a08a7c4a9fd849ac1"></a><!-- doxytag: member="task.c::rt_task_unblock" ref="ga770281eeca009c0a08a7c4a9fd849ac1" args="(RT_TASK *task)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_unblock </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&nbsp;</td>
          <td class="paramname"> <em>task</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unblock a real-time task. </p>
<p>Break the task out of any wait it is currently in. This call clears all delay and/or resource wait condition for the target task. However, <a class="el" href="group__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task.">rt_task_unblock()</a> does not resume a task which has been forcibly suspended by a previous call to <a class="el" href="group__task.html#ga926a4b10e3631f76c5f38910e6eea24c" title="Suspend a real-time task.">rt_task_suspend()</a>. If all suspensive conditions are gone, the task becomes eligible anew for scheduling.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>The descriptor address of the affected task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>task</em> is not a task descriptor.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>task</em> is a deleted task descriptor.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: possible. </p>

<p>References <a class="el" href="pod_8c_source.html#l02379">xnpod_schedule()</a>, and <a class="el" href="pod_8c_source.html#l01697">xnpod_unblock_thread()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1645d3a072ef3cefeed3bcbb27dcf108"></a><!-- doxytag: member="task.c::rt_task_wait_period" ref="ga1645d3a072ef3cefeed3bcbb27dcf108" args="(unsigned long *overruns_r)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_wait_period </td>
          <td>(</td>
          <td class="paramtype">unsigned long *&nbsp;</td>
          <td class="paramname"> <em>overruns_r</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for the next periodic release point. </p>
<p>Make the current task wait for the next periodic release point in the processor time line.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>overruns_r</em>&nbsp;</td><td>If non-NULL, <em>overruns_r</em> must be a pointer to a memory location which will be written with the count of pending overruns. This value is copied only when <a class="el" href="group__task.html#ga1645d3a072ef3cefeed3bcbb27dcf108" title="Wait for the next periodic release point.">rt_task_wait_period()</a> returns -ETIMEDOUT or success; the memory location remains unmodified otherwise. If NULL, this count will never be copied back.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success; if <em>overruns_r</em> is valid, zero is copied to the pointed memory location. Otherwise:</dd></dl>
<ul>
<li>-EWOULDBLOCK is returned if <a class="el" href="group__task.html#gababee94264156693cd4f5b9b70d3c5a1" title="Make a real-time task periodic.">rt_task_set_periodic()</a> has not previously been called for the calling task.</li>
</ul>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task.">rt_task_unblock()</a> has been called for the waiting task before the next periodic release point has been reached. In this case, the overrun counter is reset too.</li>
</ul>
<ul>
<li>-ETIMEDOUT is returned if a timer overrun occurred, which indicates that a previous release point has been missed by the calling task. If <em>overruns_r</em> is valid, the count of pending overruns is copied to the pointed memory location.</li>
</ul>
<ul>
<li>-EPERM is returned if this service was called from a context which cannot sleep (e.g. interrupt, non-realtime or scheduler locked).</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel-based task</li>
<li>User-space task (switches to primary mode)</li>
</ul>
<p>Rescheduling: always, unless the current release point has already been reached. In the latter case, the current task immediately returns from this service without being delayed. </p>

<p>References <a class="el" href="pod_8c_source.html#l03343">xnpod_wait_thread_period()</a>.</p>

</div>
</div>
<a class="anchor" id="ga31e44b069b2486c2d2bdfb8a0a3557c8"></a><!-- doxytag: member="task.c::rt_task_yield" ref="ga31e44b069b2486c2d2bdfb8a0a3557c8" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_yield </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Manual round-robin. </p>
<p>Move the current task to the end of its priority group, so that the next equal-priority task in ready state is switched in.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EPERM is returned if this service was called from a context which cannot sleep (e.g. interrupt, non-realtime or scheduler locked).</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: always if a next equal-priority task is ready to run, otherwise, this service leads to a no-op. </p>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Tue Oct 27 19:18:54 2009 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
