<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Xenomai API: HAL.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1>HAL.</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Generic Adeos-based hardware abstraction layer. 
<p>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="arm_2hal_8c.html">hal.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adeos-based Real-Time Abstraction Layer for PowerPC. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="blackfin_2hal_8c.html">hal.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adeos-based Real-Time Abstraction Layer for the Blackfin architecture. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="blackfin_2nmi_8c.html">nmi.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">NMI watchdog support. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="generic_2hal_8c.html">hal.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic Real-Time HAL. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="generic_2nmi_8c.html">nmi.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adeos-based Real-Time Abstraction Layer for x86. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="i386_2hal_8c.html">hal.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adeos-based Real-Time Abstraction Layer for x86. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="i386_2nmi_8c.html">nmi.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">NMI watchdog for x86, from linux/arch/i386/kernel/nmi.c. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="smi_8c.html">smi.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SMI workaround for x86. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ia64_2hal_8c.html">hal.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adeos-based Real-Time Abstraction Layer for ia64. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="powerpc_2hal_8c.html">hal.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adeos-based Real-Time Abstraction Layer for PowerPC. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#gc7888ef10953f2a7e9e5ed087047036d">rthal_timer_request</a> (void(*handler)(void), unsigned long nstick)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Grab the hardware timer.  <a href="#gc7888ef10953f2a7e9e5ed087047036d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#gf8da29c90939e5cffd640c240e79da3e">rthal_timer_release</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release the hardware timer.  <a href="#gf8da29c90939e5cffd640c240e79da3e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#g80403d346662fcc3c960f12e4d5b8e09">rthal_irq_host_release</a> (unsigned irq, void *dev_id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uninstall a shared Linux interrupt handler.  <a href="#g80403d346662fcc3c960f12e4d5b8e09"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#g306c0dcb88589f6a84f9b9d3304c4e8e">rthal_irq_enable</a> (unsigned irq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable an interrupt source.  <a href="#g306c0dcb88589f6a84f9b9d3304c4e8e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#g615e2795b5a080f9155bf2f9f29e0b3f">rthal_irq_disable</a> (unsigned irq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable an interrupt source.  <a href="#g615e2795b5a080f9155bf2f9f29e0b3f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#gadf0f98059a5bf1caddda9dd48d51f20">rthal_irq_request</a> (unsigned irq, rthal_irq_handler_t handler, rthal_irq_ackfn_t ackfn, void *cookie)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Install a real-time interrupt handler.  <a href="#gadf0f98059a5bf1caddda9dd48d51f20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#gd7d90c5882463a1d36b7a0ad74a9d4ff">rthal_irq_release</a> (unsigned irq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uninstall a real-time interrupt handler.  <a href="#gd7d90c5882463a1d36b7a0ad74a9d4ff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#g74372309e2009faaa4d6c1e56932e9b8">rthal_irq_host_pend</a> (unsigned irq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Propagate an IRQ event to Linux.  <a href="#g74372309e2009faaa4d6c1e56932e9b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#g63c5799998ae73a818b3c3be4cca89bd">rthal_irq_affinity</a> (unsigned irq, cpumask_t cpumask, cpumask_t *oldmask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set/Get processor affinity for external interrupt.  <a href="#g63c5799998ae73a818b3c3be4cca89bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">rthal_trap_handler_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#g3f868180536815c231983781afef99c4">rthal_trap_catch</a> (rthal_trap_handler_t handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Installs a fault handler.  <a href="#g3f868180536815c231983781afef99c4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#gfb91722da28118853a09b1a0d98dd169">rthal_apc_alloc</a> (const char *name, void(*handler)(void *cookie), void *cookie)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate an APC slot.  <a href="#gfb91722da28118853a09b1a0d98dd169"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#gf11636f94b0a6913241679d84265eba6">rthal_apc_free</a> (int apc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Releases an APC slot.  <a href="#gf11636f94b0a6913241679d84265eba6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#ga0e99241b9b16e6a43a4eb0ec144448e">rthal_apc_schedule</a> (int apc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Schedule an APC invocation.  <a href="#ga0e99241b9b16e6a43a4eb0ec144448e"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="gfb91722da28118853a09b1a0d98dd169"></a><!-- doxytag: member="hal.c::rthal_apc_alloc" ref="gfb91722da28118853a09b1a0d98dd169" args="(const char *name, void(*handler)(void *cookie), void *cookie)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rthal_apc_alloc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void(*)(void *cookie)&nbsp;</td>
          <td class="mdname" nowrap> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>cookie</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocate an APC slot. 
<p>
APC is the acronym for Asynchronous Procedure Call, a mean by which activities from the Xenomai domain can schedule deferred invocations of handlers to be run into the Linux domain, as soon as possible when the Linux kernel gets back in control. Up to BITS_PER_LONG APC slots can be active at any point in time. APC support is built upon Adeos's virtual interrupt support.<p>
The HAL guarantees that any Linux kernel service which would be callable from a regular Linux interrupt handler is also available to APC handlers, including over PREEMPT_RT kernels exhibiting a threaded IRQ model.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>is a symbolic name identifying the APC which will get reported through the /proc/xenomai/apc interface. Passing NULL to create an anonymous APC is allowed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The address of the fault handler to call upon exception condition. The handle will be passed the <em>cookie</em> value unmodified.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cookie</em>&nbsp;</td><td>A user-defined opaque cookie the HAL will pass to the APC handler as its sole argument.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>an valid APC id. is returned upon success, or a negative error code otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>handler</em> is invalid.</li></ul>
<p>
<ul>
<li>-EBUSY is returned if no more APC slots are available.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Linux domain context. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="gf11636f94b0a6913241679d84265eba6"></a><!-- doxytag: member="hal.c::rthal_apc_free" ref="gf11636f94b0a6913241679d84265eba6" args="(int apc)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rthal_apc_free           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>apc</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Releases an APC slot. 
<p>
This service deallocates an APC slot obtained by <a class="el" href="group__hal.html#gfb91722da28118853a09b1a0d98dd169">rthal_apc_alloc()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>apc</em>&nbsp;</td><td>The APC id. to release, as returned by a successful call to the <a class="el" href="group__hal.html#gfb91722da28118853a09b1a0d98dd169">rthal_apc_alloc()</a> service.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>apc</em> is invalid.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Any domain context. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="ga0e99241b9b16e6a43a4eb0ec144448e"></a><!-- doxytag: member="hal.c::rthal_apc_schedule" ref="ga0e99241b9b16e6a43a4eb0ec144448e" args="(int apc)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rthal_apc_schedule           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>apc</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Schedule an APC invocation. 
<p>
This service marks the APC as pending for the Linux domain, so that its handler will be called as soon as possible, when the Linux domain gets back in control.<p>
When posted from the Linux domain, the APC handler is fired as soon as the interrupt mask is explicitely cleared by some kernel code. When posted from the Xenomai domain, the APC handler is fired as soon as the Linux domain is resumed, i.e. after Xenomai has completed all its pending duties.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>apc</em>&nbsp;</td><td>The APC id. to schedule.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>apc</em> is invalid.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Any domain context, albeit the usual calling place is from the Xenomai domain. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="g63c5799998ae73a818b3c3be4cca89bd"></a><!-- doxytag: member="hal.c::rthal_irq_affinity" ref="g63c5799998ae73a818b3c3be4cca89bd" args="(unsigned irq, cpumask_t cpumask, cpumask_t *oldmask)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rthal_irq_affinity           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned&nbsp;</td>
          <td class="mdname" nowrap> <em>irq</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>cpumask_t&nbsp;</td>
          <td class="mdname" nowrap> <em>cpumask</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>cpumask_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>oldmask</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set/Get processor affinity for external interrupt. 
<p>
On SMP systems, this service ensures that the given interrupt is preferably dispatched to the specified set of processors. The previous affinity mask is returned by this service.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>irq</em>&nbsp;</td><td>The interrupt source whose processor affinity is affected by the operation. Only external interrupts can have their affinity changed/queried, thus virtual interrupt numbers allocated by rthal_alloc_virq() are invalid values for this parameter.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cpumask</em>&nbsp;</td><td>A list of CPU identifiers passed as a bitmask representing the new affinity for this interrupt. A zero value cause this service to return the current affinity mask without changing it.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oldmask</em>&nbsp;</td><td>If non-NULL, a pointer to a memory area which will bve overwritten by the previous affinity mask used for this interrupt source, or a zeroed mask if an error occurred. This service always returns a zeroed mask on uniprocessor systems.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>irq</em> is invalid.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Linux domain context. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="g615e2795b5a080f9155bf2f9f29e0b3f"></a><!-- doxytag: member="hal.c::rthal_irq_disable" ref="g615e2795b5a080f9155bf2f9f29e0b3f" args="(unsigned irq)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rthal_irq_disable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>irq</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Disable an interrupt source. 
<p>
Disables an interrupt source at PIC level. After this call has returned, no more IRQs from the given source will be allowed, until the latter is enabled again using <a class="el" href="group__hal.html#g306c0dcb88589f6a84f9b9d3304c4e8e">rthal_irq_enable()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>irq</em>&nbsp;</td><td>The interrupt source to disable. This value is architecture-dependent.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>irq</em> is invalid.</li></ul>
<p>
<ul>
<li>Other error codes might be returned in case some internal error happens at the Adeos level. Such error might caused by conflicting Adeos requests made by third-party code.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Any domain context. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="g306c0dcb88589f6a84f9b9d3304c4e8e"></a><!-- doxytag: member="hal.c::rthal_irq_enable" ref="g306c0dcb88589f6a84f9b9d3304c4e8e" args="(unsigned irq)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rthal_irq_enable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>irq</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enable an interrupt source. 
<p>
Enables an interrupt source at PIC level. Since Adeos masks and acknowledges the associated interrupt source upon IRQ receipt, this action is usually needed whenever the HAL handler does not propagate the IRQ event to the Linux domain, thus preventing the regular Linux interrupt handling code from re-enabling said source. After this call has returned, IRQs from the given source will be enabled again.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>irq</em>&nbsp;</td><td>The interrupt source to enable. This value is architecture-dependent.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>irq</em> is invalid.</li></ul>
<p>
<ul>
<li>Other error codes might be returned in case some internal error happens at the Adeos level. Such error might caused by conflicting Adeos requests made by third-party code.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Any domain context. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="g74372309e2009faaa4d6c1e56932e9b8"></a><!-- doxytag: member="hal.c::rthal_irq_host_pend" ref="g74372309e2009faaa4d6c1e56932e9b8" args="(unsigned irq)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rthal_irq_host_pend           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>irq</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Propagate an IRQ event to Linux. 
<p>
Causes the given IRQ to be propagated down to the Adeos pipeline to the Linux kernel. This operation is typically used after the given IRQ has been processed into the Xenomai domain by a real-time interrupt handler (see <a class="el" href="group__hal.html#gadf0f98059a5bf1caddda9dd48d51f20">rthal_irq_request()</a>), in case such interrupt must also be handled by the Linux kernel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>irq</em>&nbsp;</td><td>The interrupt source to detach the shared handler from. This value is architecture-dependent.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>irq</em> is invalid.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Xenomai domain context. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="g80403d346662fcc3c960f12e4d5b8e09"></a><!-- doxytag: member="hal.c::rthal_irq_host_release" ref="g80403d346662fcc3c960f12e4d5b8e09" args="(unsigned irq, void *dev_id)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rthal_irq_host_release           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned&nbsp;</td>
          <td class="mdname" nowrap> <em>irq</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>dev_id</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Uninstall a shared Linux interrupt handler. 
<p>
Uninstalls a shared interrupt handler from the Linux domain for the given interrupt source. The handler is removed from the existing list of Linux handlers for this interrupt source.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>irq</em>&nbsp;</td><td>The interrupt source to detach the shared handler from. This value is architecture-dependent.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dev_id</em>&nbsp;</td><td>is a valid device id, identical in essence to the one requested by the free_irq() service provided by the Linux kernel. This value will be used to locate the handler to remove from the chain of existing Linux handlers for the given interrupt source. This parameter must match the device id. passed to rthal_irq_host_request() for the same handler instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>irq</em> is invalid.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Linux domain context. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="gd7d90c5882463a1d36b7a0ad74a9d4ff"></a><!-- doxytag: member="hal.c::rthal_irq_release" ref="gd7d90c5882463a1d36b7a0ad74a9d4ff" args="(unsigned irq)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rthal_irq_release           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>irq</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Uninstall a real-time interrupt handler. 
<p>
Uninstalls an interrupt handler previously attached using the <a class="el" href="group__hal.html#gadf0f98059a5bf1caddda9dd48d51f20">rthal_irq_request()</a> service.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>irq</em>&nbsp;</td><td>The hardware interrupt channel to uninstall a handler from. This value is architecture-dependent.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>irq</em> is invalid.</li></ul>
<p>
<ul>
<li>Other error codes might be returned in case some internal error happens at the Adeos level. Such error might caused by conflicting Adeos requests made by third-party code.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Any domain context. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="gadf0f98059a5bf1caddda9dd48d51f20"></a><!-- doxytag: member="hal.c::rthal_irq_request" ref="gadf0f98059a5bf1caddda9dd48d51f20" args="(unsigned irq, rthal_irq_handler_t handler, rthal_irq_ackfn_t ackfn, void *cookie)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rthal_irq_request           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned&nbsp;</td>
          <td class="mdname" nowrap> <em>irq</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>rthal_irq_handler_t&nbsp;</td>
          <td class="mdname" nowrap> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>rthal_irq_ackfn_t&nbsp;</td>
          <td class="mdname" nowrap> <em>ackfn</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>cookie</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Install a real-time interrupt handler. 
<p>
Installs an interrupt handler for the specified IRQ line by requesting the appropriate Adeos virtualization service. The handler is invoked by Adeos on behalf of the Xenomai domain context. Once installed, the HAL interrupt handler will be called prior to the regular Linux handler for the same interrupt source.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>irq</em>&nbsp;</td><td>The hardware interrupt channel to install a handler on. This value is architecture-dependent.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The address of a valid interrupt service routine. This handler will be called each time the corresponding IRQ is delivered, and will be passed the <em>cookie</em> value unmodified.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ackfn</em>&nbsp;</td><td>The address of an optional interrupt acknowledge routine, aimed at replacing the one provided by Adeos. Only very specific situations actually require to override the default Adeos setting for this parameter, like having to acknowledge non-standard PIC hardware. <em>ackfn</em> should return a non-zero value to indicate that the interrupt has been properly acknowledged. If <em>ackfn</em> is NULL, the default Adeos routine will be used instead.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cookie</em>&nbsp;</td><td>A user-defined opaque cookie the HAL will pass to the interrupt handler as its sole argument.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EBUSY is returned if an interrupt handler is already installed. <a class="el" href="group__hal.html#gd7d90c5882463a1d36b7a0ad74a9d4ff">rthal_irq_release()</a> must be issued first before a handler is installed anew.</li></ul>
<p>
<ul>
<li>-EINVAL is returned if <em>irq</em> is invalid or <em>handler</em> is NULL.</li></ul>
<p>
<ul>
<li>Other error codes might be returned in case some internal error happens at the Adeos level. Such error might caused by conflicting Adeos requests made by third-party code.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Any domain context. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="gf8da29c90939e5cffd640c240e79da3e"></a><!-- doxytag: member="hal.c::rthal_timer_release" ref="gf8da29c90939e5cffd640c240e79da3e" args="(void)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rthal_timer_release           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Release the hardware timer. 
<p>
Releases the hardware timer, thus reverting the effect of a previous call to <a class="el" href="group__hal.html#gc7888ef10953f2a7e9e5ed087047036d">rthal_timer_request()</a>. In case the timer hardware is shared with Linux, a periodic setup suitable for the Linux kernel will be reset.<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Linux domain context. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="gc7888ef10953f2a7e9e5ed087047036d"></a><!-- doxytag: member="hal.c::rthal_timer_request" ref="gc7888ef10953f2a7e9e5ed087047036d" args="(void(*handler)(void), unsigned long nstick)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rthal_timer_request           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void(*)(void)&nbsp;</td>
          <td class="mdname" nowrap> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned long&nbsp;</td>
          <td class="mdname" nowrap> <em>nstick</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Grab the hardware timer. 
<p>
<a class="el" href="group__hal.html#gc7888ef10953f2a7e9e5ed087047036d">rthal_timer_request()</a> grabs and tunes the hardware timer so that a user-defined routine is called according to a given frequency. On architectures that provide a oneshot-programmable time source, the hardware timer can operate either in aperiodic or periodic mode. Using the aperiodic mode still allows to run periodic timings over it: the underlying hardware simply needs to be reprogrammed after each tick using the appropriate interval value<p>
The time interval that elapses between two consecutive invocations of the handler is called a tick. The user-supplied handler will always be invoked on behalf of the Xenomai domain for each incoming tick.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The address of the tick handler which will process each incoming tick.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nstick</em>&nbsp;</td><td>The timer period in nanoseconds. If this parameter is zero, the underlying hardware timer is set to operate in oneshot-programming mode. In this mode, timing accuracy is higher - since it is not rounded to a constant time slice - at the expense of a lesser efficicency due to the timer chip programming duties. On the other hand, the shorter the period, the higher the overhead induced by the periodic mode, since the handler will end up consuming a lot of CPU power to process useless ticks.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned on success. Otherwise:</dd></dl>
<ul>
<li>-EBUSY is returned if the hardware timer has already been grabbed. <a class="el" href="group__hal.html#gc7888ef10953f2a7e9e5ed087047036d">rthal_timer_request()</a> must be issued before <a class="el" href="group__hal.html#gc7888ef10953f2a7e9e5ed087047036d">rthal_timer_request()</a> is called again.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Linux domain context. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="g3f868180536815c231983781afef99c4"></a><!-- doxytag: member="hal.c::rthal_trap_catch" ref="g3f868180536815c231983781afef99c4" args="(rthal_trap_handler_t handler)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rthal_trap_catch           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">rthal_trap_handler_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>handler</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Installs a fault handler. 
<p>
The HAL attempts to invoke a fault handler whenever an uncontrolled exception or fault is caught at machine level. This service allows to install a user-defined handler for such events.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The address of the fault handler to call upon exception condition. The handler is passed the address of the low-level information block describing the fault as passed by Adeos. Its layout is implementation-dependent.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The address of the fault handler previously installed.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Any domain context. </li></ul>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Thu Jul 26 18:27:36 2007 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6 </small></address>
</body>
</html>
