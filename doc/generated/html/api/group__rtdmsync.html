<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Xenomai API: Synchronisation Services</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Xenomai API"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Xenomai API
   &#160;<span id="projectnumber">2.6.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__rtdmsync.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Synchronisation Services</div>  </div>
<div class="ingroups"><a class="el" href="group__driverapi.html">Driver Development API</a> &#124; <a class="el" href="group__devregister.html">Device Registration Services</a></div></div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Synchronisation Services:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__rtdmsync.png" border="0" alt="" usemap="#group____rtdmsync"/>
<map name="group____rtdmsync" id="group____rtdmsync">
<area shape="rect" id="node2" href="group__devregister.html" title="Device Registration\l Services" alt="" coords="20,5,156,51"/><area shape="rect" id="node3" href="group__driverapi.html" title="Driver Development API" alt="" coords="7,75,169,104"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0f7da4cec7713ed732ffd99040e219e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga0f7da4cec7713ed732ffd99040e219e2">rtdm_select_bind</a> (int fd, rtdm_selector_t *selector, enum <a class="el" href="group__rtdmsync.html#gae18228df8c70c9da1f90f61b01e92501">rtdm_selecttype</a> type, unsigned fd_index)</td></tr>
<tr class="memdesc:ga0f7da4cec7713ed732ffd99040e219e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a selector to specified event types of a given file descriptor.  <a href="#ga0f7da4cec7713ed732ffd99040e219e2"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="member-group"></a>
RTDM_SELECTTYPE_xxx</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpe7c56e23b943533d601cd08637a81e10"></a><a class="anchor" id="RTDM_SELECTTYPE_xxx"></a> Event types select can bind to </p>
</td></tr>
<tr class="memitem:gae18228df8c70c9da1f90f61b01e92501"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gae18228df8c70c9da1f90f61b01e92501">rtdm_selecttype</a> { <a class="el" href="group__rtdmsync.html#ggae18228df8c70c9da1f90f61b01e92501a3ddb0fbad9f52ad3646be2e5a6ba8b2b">RTDM_SELECTTYPE_READ</a> =  XNSELECT_READ, 
<a class="el" href="group__rtdmsync.html#ggae18228df8c70c9da1f90f61b01e92501a37819f609dee2b20852001e9b7ecd462">RTDM_SELECTTYPE_WRITE</a> =  XNSELECT_WRITE, 
<a class="el" href="group__rtdmsync.html#ggae18228df8c70c9da1f90f61b01e92501a2dd10c612a9e3c7e5134ee122ee3de74">RTDM_SELECTTYPE_EXCEPT</a> =  XNSELECT_EXCEPT
 }</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="member-group"></a>
Global Lock across Scheduler Invocation</h2></td></tr>
<tr class="memitem:gabbaf52632d5dde7fa66e0b70d887493b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gabbaf52632d5dde7fa66e0b70d887493b">RTDM_EXECUTE_ATOMICALLY</a>(code_block)</td></tr>
<tr class="memdesc:gabbaf52632d5dde7fa66e0b70d887493b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute code block atomically.  <a href="#gabbaf52632d5dde7fa66e0b70d887493b"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="member-group"></a>
Spinlock with Preemption Deactivation</h2></td></tr>
<tr class="memitem:gab6398c5dab6f8614bc8310b2248ae0b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab6398c5dab6f8614bc8310b2248ae0b6"></a>
typedef rthal_spinlock_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gab6398c5dab6f8614bc8310b2248ae0b6">rtdm_lock_t</a></td></tr>
<tr class="memdesc:gab6398c5dab6f8614bc8310b2248ae0b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock variable. <br/></td></tr>
<tr class="memitem:ga7584217487c323356414e21200a57e63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7584217487c323356414e21200a57e63"></a>
typedef unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga7584217487c323356414e21200a57e63">rtdm_lockctx_t</a></td></tr>
<tr class="memdesc:ga7584217487c323356414e21200a57e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable to save the context while holding a lock. <br/></td></tr>
<tr class="memitem:ga1dd901a6311b10ef7961b5fce7fa9d41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1dd901a6311b10ef7961b5fce7fa9d41"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga1dd901a6311b10ef7961b5fce7fa9d41">RTDM_LOCK_UNLOCKED</a>&#160;&#160;&#160;RTHAL_SPIN_LOCK_UNLOCKED</td></tr>
<tr class="memdesc:ga1dd901a6311b10ef7961b5fce7fa9d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static lock initialisation. <br/></td></tr>
<tr class="memitem:ga6abf985ea7a0b13ec564cf0107fd8cba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga6abf985ea7a0b13ec564cf0107fd8cba">rtdm_lock_init</a>(lock)&#160;&#160;&#160;rthal_spin_lock_init(lock)</td></tr>
<tr class="memdesc:ga6abf985ea7a0b13ec564cf0107fd8cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic lock initialisation.  <a href="#ga6abf985ea7a0b13ec564cf0107fd8cba"></a><br/></td></tr>
<tr class="memitem:ga65a4897268e15bda462b871976cb3909"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga65a4897268e15bda462b871976cb3909">rtdm_lock_get</a>(lock)&#160;&#160;&#160;rthal_spin_lock(lock)</td></tr>
<tr class="memdesc:ga65a4897268e15bda462b871976cb3909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire lock from non-preemptible contexts.  <a href="#ga65a4897268e15bda462b871976cb3909"></a><br/></td></tr>
<tr class="memitem:ga963bdb01102d0076cd64f6bc72a347da"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga963bdb01102d0076cd64f6bc72a347da">rtdm_lock_put</a>(lock)</td></tr>
<tr class="memdesc:ga963bdb01102d0076cd64f6bc72a347da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release lock without preemption restoration.  <a href="#ga963bdb01102d0076cd64f6bc72a347da"></a><br/></td></tr>
<tr class="memitem:ga985473873f9e32af688fe8a23634693d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga985473873f9e32af688fe8a23634693d">rtdm_lock_get_irqsave</a>(lock, context)</td></tr>
<tr class="memdesc:ga985473873f9e32af688fe8a23634693d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire lock and disable preemption.  <a href="#ga985473873f9e32af688fe8a23634693d"></a><br/></td></tr>
<tr class="memitem:ga4f1f8e33baf33b162636f63dec61aebd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga4f1f8e33baf33b162636f63dec61aebd">rtdm_lock_put_irqrestore</a>(lock, context)</td></tr>
<tr class="memdesc:ga4f1f8e33baf33b162636f63dec61aebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release lock and restore preemption state.  <a href="#ga4f1f8e33baf33b162636f63dec61aebd"></a><br/></td></tr>
<tr class="memitem:ga3d563fc5def018f743c55c452e061758"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga3d563fc5def018f743c55c452e061758">rtdm_lock_irqsave</a>(context)&#160;&#160;&#160;rthal_local_irq_save(context)</td></tr>
<tr class="memdesc:ga3d563fc5def018f743c55c452e061758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable preemption locally.  <a href="#ga3d563fc5def018f743c55c452e061758"></a><br/></td></tr>
<tr class="memitem:gae03c387fcae8a55105dd31d7c008bbb4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gae03c387fcae8a55105dd31d7c008bbb4">rtdm_lock_irqrestore</a>(context)&#160;&#160;&#160;rthal_local_irq_restore(context)</td></tr>
<tr class="memdesc:gae03c387fcae8a55105dd31d7c008bbb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore preemption state.  <a href="#gae03c387fcae8a55105dd31d7c008bbb4"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="member-group"></a>
Timeout Sequence Management</h2></td></tr>
<tr class="memitem:ga531ddf80690059302409f760bd7f14d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga531ddf80690059302409f760bd7f14d4">rtdm_toseq_init</a> (rtdm_toseq_t *timeout_seq, <a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a> timeout)</td></tr>
<tr class="memdesc:ga531ddf80690059302409f760bd7f14d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a timeout sequence.  <a href="#ga531ddf80690059302409f760bd7f14d4"></a><br/></td></tr>
<tr class="memitem:ga6f74613fc8e61d59e81bd55b1ca1aca7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga6f74613fc8e61d59e81bd55b1ca1aca7">EXPORT_SYMBOL_GPL</a> (<a class="el" href="group__rtdmsync.html#ga531ddf80690059302409f760bd7f14d4">rtdm_toseq_init</a>)</td></tr>
<tr class="memdesc:ga6f74613fc8e61d59e81bd55b1ca1aca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a timeout sequence.  <a href="#ga6f74613fc8e61d59e81bd55b1ca1aca7"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="member-group"></a>
Event Services</h2></td></tr>
<tr class="memitem:gaddf08d8ba5a44668bb360070a114fb19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gaddf08d8ba5a44668bb360070a114fb19">rtdm_event_init</a> (rtdm_event_t *event, unsigned long pending)</td></tr>
<tr class="memdesc:gaddf08d8ba5a44668bb360070a114fb19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise an event.  <a href="#gaddf08d8ba5a44668bb360070a114fb19"></a><br/></td></tr>
<tr class="memitem:ga3e6868f8425c539b9def60c423fb29a5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga3e6868f8425c539b9def60c423fb29a5">EXPORT_SYMBOL_GPL</a> (<a class="el" href="group__rtdmsync.html#gaddf08d8ba5a44668bb360070a114fb19">rtdm_event_init</a>)</td></tr>
<tr class="memdesc:ga3e6868f8425c539b9def60c423fb29a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise an event.  <a href="#ga3e6868f8425c539b9def60c423fb29a5"></a><br/></td></tr>
<tr class="memitem:ga7b27d0206027a07958d4a09017e8a3fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga7b27d0206027a07958d4a09017e8a3fe">rtdm_event_destroy</a> (rtdm_event_t *event)</td></tr>
<tr class="memdesc:ga7b27d0206027a07958d4a09017e8a3fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy an event.  <a href="#ga7b27d0206027a07958d4a09017e8a3fe"></a><br/></td></tr>
<tr class="memitem:ga7c9745d1db8e6de244a6c2690cbb8b22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga7c9745d1db8e6de244a6c2690cbb8b22">rtdm_event_pulse</a> (rtdm_event_t *event)</td></tr>
<tr class="memdesc:ga7c9745d1db8e6de244a6c2690cbb8b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal an event occurrence to currently listening waiters.  <a href="#ga7c9745d1db8e6de244a6c2690cbb8b22"></a><br/></td></tr>
<tr class="memitem:ga1217402b82034b26fe25c26f1e5b32c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga1217402b82034b26fe25c26f1e5b32c9">rtdm_event_signal</a> (rtdm_event_t *event)</td></tr>
<tr class="memdesc:ga1217402b82034b26fe25c26f1e5b32c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal an event occurrence.  <a href="#ga1217402b82034b26fe25c26f1e5b32c9"></a><br/></td></tr>
<tr class="memitem:ga38f5b3662d79e48390b4dd98b39ce456"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga38f5b3662d79e48390b4dd98b39ce456">EXPORT_SYMBOL_GPL</a> (<a class="el" href="group__rtdmsync.html#ga1217402b82034b26fe25c26f1e5b32c9">rtdm_event_signal</a>)</td></tr>
<tr class="memdesc:ga38f5b3662d79e48390b4dd98b39ce456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise an event.  <a href="#ga38f5b3662d79e48390b4dd98b39ce456"></a><br/></td></tr>
<tr class="memitem:ga1c433b50c53d49d164b084751861e855"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga1c433b50c53d49d164b084751861e855">rtdm_event_wait</a> (rtdm_event_t *event)</td></tr>
<tr class="memdesc:ga1c433b50c53d49d164b084751861e855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait on event occurrence.  <a href="#ga1c433b50c53d49d164b084751861e855"></a><br/></td></tr>
<tr class="memitem:ga8169aeaf5b6ba7745fd7b41cc0a7e495"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga8169aeaf5b6ba7745fd7b41cc0a7e495">EXPORT_SYMBOL_GPL</a> (<a class="el" href="group__rtdmsync.html#ga1c433b50c53d49d164b084751861e855">rtdm_event_wait</a>)</td></tr>
<tr class="memdesc:ga8169aeaf5b6ba7745fd7b41cc0a7e495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise an event.  <a href="#ga8169aeaf5b6ba7745fd7b41cc0a7e495"></a><br/></td></tr>
<tr class="memitem:gaf76f858a3951ca2e20d3b1e00afa17e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gaf76f858a3951ca2e20d3b1e00afa17e0">rtdm_event_timedwait</a> (rtdm_event_t *event, <a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a> timeout, rtdm_toseq_t *timeout_seq)</td></tr>
<tr class="memdesc:gaf76f858a3951ca2e20d3b1e00afa17e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait on event occurrence with timeout.  <a href="#gaf76f858a3951ca2e20d3b1e00afa17e0"></a><br/></td></tr>
<tr class="memitem:gacbef7eec85009512f70dc6d46326179f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gacbef7eec85009512f70dc6d46326179f">EXPORT_SYMBOL_GPL</a> (<a class="el" href="group__rtdmsync.html#gaf76f858a3951ca2e20d3b1e00afa17e0">rtdm_event_timedwait</a>)</td></tr>
<tr class="memdesc:gacbef7eec85009512f70dc6d46326179f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise an event.  <a href="#gacbef7eec85009512f70dc6d46326179f"></a><br/></td></tr>
<tr class="memitem:ga732fe3cf3370df0f296f06fc4ac7f925"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga732fe3cf3370df0f296f06fc4ac7f925">rtdm_event_clear</a> (rtdm_event_t *event)</td></tr>
<tr class="memdesc:ga732fe3cf3370df0f296f06fc4ac7f925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear event state.  <a href="#ga732fe3cf3370df0f296f06fc4ac7f925"></a><br/></td></tr>
<tr class="memitem:gaa3ed21bc517624a7ef72faacb39c4083"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gaa3ed21bc517624a7ef72faacb39c4083">EXPORT_SYMBOL_GPL</a> (<a class="el" href="group__rtdmsync.html#ga732fe3cf3370df0f296f06fc4ac7f925">rtdm_event_clear</a>)</td></tr>
<tr class="memdesc:gaa3ed21bc517624a7ef72faacb39c4083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise an event.  <a href="#gaa3ed21bc517624a7ef72faacb39c4083"></a><br/></td></tr>
<tr class="memitem:ga839656c781d87069dd1bf1c84c38e9d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga839656c781d87069dd1bf1c84c38e9d9">rtdm_event_select_bind</a> (rtdm_event_t *event, rtdm_selector_t *selector, enum <a class="el" href="group__rtdmsync.html#gae18228df8c70c9da1f90f61b01e92501">rtdm_selecttype</a> type, unsigned fd_index)</td></tr>
<tr class="memdesc:ga839656c781d87069dd1bf1c84c38e9d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a selector to an event.  <a href="#ga839656c781d87069dd1bf1c84c38e9d9"></a><br/></td></tr>
<tr class="memitem:ga4d9f20aae9b53a67c2423343a9a12aa0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga4d9f20aae9b53a67c2423343a9a12aa0">EXPORT_SYMBOL_GPL</a> (<a class="el" href="group__rtdmsync.html#ga839656c781d87069dd1bf1c84c38e9d9">rtdm_event_select_bind</a>)</td></tr>
<tr class="memdesc:ga4d9f20aae9b53a67c2423343a9a12aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise an event.  <a href="#ga4d9f20aae9b53a67c2423343a9a12aa0"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="member-group"></a>
Semaphore Services</h2></td></tr>
<tr class="memitem:gae1172824e463d7705ed3033e8aea133d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gae1172824e463d7705ed3033e8aea133d">rtdm_sem_init</a> (rtdm_sem_t *sem, unsigned long value)</td></tr>
<tr class="memdesc:gae1172824e463d7705ed3033e8aea133d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a semaphore.  <a href="#gae1172824e463d7705ed3033e8aea133d"></a><br/></td></tr>
<tr class="memitem:gac623a32474816f8e101cf333a8fefc58"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gac623a32474816f8e101cf333a8fefc58">EXPORT_SYMBOL_GPL</a> (<a class="el" href="group__rtdmsync.html#gae1172824e463d7705ed3033e8aea133d">rtdm_sem_init</a>)</td></tr>
<tr class="memdesc:gac623a32474816f8e101cf333a8fefc58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a semaphore.  <a href="#gac623a32474816f8e101cf333a8fefc58"></a><br/></td></tr>
<tr class="memitem:gaf16f45217e54201ff3f24753982c41f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gaf16f45217e54201ff3f24753982c41f8">rtdm_sem_destroy</a> (rtdm_sem_t *sem)</td></tr>
<tr class="memdesc:gaf16f45217e54201ff3f24753982c41f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a semaphore.  <a href="#gaf16f45217e54201ff3f24753982c41f8"></a><br/></td></tr>
<tr class="memitem:ga59da1b60b7279c1fc4355e2e0b2cc77c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga59da1b60b7279c1fc4355e2e0b2cc77c">rtdm_sem_down</a> (rtdm_sem_t *sem)</td></tr>
<tr class="memdesc:ga59da1b60b7279c1fc4355e2e0b2cc77c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement a semaphore.  <a href="#ga59da1b60b7279c1fc4355e2e0b2cc77c"></a><br/></td></tr>
<tr class="memitem:ga0e25c7dcd0a2cfa64b07d92d3df636f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga0e25c7dcd0a2cfa64b07d92d3df636f9">EXPORT_SYMBOL_GPL</a> (<a class="el" href="group__rtdmsync.html#ga59da1b60b7279c1fc4355e2e0b2cc77c">rtdm_sem_down</a>)</td></tr>
<tr class="memdesc:ga0e25c7dcd0a2cfa64b07d92d3df636f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a semaphore.  <a href="#ga0e25c7dcd0a2cfa64b07d92d3df636f9"></a><br/></td></tr>
<tr class="memitem:ga8aadb120a93df5dfd717c5bac6d4c1a9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga8aadb120a93df5dfd717c5bac6d4c1a9">rtdm_sem_timeddown</a> (rtdm_sem_t *sem, <a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a> timeout, rtdm_toseq_t *timeout_seq)</td></tr>
<tr class="memdesc:ga8aadb120a93df5dfd717c5bac6d4c1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement a semaphore with timeout.  <a href="#ga8aadb120a93df5dfd717c5bac6d4c1a9"></a><br/></td></tr>
<tr class="memitem:gafd5c6c2b33c052e09fb3f1940f1e1e84"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gafd5c6c2b33c052e09fb3f1940f1e1e84">EXPORT_SYMBOL_GPL</a> (<a class="el" href="group__rtdmsync.html#ga8aadb120a93df5dfd717c5bac6d4c1a9">rtdm_sem_timeddown</a>)</td></tr>
<tr class="memdesc:gafd5c6c2b33c052e09fb3f1940f1e1e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a semaphore.  <a href="#gafd5c6c2b33c052e09fb3f1940f1e1e84"></a><br/></td></tr>
<tr class="memitem:ga829dbd8c5709d798ed06947b27001fed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga829dbd8c5709d798ed06947b27001fed">rtdm_sem_up</a> (rtdm_sem_t *sem)</td></tr>
<tr class="memdesc:ga829dbd8c5709d798ed06947b27001fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment a semaphore.  <a href="#ga829dbd8c5709d798ed06947b27001fed"></a><br/></td></tr>
<tr class="memitem:ga02f0e859d64236f38b14230d5619fadc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga02f0e859d64236f38b14230d5619fadc">EXPORT_SYMBOL_GPL</a> (<a class="el" href="group__rtdmsync.html#ga829dbd8c5709d798ed06947b27001fed">rtdm_sem_up</a>)</td></tr>
<tr class="memdesc:ga02f0e859d64236f38b14230d5619fadc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a semaphore.  <a href="#ga02f0e859d64236f38b14230d5619fadc"></a><br/></td></tr>
<tr class="memitem:gaf61f576b0ff06f99399b27725aef0ae1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gaf61f576b0ff06f99399b27725aef0ae1">rtdm_sem_select_bind</a> (rtdm_sem_t *sem, rtdm_selector_t *selector, enum <a class="el" href="group__rtdmsync.html#gae18228df8c70c9da1f90f61b01e92501">rtdm_selecttype</a> type, unsigned fd_index)</td></tr>
<tr class="memdesc:gaf61f576b0ff06f99399b27725aef0ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a selector to a semaphore.  <a href="#gaf61f576b0ff06f99399b27725aef0ae1"></a><br/></td></tr>
<tr class="memitem:gac1e2f2337dfcb71ec548f4741aefeb8d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gac1e2f2337dfcb71ec548f4741aefeb8d">EXPORT_SYMBOL_GPL</a> (<a class="el" href="group__rtdmsync.html#gaf61f576b0ff06f99399b27725aef0ae1">rtdm_sem_select_bind</a>)</td></tr>
<tr class="memdesc:gac1e2f2337dfcb71ec548f4741aefeb8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a semaphore.  <a href="#gac1e2f2337dfcb71ec548f4741aefeb8d"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="member-group"></a>
Mutex Services</h2></td></tr>
<tr class="memitem:ga8d58a144bf71df7b38bb887d036cbbb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga8d58a144bf71df7b38bb887d036cbbb5">rtdm_mutex_init</a> (rtdm_mutex_t *mutex)</td></tr>
<tr class="memdesc:ga8d58a144bf71df7b38bb887d036cbbb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a mutex.  <a href="#ga8d58a144bf71df7b38bb887d036cbbb5"></a><br/></td></tr>
<tr class="memitem:gae0e01706b31cdf69fdfbd9b012bd393d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gae0e01706b31cdf69fdfbd9b012bd393d">EXPORT_SYMBOL_GPL</a> (<a class="el" href="group__rtdmsync.html#ga8d58a144bf71df7b38bb887d036cbbb5">rtdm_mutex_init</a>)</td></tr>
<tr class="memdesc:gae0e01706b31cdf69fdfbd9b012bd393d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a mutex.  <a href="#gae0e01706b31cdf69fdfbd9b012bd393d"></a><br/></td></tr>
<tr class="memitem:gad13170b569d0a4cdb46072e1e3a45527"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gad13170b569d0a4cdb46072e1e3a45527">rtdm_mutex_destroy</a> (rtdm_mutex_t *mutex)</td></tr>
<tr class="memdesc:gad13170b569d0a4cdb46072e1e3a45527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a mutex.  <a href="#gad13170b569d0a4cdb46072e1e3a45527"></a><br/></td></tr>
<tr class="memitem:gab40ed579324d8cc76387a0e06dd0f82a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gab40ed579324d8cc76387a0e06dd0f82a">rtdm_mutex_unlock</a> (rtdm_mutex_t *mutex)</td></tr>
<tr class="memdesc:gab40ed579324d8cc76387a0e06dd0f82a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a mutex.  <a href="#gab40ed579324d8cc76387a0e06dd0f82a"></a><br/></td></tr>
<tr class="memitem:ga67c8f85c844df1aeed806e343a1b6437"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga67c8f85c844df1aeed806e343a1b6437">rtdm_mutex_lock</a> (rtdm_mutex_t *mutex)</td></tr>
<tr class="memdesc:ga67c8f85c844df1aeed806e343a1b6437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a mutex.  <a href="#ga67c8f85c844df1aeed806e343a1b6437"></a><br/></td></tr>
<tr class="memitem:ga06d802ef1094fede869ea3311989d314"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga06d802ef1094fede869ea3311989d314">EXPORT_SYMBOL_GPL</a> (<a class="el" href="group__rtdmsync.html#ga67c8f85c844df1aeed806e343a1b6437">rtdm_mutex_lock</a>)</td></tr>
<tr class="memdesc:ga06d802ef1094fede869ea3311989d314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a mutex.  <a href="#ga06d802ef1094fede869ea3311989d314"></a><br/></td></tr>
<tr class="memitem:ga0789968300701ba2a940f5fe8b1fd4d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga0789968300701ba2a940f5fe8b1fd4d8">rtdm_mutex_timedlock</a> (rtdm_mutex_t *mutex, <a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a> timeout, rtdm_toseq_t *timeout_seq)</td></tr>
<tr class="memdesc:ga0789968300701ba2a940f5fe8b1fd4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a mutex with timeout.  <a href="#ga0789968300701ba2a940f5fe8b1fd4d8"></a><br/></td></tr>
<tr class="memitem:gabd3ac3306da6354b35adc928cf05cc7f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gabd3ac3306da6354b35adc928cf05cc7f">EXPORT_SYMBOL_GPL</a> (<a class="el" href="group__rtdmsync.html#ga0789968300701ba2a940f5fe8b1fd4d8">rtdm_mutex_timedlock</a>)</td></tr>
<tr class="memdesc:gabd3ac3306da6354b35adc928cf05cc7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a mutex.  <a href="#gabd3ac3306da6354b35adc928cf05cc7f"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<h2>Macro Definition Documentation</h2>
<a class="anchor" id="gabbaf52632d5dde7fa66e0b70d887493b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTDM_EXECUTE_ATOMICALLY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">code_block</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{                                               \</div>
<div class="line">        &lt;ENTER_ATOMIC_SECTION&gt;                  \</div>
<div class="line">        code_block;                             \</div>
<div class="line">        &lt;LEAVE_ATOMIC_SECTION&gt;                  \</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>Execute code block atomically. </p>
<p>Generally, it is illegal to suspend the current task by calling <a class="el" href="group__rtdmtask.html#gabfae53746165a83a75965b7b0f6710a0" title="Sleep a specified amount of time.">rtdm_task_sleep()</a>, <a class="el" href="group__rtdmsync.html#ga1c433b50c53d49d164b084751861e855" title="Wait on event occurrence.">rtdm_event_wait()</a>, etc. while holding a spinlock. In contrast, this macro allows to combine several operations including a potentially rescheduling call to an atomic code block with respect to other <a class="el" href="group__rtdmsync.html#gabbaf52632d5dde7fa66e0b70d887493b" title="Execute code block atomically.">RTDM_EXECUTE_ATOMICALLY()</a> blocks. The macro is a light-weight alternative for protecting code blocks via mutexes, and it can even be used to synchronise real-time and non-real-time contexts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_block</td><td>Commands to be executed atomically</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It is not allowed to leave the code block explicitly by using <code>break</code>, <code>return</code>, <code>goto</code>, etc. This would leave the global lock held during the code block execution in an inconsistent state. Moreover, do not embed complex operations into the code bock. Consider that they will be executed under preemption lock with interrupts switched-off. Also note that invocation of rescheduling calls may break the atomicity until the task gains the CPU again.</dd></dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: possible, depends on functions called within <em>code_block</em>. </p>

</div>
</div>
<a class="anchor" id="ga65a4897268e15bda462b871976cb3909"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_lock_get</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">lock</td><td>)</td>
          <td>&#160;&#160;&#160;rthal_spin_lock(lock)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire lock from non-preemptible contexts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>Address of lock variable</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="ga985473873f9e32af688fe8a23634693d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_lock_get_irqsave</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">lock, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">context&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                                            \</div>
<div class="line">                rthal_spin_lock_irqsave(lock, context); \</div>
<div class="line">                __xnpod_lock_sched();                   \</div>
<div class="line">        } <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment -->
<p>Acquire lock and disable preemption. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>Address of lock variable </td></tr>
    <tr><td class="paramname">context</td><td>name of local variable to store the context in</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

<p>Referenced by <a class="el" href="group__util.html#gab0b2db892afe1bd77a80f6b8367eb0c9">rtdm_ratelimit()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6abf985ea7a0b13ec564cf0107fd8cba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_lock_init</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">lock</td><td>)</td>
          <td>&#160;&#160;&#160;rthal_spin_lock_init(lock)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dynamic lock initialisation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>Address of lock variable</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="gae03c387fcae8a55105dd31d7c008bbb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_lock_irqrestore</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">context</td><td>)</td>
          <td>&#160;&#160;&#160;rthal_local_irq_restore(context)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore preemption state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>name of local variable which stored the context</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: possible. </p>

</div>
</div>
<a class="anchor" id="ga3d563fc5def018f743c55c452e061758"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_lock_irqsave</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">context</td><td>)</td>
          <td>&#160;&#160;&#160;rthal_local_irq_save(context)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable preemption locally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>name of local variable to store the context in</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="ga963bdb01102d0076cd64f6bc72a347da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_lock_put</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">lock</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                                    \</div>
<div class="line">                rthal_spin_unlock(lock);        \</div>
<div class="line">                __xnpod_unlock_sched();         \</div>
<div class="line">        } <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment -->
<p>Release lock without preemption restoration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>Address of lock variable</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="ga4f1f8e33baf33b162636f63dec61aebd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_lock_put_irqrestore</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">lock, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">context&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                                            \</div>
<div class="line">                rthal_spin_unlock(lock);                \</div>
<div class="line">                __xnpod_unlock_sched();                 \</div>
<div class="line">                rthal_local_irq_restore(context);       \</div>
<div class="line">        } <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment -->
<p>Release lock and restore preemption state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>Address of lock variable </td></tr>
    <tr><td class="paramname">context</td><td>name of local variable which stored the context</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: possible. </p>

<p>Referenced by <a class="el" href="group__util.html#gab0b2db892afe1bd77a80f6b8367eb0c9">rtdm_ratelimit()</a>.</p>

</div>
</div>
<h2>Enumeration Type Documentation</h2>
<a class="anchor" id="gae18228df8c70c9da1f90f61b01e92501"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__rtdmsync.html#gae18228df8c70c9da1f90f61b01e92501">rtdm_selecttype</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggae18228df8c70c9da1f90f61b01e92501a3ddb0fbad9f52ad3646be2e5a6ba8b2b"></a>RTDM_SELECTTYPE_READ</em>&nbsp;</td><td>
<p>Select input data availability events. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae18228df8c70c9da1f90f61b01e92501a37819f609dee2b20852001e9b7ecd462"></a>RTDM_SELECTTYPE_WRITE</em>&nbsp;</td><td>
<p>Select ouput buffer availability events. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae18228df8c70c9da1f90f61b01e92501a2dd10c612a9e3c7e5134ee122ee3de74"></a>RTDM_SELECTTYPE_EXCEPT</em>&nbsp;</td><td>
<p>Select exceptional events. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="ga6f74613fc8e61d59e81bd55b1ca1aca7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL_GPL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rtdmsync.html#ga531ddf80690059302409f760bd7f14d4">rtdm_toseq_init</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a timeout sequence. </p>
<p>This service initialises a timeout sequence handle according to the given timeout value. Timeout sequences allow to maintain a continuous <em>timeout</em> across multiple calls of blocking synchronisation services. A typical application scenario is given below.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">timeout_seq</td><td>Timeout sequence handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Relative timeout in nanoseconds, see <a class="el" href="group__rtdm.html#RTDM_TIMEOUT_xxx">RTDM_TIMEOUT_xxx</a> for special values</td></tr>
  </table>
  </dd>
</dl>
<p>Application Scenario: </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> device_service_routine(...)</div>
<div class="line">{</div>
<div class="line">        rtdm_toseq_t timeout_seq;</div>
<div class="line">        ...</div>
<div class="line"></div>
<div class="line">        <a class="code" href="group__rtdmsync.html#ga531ddf80690059302409f760bd7f14d4" title="Initialise a timeout sequence.">rtdm_toseq_init</a>(&amp;timeout_seq, timeout);</div>
<div class="line">        ...</div>
<div class="line">        <span class="keywordflow">while</span> (received &lt; requested) {</div>
<div class="line">                ret = <a class="code" href="group__rtdmsync.html#gaf76f858a3951ca2e20d3b1e00afa17e0" title="Wait on event occurrence with timeout.">rtdm_event_timedwait</a>(&amp;data_available, timeout, &amp;timeout_seq);</div>
<div class="line">                <span class="keywordflow">if</span> (ret &lt; 0) <span class="comment">// including -ETIMEDOUT</span></div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// receive some data</span></div>
<div class="line">                ...</div>
<div class="line">        }</div>
<div class="line">        ...</div>
<div class="line">}</div>
</div><!-- fragment --><p> Using a timeout sequence in such a scenario avoids that the user-provided relative <code>timeout</code> is restarted on every call to <a class="el" href="group__rtdmsync.html#gaf76f858a3951ca2e20d3b1e00afa17e0" title="Wait on event occurrence with timeout.">rtdm_event_timedwait()</a>, potentially causing an overall delay that is larger than specified by <code>timeout</code>. Moreover, all functions supporting timeout sequences also interpret special timeout values (infinite and non-blocking), disburdening the driver developer from handling them separately.</p>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel-based task</li>
<li>User-space task (RT)</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="ga3e6868f8425c539b9def60c423fb29a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL_GPL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rtdmsync.html#gaddf08d8ba5a44668bb360070a114fb19">rtdm_event_init</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise an event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">event</td><td>Event handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pending</td><td>Non-zero if event shall be initialised as set, 0 otherwise</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="ga38f5b3662d79e48390b4dd98b39ce456"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL_GPL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rtdmsync.html#ga1217402b82034b26fe25c26f1e5b32c9">rtdm_event_signal</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise an event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">event</td><td>Event handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pending</td><td>Non-zero if event shall be initialised as set, 0 otherwise</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="ga8169aeaf5b6ba7745fd7b41cc0a7e495"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL_GPL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rtdmsync.html#ga1c433b50c53d49d164b084751861e855">rtdm_event_wait</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise an event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">event</td><td>Event handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pending</td><td>Non-zero if event shall be initialised as set, 0 otherwise</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="gacbef7eec85009512f70dc6d46326179f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL_GPL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rtdmsync.html#gaf76f858a3951ca2e20d3b1e00afa17e0">rtdm_event_timedwait</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise an event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">event</td><td>Event handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pending</td><td>Non-zero if event shall be initialised as set, 0 otherwise</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="gaa3ed21bc517624a7ef72faacb39c4083"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL_GPL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rtdmsync.html#ga732fe3cf3370df0f296f06fc4ac7f925">rtdm_event_clear</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise an event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">event</td><td>Event handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pending</td><td>Non-zero if event shall be initialised as set, 0 otherwise</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="ga4d9f20aae9b53a67c2423343a9a12aa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL_GPL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rtdmsync.html#ga839656c781d87069dd1bf1c84c38e9d9">rtdm_event_select_bind</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise an event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">event</td><td>Event handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pending</td><td>Non-zero if event shall be initialised as set, 0 otherwise</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="gac623a32474816f8e101cf333a8fefc58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL_GPL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rtdmsync.html#gae1172824e463d7705ed3033e8aea133d">rtdm_sem_init</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a semaphore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sem</td><td>Semaphore handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Initial value of the semaphore</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="ga0e25c7dcd0a2cfa64b07d92d3df636f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL_GPL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rtdmsync.html#ga59da1b60b7279c1fc4355e2e0b2cc77c">rtdm_sem_down</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a semaphore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sem</td><td>Semaphore handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Initial value of the semaphore</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="gafd5c6c2b33c052e09fb3f1940f1e1e84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL_GPL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rtdmsync.html#ga8aadb120a93df5dfd717c5bac6d4c1a9">rtdm_sem_timeddown</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a semaphore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sem</td><td>Semaphore handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Initial value of the semaphore</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="ga02f0e859d64236f38b14230d5619fadc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL_GPL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rtdmsync.html#ga829dbd8c5709d798ed06947b27001fed">rtdm_sem_up</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a semaphore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sem</td><td>Semaphore handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Initial value of the semaphore</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="gac1e2f2337dfcb71ec548f4741aefeb8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL_GPL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rtdmsync.html#gaf61f576b0ff06f99399b27725aef0ae1">rtdm_sem_select_bind</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a semaphore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sem</td><td>Semaphore handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Initial value of the semaphore</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="gae0e01706b31cdf69fdfbd9b012bd393d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL_GPL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rtdmsync.html#ga8d58a144bf71df7b38bb887d036cbbb5">rtdm_mutex_init</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a mutex. </p>
<p>This function initalises a basic mutex with priority inversion protection. "Basic", as it does not allow a mutex owner to recursively lock the same mutex again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mutex</td><td>Mutex handle</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="ga06d802ef1094fede869ea3311989d314"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL_GPL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rtdmsync.html#ga67c8f85c844df1aeed806e343a1b6437">rtdm_mutex_lock</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a mutex. </p>
<p>This function initalises a basic mutex with priority inversion protection. "Basic", as it does not allow a mutex owner to recursively lock the same mutex again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mutex</td><td>Mutex handle</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="gabd3ac3306da6354b35adc928cf05cc7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL_GPL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rtdmsync.html#ga0789968300701ba2a940f5fe8b1fd4d8">rtdm_mutex_timedlock</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a mutex. </p>
<p>This function initalises a basic mutex with priority inversion protection. "Basic", as it does not allow a mutex owner to recursively lock the same mutex again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mutex</td><td>Mutex handle</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="ga732fe3cf3370df0f296f06fc4ac7f925"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_event_clear </td>
          <td>(</td>
          <td class="paramtype">rtdm_event_t *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear event state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">event</td><td>Event handle as returned by <a class="el" href="group__rtdmsync.html#gaddf08d8ba5a44668bb360070a114fb19" title="Initialise an event.">rtdm_event_init()</a></td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="ga7b27d0206027a07958d4a09017e8a3fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_event_destroy </td>
          <td>(</td>
          <td class="paramtype">rtdm_event_t *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy an event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">event</td><td>Event handle as returned by <a class="el" href="group__rtdmsync.html#gaddf08d8ba5a44668bb360070a114fb19" title="Initialise an event.">rtdm_event_init()</a></td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: possible. </p>

</div>
</div>
<a class="anchor" id="gaddf08d8ba5a44668bb360070a114fb19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_event_init </td>
          <td>(</td>
          <td class="paramtype">rtdm_event_t *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>pending</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise an event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">event</td><td>Event handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pending</td><td>Non-zero if event shall be initialised as set, 0 otherwise</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

<p>References <a class="el" href="group__select.html#ga80b33cc02e860dc6ffbd08e8da376e5b">xnselect_init()</a>, and <a class="el" href="group__synch.html#ga4c07b8ec87b14cf18ef512f0e0aade51">xnsynch_init()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7c9745d1db8e6de244a6c2690cbb8b22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_event_pulse </td>
          <td>(</td>
          <td class="paramtype">rtdm_event_t *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal an event occurrence to currently listening waiters. </p>
<p>This function wakes up all current waiters of the given event, but it does not change the event state. Subsequently callers of <a class="el" href="group__rtdmsync.html#ga1c433b50c53d49d164b084751861e855" title="Wait on event occurrence.">rtdm_event_wait()</a> or <a class="el" href="group__rtdmsync.html#gaf76f858a3951ca2e20d3b1e00afa17e0" title="Wait on event occurrence with timeout.">rtdm_event_timedwait()</a> will therefore be blocked first.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">event</td><td>Event handle as returned by <a class="el" href="group__rtdmsync.html#gaddf08d8ba5a44668bb360070a114fb19" title="Initialise an event.">rtdm_event_init()</a></td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: possible. </p>

</div>
</div>
<a class="anchor" id="ga839656c781d87069dd1bf1c84c38e9d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_event_select_bind </td>
          <td>(</td>
          <td class="paramtype">rtdm_event_t *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtdm_selector_t *&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__rtdmsync.html#gae18228df8c70c9da1f90f61b01e92501">rtdm_selecttype</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>fd_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a selector to an event. </p>
<p>This functions binds the given selector to an event so that the former is notified when the event state changes. Typically the select binding handler will invoke this service.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">event</td><td>Event handle as returned by <a class="el" href="group__rtdmsync.html#gaddf08d8ba5a44668bb360070a114fb19" title="Initialise an event.">rtdm_event_init()</a> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">selector</td><td>Selector as passed to the select binding handler </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Type of the bound event as passed to the select binding handler </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fd_index</td><td>File descriptor index as passed to the select binding handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-ENOMEM is returned if there is insufficient memory to establish the dynamic binding.</li>
</ul>
<ul>
<li>-EINVAL is returned if <em>type</em> or <em>fd_index</em> are invalid.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

<p>References <a class="el" href="group__select.html#ga8546a4a6f997a8c29451673d5b7f0e86">xnselect_bind()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1217402b82034b26fe25c26f1e5b32c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_event_signal </td>
          <td>(</td>
          <td class="paramtype">rtdm_event_t *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal an event occurrence. </p>
<p>This function sets the given event and wakes up all current waiters. If no waiter is presently registered, the next call to <a class="el" href="group__rtdmsync.html#ga1c433b50c53d49d164b084751861e855" title="Wait on event occurrence.">rtdm_event_wait()</a> or <a class="el" href="group__rtdmsync.html#gaf76f858a3951ca2e20d3b1e00afa17e0" title="Wait on event occurrence with timeout.">rtdm_event_timedwait()</a> will return immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">event</td><td>Event handle as returned by <a class="el" href="group__rtdmsync.html#gaddf08d8ba5a44668bb360070a114fb19" title="Initialise an event.">rtdm_event_init()</a></td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: possible. </p>

<p>References <a class="el" href="group__pod.html#gacf5b53f0405351327b89b0cc4976b962">xnpod_schedule()</a>, and <a class="el" href="group__synch.html#ga82beb68147bc5f0306ab02a61a9dc76b">xnsynch_flush()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf76f858a3951ca2e20d3b1e00afa17e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_event_timedwait </td>
          <td>(</td>
          <td class="paramtype">rtdm_event_t *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtdm_toseq_t *&#160;</td>
          <td class="paramname"><em>timeout_seq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait on event occurrence with timeout. </p>
<p>This function waits or tests for the occurence of the given event, taking the provided timeout into account. On successful return, the event is reset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">event</td><td>Event handle as returned by <a class="el" href="group__rtdmsync.html#gaddf08d8ba5a44668bb360070a114fb19" title="Initialise an event.">rtdm_event_init()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Relative timeout in nanoseconds, see <a class="el" href="group__rtdm.html#RTDM_TIMEOUT_xxx">RTDM_TIMEOUT_xxx</a> for special values </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">timeout_seq</td><td>Handle of a timeout sequence as returned by <a class="el" href="group__rtdmsync.html#ga531ddf80690059302409f760bd7f14d4" title="Initialise a timeout sequence.">rtdm_toseq_init()</a> or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-ETIMEDOUT is returned if the if the request has not been satisfied within the specified amount of time.</li>
</ul>
<ul>
<li>-EINTR is returned if calling task has been unblock by a signal or explicitly via <a class="el" href="group__rtdmtask.html#gae52cca97ebaf78eec2e31553a4dacd5e" title="Activate a blocked real-time task.">rtdm_task_unblock()</a>.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>event</em> has been destroyed.</li>
</ul>
<ul>
<li>-EPERM <em>may</em> be returned if an illegal invocation environment is detected.</li>
</ul>
<ul>
<li>-EWOULDBLOCK is returned if a negative <em>timeout</em> (i.e., non-blocking operation) has been specified.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel-based task</li>
<li>User-space task (RT)</li>
</ul>
<p>Rescheduling: possible. </p>

<p>References <a class="el" href="group__nucleus__info__flags.html#ga6aa575e1a99b9c931d3b1feb8bc7a36f">XNBREAK</a>, <a class="el" href="group__nucleus__info__flags.html#gab07d9dea73645dbba353dc2452c15b40">XNRMID</a>, <a class="el" href="group__synch.html#ga2747e9834546af461f118e7c90c9613e">xnsynch_sleep_on()</a>, and <a class="el" href="group__nucleus__info__flags.html#gaa11d7fc754db50d3a1f1e41611d324e9">XNTIMEO</a>.</p>

<p>Referenced by <a class="el" href="group__rtdmsync.html#ga1c433b50c53d49d164b084751861e855">rtdm_event_wait()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1c433b50c53d49d164b084751861e855"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_event_wait </td>
          <td>(</td>
          <td class="paramtype">rtdm_event_t *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait on event occurrence. </p>
<p>This is the light-weight version of <a class="el" href="group__rtdmsync.html#gaf76f858a3951ca2e20d3b1e00afa17e0" title="Wait on event occurrence with timeout.">rtdm_event_timedwait()</a>, implying an infinite timeout.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">event</td><td>Event handle as returned by <a class="el" href="group__rtdmsync.html#gaddf08d8ba5a44668bb360070a114fb19" title="Initialise an event.">rtdm_event_init()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if calling task has been unblock by a signal or explicitly via <a class="el" href="group__rtdmtask.html#gae52cca97ebaf78eec2e31553a4dacd5e" title="Activate a blocked real-time task.">rtdm_task_unblock()</a>.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>event</em> has been destroyed.</li>
</ul>
<ul>
<li>-EPERM <em>may</em> be returned if an illegal invocation environment is detected.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel-based task</li>
<li>User-space task (RT)</li>
</ul>
<p>Rescheduling: possible. </p>

<p>References <a class="el" href="group__rtdmsync.html#gaf76f858a3951ca2e20d3b1e00afa17e0">rtdm_event_timedwait()</a>.</p>

</div>
</div>
<a class="anchor" id="gad13170b569d0a4cdb46072e1e3a45527"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_mutex_destroy </td>
          <td>(</td>
          <td class="paramtype">rtdm_mutex_t *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mutex</td><td>Mutex handle as returned by <a class="el" href="group__rtdmsync.html#ga8d58a144bf71df7b38bb887d036cbbb5" title="Initialise a mutex.">rtdm_mutex_init()</a></td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: possible. </p>

</div>
</div>
<a class="anchor" id="ga8d58a144bf71df7b38bb887d036cbbb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_mutex_init </td>
          <td>(</td>
          <td class="paramtype">rtdm_mutex_t *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a mutex. </p>
<p>This function initalises a basic mutex with priority inversion protection. "Basic", as it does not allow a mutex owner to recursively lock the same mutex again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mutex</td><td>Mutex handle</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

<p>References <a class="el" href="group__synch.html#ga4c07b8ec87b14cf18ef512f0e0aade51">xnsynch_init()</a>.</p>

</div>
</div>
<a class="anchor" id="ga67c8f85c844df1aeed806e343a1b6437"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_mutex_lock </td>
          <td>(</td>
          <td class="paramtype">rtdm_mutex_t *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request a mutex. </p>
<p>This is the light-weight version of <a class="el" href="group__rtdmsync.html#ga0789968300701ba2a940f5fe8b1fd4d8" title="Request a mutex with timeout.">rtdm_mutex_timedlock()</a>, implying an infinite timeout.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mutex</td><td>Mutex handle as returned by <a class="el" href="group__rtdmsync.html#ga8d58a144bf71df7b38bb887d036cbbb5" title="Initialise a mutex.">rtdm_mutex_init()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EIDRM is returned if <em>mutex</em> has been destroyed.</li>
</ul>
<ul>
<li>-EPERM <em>may</em> be returned if an illegal invocation environment is detected.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel-based task</li>
<li>User-space task (RT)</li>
</ul>
<p>Rescheduling: possible. </p>

<p>References <a class="el" href="group__rtdmsync.html#ga0789968300701ba2a940f5fe8b1fd4d8">rtdm_mutex_timedlock()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0789968300701ba2a940f5fe8b1fd4d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_mutex_timedlock </td>
          <td>(</td>
          <td class="paramtype">rtdm_mutex_t *&#160;</td>
          <td class="paramname"><em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtdm_toseq_t *&#160;</td>
          <td class="paramname"><em>timeout_seq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request a mutex with timeout. </p>
<p>This function tries to acquire the given mutex. If it is not available, the caller is blocked unless non-blocking operation was selected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mutex</td><td>Mutex handle as returned by <a class="el" href="group__rtdmsync.html#ga8d58a144bf71df7b38bb887d036cbbb5" title="Initialise a mutex.">rtdm_mutex_init()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Relative timeout in nanoseconds, see <a class="el" href="group__rtdm.html#RTDM_TIMEOUT_xxx">RTDM_TIMEOUT_xxx</a> for special values </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">timeout_seq</td><td>Handle of a timeout sequence as returned by <a class="el" href="group__rtdmsync.html#ga531ddf80690059302409f760bd7f14d4" title="Initialise a timeout sequence.">rtdm_toseq_init()</a> or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-ETIMEDOUT is returned if the if the request has not been satisfied within the specified amount of time.</li>
</ul>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is negative and the semaphore value is currently not positive.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>mutex</em> has been destroyed.</li>
</ul>
<ul>
<li>-EPERM <em>may</em> be returned if an illegal invocation environment is detected.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel-based task</li>
<li>User-space task (RT)</li>
</ul>
<p>Rescheduling: possible. </p>

<p>References <a class="el" href="group__nucleus__info__flags.html#ga6aa575e1a99b9c931d3b1feb8bc7a36f">XNBREAK</a>, <a class="el" href="group__nucleus__info__flags.html#gab07d9dea73645dbba353dc2452c15b40">XNRMID</a>, <a class="el" href="group__synch.html#ga6d4ad886901c751a4f3c51b90fc8f91f">xnsynch_acquire()</a>, and <a class="el" href="group__nucleus__info__flags.html#gaa11d7fc754db50d3a1f1e41611d324e9">XNTIMEO</a>.</p>

<p>Referenced by <a class="el" href="group__rtdmsync.html#ga67c8f85c844df1aeed806e343a1b6437">rtdm_mutex_lock()</a>.</p>

</div>
</div>
<a class="anchor" id="gab40ed579324d8cc76387a0e06dd0f82a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_mutex_unlock </td>
          <td>(</td>
          <td class="paramtype">rtdm_mutex_t *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a mutex. </p>
<p>This function releases the given mutex, waking up a potential waiter which was blocked upon <a class="el" href="group__rtdmsync.html#ga67c8f85c844df1aeed806e343a1b6437" title="Request a mutex.">rtdm_mutex_lock()</a> or <a class="el" href="group__rtdmsync.html#ga0789968300701ba2a940f5fe8b1fd4d8" title="Request a mutex with timeout.">rtdm_mutex_timedlock()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mutex</td><td>Mutex handle as returned by <a class="el" href="group__rtdmsync.html#ga8d58a144bf71df7b38bb887d036cbbb5" title="Initialise a mutex.">rtdm_mutex_init()</a></td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel-based task</li>
<li>User-space task (RT)</li>
</ul>
<p>Rescheduling: possible. </p>

</div>
</div>
<a class="anchor" id="ga0f7da4cec7713ed732ffd99040e219e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_select_bind </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtdm_selector_t *&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__rtdmsync.html#gae18228df8c70c9da1f90f61b01e92501">rtdm_selecttype</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>fd_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a selector to specified event types of a given file descriptor. </p>
<p>This function is invoked by higher RTOS layers implementing select-like services. It shall not be called directly by RTDM drivers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>File descriptor to bind to </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">selector</td><td>Selector object that shall be bound to the given event </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Event type the caller is interested in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fd_index</td><td>Index in the file descriptor set of the caller</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EBADF is returned if the file descriptor <em>fd</em> cannot be resolved.</li>
</ul>
<ul>
<li>-EINVAL is returned if <em>type</em> or <em>fd_index</em> are invalid.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

<p>References <a class="el" href="structrtdm__dev__context.html#a91420e832bc08338b0d84b12edff9e88">rtdm_dev_context::ops</a>, <a class="el" href="group__interdrv.html#ga99e8509f4c8b404f0d5795b575d4c9cb">rtdm_context_get()</a>, <a class="el" href="group__interdrv.html#gaa48a3e04fd74cec81691d5d2187d7ef2">rtdm_context_unlock()</a>, and <a class="el" href="structrtdm__operations.html#aa052e237d48e04bfb777fde1b6eb83e7">rtdm_operations::select_bind</a>.</p>

</div>
</div>
<a class="anchor" id="gaf16f45217e54201ff3f24753982c41f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_sem_destroy </td>
          <td>(</td>
          <td class="paramtype">rtdm_sem_t *&#160;</td>
          <td class="paramname"><em>sem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a semaphore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sem</td><td>Semaphore handle as returned by <a class="el" href="group__rtdmsync.html#gae1172824e463d7705ed3033e8aea133d" title="Initialise a semaphore.">rtdm_sem_init()</a></td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: possible. </p>

</div>
</div>
<a class="anchor" id="ga59da1b60b7279c1fc4355e2e0b2cc77c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_sem_down </td>
          <td>(</td>
          <td class="paramtype">rtdm_sem_t *&#160;</td>
          <td class="paramname"><em>sem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrement a semaphore. </p>
<p>This is the light-weight version of <a class="el" href="group__rtdmsync.html#ga8aadb120a93df5dfd717c5bac6d4c1a9" title="Decrement a semaphore with timeout.">rtdm_sem_timeddown()</a>, implying an infinite timeout.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sem</td><td>Semaphore handle as returned by <a class="el" href="group__rtdmsync.html#gae1172824e463d7705ed3033e8aea133d" title="Initialise a semaphore.">rtdm_sem_init()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if calling task has been unblock by a signal or explicitly via <a class="el" href="group__rtdmtask.html#gae52cca97ebaf78eec2e31553a4dacd5e" title="Activate a blocked real-time task.">rtdm_task_unblock()</a>.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>sem</em> has been destroyed.</li>
</ul>
<ul>
<li>-EPERM <em>may</em> be returned if an illegal invocation environment is detected.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel-based task</li>
<li>User-space task (RT)</li>
</ul>
<p>Rescheduling: possible. </p>

<p>References <a class="el" href="group__rtdmsync.html#ga8aadb120a93df5dfd717c5bac6d4c1a9">rtdm_sem_timeddown()</a>.</p>

</div>
</div>
<a class="anchor" id="gae1172824e463d7705ed3033e8aea133d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_sem_init </td>
          <td>(</td>
          <td class="paramtype">rtdm_sem_t *&#160;</td>
          <td class="paramname"><em>sem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a semaphore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sem</td><td>Semaphore handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Initial value of the semaphore</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

<p>References <a class="el" href="group__posix__sem.html#ga39b0c38dd6210ff17b5b7da04598efd0">sem_init()</a>, <a class="el" href="group__select.html#ga80b33cc02e860dc6ffbd08e8da376e5b">xnselect_init()</a>, and <a class="el" href="group__synch.html#ga4c07b8ec87b14cf18ef512f0e0aade51">xnsynch_init()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf61f576b0ff06f99399b27725aef0ae1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_sem_select_bind </td>
          <td>(</td>
          <td class="paramtype">rtdm_sem_t *&#160;</td>
          <td class="paramname"><em>sem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtdm_selector_t *&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__rtdmsync.html#gae18228df8c70c9da1f90f61b01e92501">rtdm_selecttype</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>fd_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a selector to a semaphore. </p>
<p>This functions binds the given selector to the semaphore so that the former is notified when the semaphore state changes. Typically the select binding handler will invoke this service.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sem</td><td>Semaphore handle as returned by <a class="el" href="group__rtdmsync.html#gae1172824e463d7705ed3033e8aea133d" title="Initialise a semaphore.">rtdm_sem_init()</a> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">selector</td><td>Selector as passed to the select binding handler </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Type of the bound event as passed to the select binding handler </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fd_index</td><td>File descriptor index as passed to the select binding handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-ENOMEM is returned if there is insufficient memory to establish the dynamic binding.</li>
</ul>
<ul>
<li>-EINVAL is returned if <em>type</em> or <em>fd_index</em> are invalid.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

<p>References <a class="el" href="group__select.html#ga8546a4a6f997a8c29451673d5b7f0e86">xnselect_bind()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8aadb120a93df5dfd717c5bac6d4c1a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_sem_timeddown </td>
          <td>(</td>
          <td class="paramtype">rtdm_sem_t *&#160;</td>
          <td class="paramname"><em>sem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtdm_toseq_t *&#160;</td>
          <td class="paramname"><em>timeout_seq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrement a semaphore with timeout. </p>
<p>This function tries to decrement the given semphore's value if it is positive on entry. If not, the caller is blocked unless non-blocking operation was selected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sem</td><td>Semaphore handle as returned by <a class="el" href="group__rtdmsync.html#gae1172824e463d7705ed3033e8aea133d" title="Initialise a semaphore.">rtdm_sem_init()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Relative timeout in nanoseconds, see <a class="el" href="group__rtdm.html#RTDM_TIMEOUT_xxx">RTDM_TIMEOUT_xxx</a> for special values </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">timeout_seq</td><td>Handle of a timeout sequence as returned by <a class="el" href="group__rtdmsync.html#ga531ddf80690059302409f760bd7f14d4" title="Initialise a timeout sequence.">rtdm_toseq_init()</a> or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-ETIMEDOUT is returned if the if the request has not been satisfied within the specified amount of time.</li>
</ul>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is negative and the semaphore value is currently not positive.</li>
</ul>
<ul>
<li>-EINTR is returned if calling task has been unblock by a signal or explicitly via <a class="el" href="group__rtdmtask.html#gae52cca97ebaf78eec2e31553a4dacd5e" title="Activate a blocked real-time task.">rtdm_task_unblock()</a>.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>sem</em> has been destroyed.</li>
</ul>
<ul>
<li>-EPERM <em>may</em> be returned if an illegal invocation environment is detected.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel-based task</li>
<li>User-space task (RT)</li>
</ul>
<p>Rescheduling: possible. </p>

<p>References <a class="el" href="group__posix__sem.html#ga8678e7f5136343ef8d8123a185878f78">sem_timedwait()</a>, <a class="el" href="group__nucleus__info__flags.html#ga6aa575e1a99b9c931d3b1feb8bc7a36f">XNBREAK</a>, <a class="el" href="group__nucleus__info__flags.html#gab07d9dea73645dbba353dc2452c15b40">XNRMID</a>, <a class="el" href="group__synch.html#ga2747e9834546af461f118e7c90c9613e">xnsynch_sleep_on()</a>, and <a class="el" href="group__nucleus__info__flags.html#gaa11d7fc754db50d3a1f1e41611d324e9">XNTIMEO</a>.</p>

<p>Referenced by <a class="el" href="group__rtdmsync.html#ga59da1b60b7279c1fc4355e2e0b2cc77c">rtdm_sem_down()</a>.</p>

</div>
</div>
<a class="anchor" id="ga829dbd8c5709d798ed06947b27001fed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_sem_up </td>
          <td>(</td>
          <td class="paramtype">rtdm_sem_t *&#160;</td>
          <td class="paramname"><em>sem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increment a semaphore. </p>
<p>This function increments the given semphore's value, waking up a potential waiter which was blocked upon <a class="el" href="group__rtdmsync.html#ga59da1b60b7279c1fc4355e2e0b2cc77c" title="Decrement a semaphore.">rtdm_sem_down()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sem</td><td>Semaphore handle as returned by <a class="el" href="group__rtdmsync.html#gae1172824e463d7705ed3033e8aea133d" title="Initialise a semaphore.">rtdm_sem_init()</a></td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: possible. </p>

<p>References <a class="el" href="group__pod.html#gacf5b53f0405351327b89b0cc4976b962">xnpod_schedule()</a>, and <a class="el" href="group__synch.html#gad5992ddbdb81821cb29bae8900eb65ac">xnsynch_wakeup_one_sleeper()</a>.</p>

</div>
</div>
<a class="anchor" id="ga531ddf80690059302409f760bd7f14d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_toseq_init </td>
          <td>(</td>
          <td class="paramtype">rtdm_toseq_t *&#160;</td>
          <td class="paramname"><em>timeout_seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a timeout sequence. </p>
<p>This service initialises a timeout sequence handle according to the given timeout value. Timeout sequences allow to maintain a continuous <em>timeout</em> across multiple calls of blocking synchronisation services. A typical application scenario is given below.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">timeout_seq</td><td>Timeout sequence handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Relative timeout in nanoseconds, see <a class="el" href="group__rtdm.html#RTDM_TIMEOUT_xxx">RTDM_TIMEOUT_xxx</a> for special values</td></tr>
  </table>
  </dd>
</dl>
<p>Application Scenario: </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> device_service_routine(...)</div>
<div class="line">{</div>
<div class="line">        rtdm_toseq_t timeout_seq;</div>
<div class="line">        ...</div>
<div class="line"></div>
<div class="line">        <a class="code" href="group__rtdmsync.html#ga531ddf80690059302409f760bd7f14d4" title="Initialise a timeout sequence.">rtdm_toseq_init</a>(&amp;timeout_seq, timeout);</div>
<div class="line">        ...</div>
<div class="line">        <span class="keywordflow">while</span> (received &lt; requested) {</div>
<div class="line">                ret = <a class="code" href="group__rtdmsync.html#gaf76f858a3951ca2e20d3b1e00afa17e0" title="Wait on event occurrence with timeout.">rtdm_event_timedwait</a>(&amp;data_available, timeout, &amp;timeout_seq);</div>
<div class="line">                <span class="keywordflow">if</span> (ret &lt; 0) <span class="comment">// including -ETIMEDOUT</span></div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// receive some data</span></div>
<div class="line">                ...</div>
<div class="line">        }</div>
<div class="line">        ...</div>
<div class="line">}</div>
</div><!-- fragment --><p> Using a timeout sequence in such a scenario avoids that the user-provided relative <code>timeout</code> is restarted on every call to <a class="el" href="group__rtdmsync.html#gaf76f858a3951ca2e20d3b1e00afa17e0" title="Wait on event occurrence with timeout.">rtdm_event_timedwait()</a>, potentially causing an overall delay that is larger than specified by <code>timeout</code>. Moreover, all functions supporting timeout sequences also interpret special timeout values (infinite and non-blocking), disburdening the driver developer from handling them separately.</p>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel-based task</li>
<li>User-space task (RT)</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Oct 4 2013 22:39:09 for Xenomai API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.2 </li>
  </ul>
</div>
</body>
</html>
