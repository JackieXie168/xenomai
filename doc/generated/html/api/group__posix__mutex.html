<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Xenomai API: Mutex services.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>Mutex services.<br>
<small>
[<a class="el" href="group__posix.html">POSIX skin.</a>]</small>
</h1>
<p>
Collaboration diagram for Mutex services.:<center><table><tr><td><img src="group__posix__mutex.png" border="0" alt="" usemap="#group____posix____mutex_map">
<map name="group____posix____mutex_map">
<area href="group__posix.html" shape="rect" coords="9,8,102,32" alt="">
</map></td></tr></table></center>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Mutex services. 
<p>
A mutex is a MUTual EXclusion device, and is useful for protecting shared data structures from concurrent modifications, and implementing critical sections and monitors.<p>
A mutex has two possible states: unlocked (not owned by any thread), and locked (owned by one thread). A mutex can never be owned by two different threads simultaneously. A thread attempting to lock a mutex that is already locked by another thread is suspended until the owning thread unlocks the mutex first.<p>
Before it can be used, a mutex has to be initialized with <a class="el" href="group__posix__mutex.html#ga6">pthread_mutex_init()</a>. An attribute object, which reference may be passed to this service, allows to select the features of the created mutex, namely its <em>type</em> (see <a class="el" href="group__posix__mutex.html#ga17">pthread_mutexattr_settype()</a>) and the priority <em>protocol</em> it uses (see <a class="el" href="group__posix__mutex.html#ga19">pthread_mutexattr_setprotocol()</a>).<p>
There is no support for the <em>pshared</em> attribute; mutexes created by Xenomai POSIX skin may be shared by kernel-space modules and user-space processes through shared memory.<p>
By default, Xenomai POSIX skin mutexes are of the recursive type and use the priority inheritance protocol.<p>
Note that only <a class="el" href="group__posix__mutex.html#ga6">pthread_mutex_init()</a> may be used to initialize a mutex, using the static initializer <em>PTHREAD_MUTEX_INITIALIZER</em> is not supported. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__mutex.html#ga6">pthread_mutex_init</a> (pthread_mutex_t *mx, const pthread_mutexattr_t *attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a mutex.  <a href="#ga6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__mutex.html#ga7">pthread_mutex_destroy</a> (pthread_mutex_t *mx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a mutex.  <a href="#ga7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__mutex.html#ga9">pthread_mutex_trylock</a> (pthread_mutex_t *mx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to lock a mutex.  <a href="#ga9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__mutex.html#ga10">pthread_mutex_lock</a> (pthread_mutex_t *mx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock a mutex.  <a href="#ga10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__mutex.html#ga11">pthread_mutex_timedlock</a> (pthread_mutex_t *mx, const struct timespec *to)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt, during a bounded time, to lock a mutex.  <a href="#ga11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__mutex.html#ga13">pthread_mutex_unlock</a> (pthread_mutex_t *mx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock a mutex.  <a href="#ga13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__mutex.html#ga14">pthread_mutexattr_init</a> (pthread_mutexattr_t *attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a mutex attributes object.  <a href="#ga14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__mutex.html#ga15">pthread_mutexattr_destroy</a> (pthread_mutexattr_t *attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a mutex attributes object.  <a href="#ga15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__mutex.html#ga16">pthread_mutexattr_gettype</a> (const pthread_mutexattr_t *attr, int *type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the mutex type attribute from a mutex attributes object.  <a href="#ga16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__mutex.html#ga17">pthread_mutexattr_settype</a> (pthread_mutexattr_t *attr, int type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the mutex type attribute of a mutex attributes object.  <a href="#ga17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__mutex.html#ga18">pthread_mutexattr_getprotocol</a> (const pthread_mutexattr_t *attr, int *proto)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the protocol attribute from a mutex attributes object.  <a href="#ga18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__mutex.html#ga19">pthread_mutexattr_setprotocol</a> (pthread_mutexattr_t *attr, int proto)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the protocol attribute of a mutex attributes object.  <a href="#ga19"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga7" doxytag="mutex.c::pthread_mutex_destroy"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int pthread_mutex_destroy           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pthread_mutex_t *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mx</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destroy a mutex. 
<p>
This service destroys the mutex <em>mx</em>, if it is unlocked and not referenced by any condition variable. The mutex becomes invalid for all mutex services (they all return the EINVAL error) except <a class="el" href="group__posix__mutex.html#ga6">pthread_mutex_init()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mx</em>&nbsp;</td><td>the mutex to be destroyed.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, <p>
an error number if:<ul>
<li>EINVAL, the mutex <em>mx</em> is invalid;</li><li>EBUSY, the mutex is locked, or used by a condition variable.</li></ul>
</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutex_destroy.html">http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutex_destroy.html</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga6" doxytag="mutex.c::pthread_mutex_init"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int pthread_mutex_init           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pthread_mutex_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>mx</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const pthread_mutexattr_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>attr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize a mutex. 
<p>
This services initializes the mutex <em>mx</em>, using the mutex attributes object <em>attr</em>. If <em>attr</em> is <em>NULL</em> or this service is used from user-space, default attributes are used (see <a class="el" href="group__posix__mutex.html#ga14">pthread_mutexattr_init()</a>).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mx</em>&nbsp;</td><td>the mutex to be initialized;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>the mutex attributes object.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, <p>
an error number if:<ul>
<li>EINVAL, the mutex attributes object <em>attr</em> is invalid or uninitialized;</li><li>EBUSY, the mutex <em>mx</em> was already initialized;</li><li>ENOMEM, insufficient memory exists in the system heap to initialize the mutex, increase CONFIG_XENO_OPT_SYS_HEAPSZ.</li></ul>
</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutex_init.html">http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutex_init.html</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga10" doxytag="mutex.c::pthread_mutex_lock"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int pthread_mutex_lock           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pthread_mutex_t *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mx</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Lock a mutex. 
<p>
This service attempts to lock the mutex <em>mx</em>. If the mutex is free, it becomes locked. If it was locked by another thread than the current one, the current thread is suspended until the mutex is unlocked. If it was already locked by the current mutex, the behaviour of this service depends on the mutex type :<ul>
<li>for mutexes of the <em>PTHREAD_MUTEX_NORMAL</em> type, this service deadlocks;</li><li>for mutexes of the <em>PTHREAD_MUTEX_ERRORCHECK</em> type, this service returns the EDEADLK error number;</li><li>for mutexes of the <em>PTHREAD_MUTEX_RECURSIVE</em> type, this service increments the lock recursion count and returns 0.</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mx</em>&nbsp;</td><td>the mutex to be locked.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success <p>
an error number if:<ul>
<li>EPERM, the caller context is invalid;</li><li>EINVAL, the mutex <em>mx</em> is invalid;</li><li>EDEADLK, the mutex is of the <em>PTHREAD_MUTEX_ERRORCHECK</em> type and the mutex was already locked by the current thread;</li><li>EAGAIN, the mutex is of the <em>PTHREAD_MUTEX_RECURSIVE</em> type and the maximum number of recursive locks has been exceeded.</li></ul>
</dd></dl>
<dl compact><dt><b>Valid contexts:</b></dt><dd><ul>
<li>Xenomai kernel-space thread;</li><li>Xenomai user-space thread (switches to primary mode).</li></ul>
</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutex_lock.html">http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutex_lock.html</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga11" doxytag="mutex.c::pthread_mutex_timedlock"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int pthread_mutex_timedlock           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pthread_mutex_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>mx</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const struct timespec *&nbsp;</td>
          <td class="mdname" nowrap> <em>to</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Attempt, during a bounded time, to lock a mutex. 
<p>
This service is equivalent to <a class="el" href="group__posix__mutex.html#ga10">pthread_mutex_lock()</a>, except that if the mutex <em>mx</em> is locked by another thread than the current one, this service only suspends the current thread until the timeout specified by <em>to</em> expires.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mx</em>&nbsp;</td><td>the mutex to be locked;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>to</em>&nbsp;</td><td>the timeout, expressed as an absolute value of the CLOCK_REALTIME clock.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success; <p>
an error number if:<ul>
<li>EPERM, the caller context is invalid;</li><li>EINVAL, the mutex <em>mx</em> is invalid;</li><li>ETIMEDOUT, the mutex could not be locked and the specified timeout expired;</li><li>EDEADLK, the mutex is of the <em>PTHREAD_MUTEX_ERRORCHECK</em> type and the mutex was already locked by the current thread;</li><li>EAGAIN, the mutex is of the <em>PTHREAD_MUTEX_RECURSIVE</em> type and the maximum number of recursive locks has been exceeded.</li></ul>
</dd></dl>
<dl compact><dt><b>Valid contexts:</b></dt><dd><ul>
<li>Xenomai kernel-space thread;</li><li>Xenomai user-space thread (switches to primary mode).</li></ul>
</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutex_timedlock.html">http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutex_timedlock.html</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga9" doxytag="mutex.c::pthread_mutex_trylock"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int pthread_mutex_trylock           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pthread_mutex_t *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mx</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Attempt to lock a mutex. 
<p>
This service is equivalent to <a class="el" href="group__posix__mutex.html#ga10">pthread_mutex_lock()</a>, except that if the mutex <em>mx</em> is locked by another thread than the current one, this service returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mx</em>&nbsp;</td><td>the mutex to be locked.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success; <p>
an error number if:<ul>
<li>EPERM, the caller context is invalid;</li><li>EINVAL, the mutex is invalid;</li><li>EBUSY, the mutex was locked by another thread than the current one;</li><li>EAGAIN, the mutex is recursive, and the maximum number of recursive locks has been exceeded.</li></ul>
</dd></dl>
<dl compact><dt><b>Valid contexts:</b></dt><dd><ul>
<li>Xenomai kernel-space thread,</li><li>Xenomai user-space thread (switches to primary mode).</li></ul>
</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutex_trylock.html">http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutex_trylock.html</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga13" doxytag="mutex.c::pthread_mutex_unlock"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int pthread_mutex_unlock           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pthread_mutex_t *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mx</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Unlock a mutex. 
<p>
This service unlocks the mutex <em>mx</em>. If the mutex is of the <em>PTHREAD_MUTEX_RECURSIVE</em> <em>type</em> and the locking recursion count is greater than one, the lock recursion count is decremented and the mutex remains locked.<p>
Attempting to unlock a mutex which is not locked or which is locked by anther thread than the current one yields the EPERM error, whatever the mutex <em>type</em> attribute.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mx</em>&nbsp;</td><td>the mutex to be released.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success; <p>
an error number if:<ul>
<li>EPERM, the caller context is invalid;</li><li>EINVAL, the mutex <em>mx</em> is invalid;</li><li>EPERM, the mutex was not locked by the current thread.</li></ul>
</dd></dl>
<dl compact><dt><b>Valid contexts:</b></dt><dd><ul>
<li>Xenomai kernel-space thread,</li><li>kernel-space cancellation cleanup routine,</li><li>Xenomai user-space thread (switches to primary mode),</li><li>user-space cancellation cleanup routine.</li></ul>
</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutex_unlock.html">http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutex_unlock.html</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga15" doxytag="mutex_attr.c::pthread_mutexattr_destroy"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int pthread_mutexattr_destroy           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pthread_mutexattr_t *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>attr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destroy a mutex attributes object. 
<p>
This service destroys the mutex attributes object <em>attr</em>. The object becomes invalid for all mutex services (they all return EINVAL) except <a class="el" href="group__posix__mutex.html#ga14">pthread_mutexattr_init()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>the initialized mutex attributes object to be destroyed.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success; <p>
an error number if:<ul>
<li>EINVAL, the mutex attributes object <em>attr</em> is invalid.</li></ul>
</dd></dl>
<dl compact><dt><b>Valid contexts:</b></dt><dd><ul>
<li>kernel module initialization or cleanup routine;</li><li>Xenomai kernel-space real-time thread.</li></ul>
</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutexattr_destroy.html">http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutexattr_destroy.html</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga18" doxytag="mutex_attr.c::pthread_mutexattr_getprotocol"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int pthread_mutexattr_getprotocol           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const pthread_mutexattr_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>proto</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the protocol attribute from a mutex attributes object. 
<p>
This service stores, at the address <em>proto</em>, the value of the <em>protocol</em> attribute in the mutex attributes object <em>attr</em>.<p>
The <em>protcol</em> attribute may only be one of <em>PTHREAD_PRIO_NONE</em> and <em>PTHREAD_PRIO_INHERIT</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>an initialized mutex attributes object;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proto</em>&nbsp;</td><td>address where the value of the <em>protocol</em> attribute will be stored on success.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, <p>
an error number if:<ul>
<li>EINVAL, the <em>proto</em> address is invalid;</li><li>EINVAL, the mutex attributes object <em>attr</em> is invalid.</li></ul>
</dd></dl>
<dl compact><dt><b>Valid contexts:</b></dt><dd><ul>
<li>kernel module initialization or cleanup routine;</li><li>Xenomai kernel-space real-time thread.</li></ul>
</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutexattr_getprotocol.html">http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutexattr_getprotocol.html</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga16" doxytag="mutex_attr.c::pthread_mutexattr_gettype"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int pthread_mutexattr_gettype           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const pthread_mutexattr_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>type</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the mutex type attribute from a mutex attributes object. 
<p>
This service stores, at the address <em>type</em>, the value of the <em>type</em> attribute in the mutex attributes object <em>attr</em>.<p>
See <a class="el" href="group__posix__mutex.html#ga10">pthread_mutex_lock()</a> and <a class="el" href="group__posix__mutex.html#ga13">pthread_mutex_unlock()</a> documentations for a description of the values of the <em>type</em> attribute and their effect on a mutex.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>an initialized mutex attributes object,</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>address where the <em>type</em> attribute value will be stored on success.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on sucess, <p>
an error number if:<ul>
<li>EINVAL, the <em>type</em> address is invalid;</li><li>EINVAL, the mutex attributes object <em>attr</em> is invalid.</li></ul>
</dd></dl>
<dl compact><dt><b>Valid contexts:</b></dt><dd><ul>
<li>kernel module initialization or cleanup routine;</li><li>Xenomai kernel-space real-time thread.</li></ul>
</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutexattr_gettype.html">http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutexattr_gettype.html</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga14" doxytag="mutex_attr.c::pthread_mutexattr_init"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int pthread_mutexattr_init           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pthread_mutexattr_t *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>attr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize a mutex attributes object. 
<p>
This services initializes the mutex attributes object <em>attr</em> with default values for all attributes. Default value are :<ul>
<li>for the <em>type</em> attribute, <em>PTHREAD_MUTEX_RECURSIVE</em>;</li><li>for the <em>protocol</em> attribute, <em>PTHREAD_PRIO_INHERIT</em>.</li></ul>
<p>
Note that the <em>pshared</em> attribute is not supported: mutexes created by Xenomai POSIX skin may be shared by kernel-space modules and user-space processes through shared memory.<p>
If this service is called specifying a mutex attributes object that was already initialized, the attributes object is reinitialized.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>the mutex attributes object to be initialized.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success; <p>
an error number if:<ul>
<li>ENOMEM, the mutex attributes object pointer <em>attr</em> is <em>NULL</em>.</li></ul>
</dd></dl>
<dl compact><dt><b>Valid contexts:</b></dt><dd><ul>
<li>kernel module initialization or cleanup routine;</li><li>Xenomai kernel-space real-time thread.</li></ul>
</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutexattr_init.html">http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutexattr_init.html</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga19" doxytag="mutex_attr.c::pthread_mutexattr_setprotocol"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int pthread_mutexattr_setprotocol           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pthread_mutexattr_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>proto</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the protocol attribute of a mutex attributes object. 
<p>
This service set the <em>type</em> attribute of the mutex attributes object <em>attr</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>an initialized mutex attributes object,</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proto</em>&nbsp;</td><td>value of the <em>protocol</em> attribute, may be one of:<ul>
<li>PTHREAD_PRIO_NONE, meaning that a mutex created with the attributes object <em>attr</em> will not follow any priority protocol;</li><li>PTHREAD_PRIO_INHERIT, meaning that a mutex created with the attributes object <em>attr</em>, will follow the priority inheritance protocol.</li></ul>
</td></tr>
  </table>
</dl>
The value PTHREAD_PRIO_PROTECT (priority ceiling protocol) is unsupported.<p>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, <p>
an error status if:<ul>
<li>EINVAL, the mutex attributes object <em>attr</em> is invalid;</li><li>ENOTSUP, the value of <em>proto</em> is unsupported;</li><li>EINVAL, the value of <em>proto</em> is invalid.</li></ul>
</dd></dl>
<dl compact><dt><b>Valid contexts:</b></dt><dd><ul>
<li>kernel module initialization or cleanup routine;</li><li>Xenomai kernel-space real-time thread.</li></ul>
</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutexattr_setprotocol.html">http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutexattr_setprotocol.html</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga17" doxytag="mutex_attr.c::pthread_mutexattr_settype"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int pthread_mutexattr_settype           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pthread_mutexattr_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>type</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the mutex type attribute of a mutex attributes object. 
<p>
This service set the <em>type</em> attribute of the mutex attributes object <em>attr</em>.<p>
See <a class="el" href="group__posix__mutex.html#ga10">pthread_mutex_lock()</a> and <a class="el" href="group__posix__mutex.html#ga13">pthread_mutex_unlock()</a> documentations for a description of the values of the <em>type</em> attribute and their effect on a mutex.<p>
The <em>PTHREAD_MUTEX_DEFAULT</em> default <em>type</em> is the same as <em>PTHREAD_MUTEX_RECURSIVE</em>. Note that using a Xenomai POSIX skin recursive mutex with a Xenomai POSIX skin condition variable is safe (see <a class="el" href="group__posix__cond.html#ga10">pthread_cond_wait()</a> documentation).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>an initialized mutex attributes object,</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>value of the <em>type</em> attribute.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, <p>
an error number if:<ul>
<li>EINVAL, the mutex attributes object <em>attr</em> is invalid;</li><li>EINVAL, the value of <em>type</em> is invalid for the <em>type</em> attribute.</li></ul>
</dd></dl>
<dl compact><dt><b>Valid contexts:</b></dt><dd><ul>
<li>kernel module initialization or cleanup routine;</li><li>Xenomai kernel-space real-time thread.</li></ul>
</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutexattr_settype.html">http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutexattr_settype.html</a> </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat Mar 11 15:12:00 2006 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
