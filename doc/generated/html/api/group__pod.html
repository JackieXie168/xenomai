<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Xenomai API: Real-time pod services.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Xenomai API"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Xenomai API
   &#160;<span id="projectnumber">2.6.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__pod.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Real-time pod services.</div>  </div>
<div class="ingroups"><a class="el" href="group__nucleus.html">Xenomai nucleus.</a></div></div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Real-time pod services.:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__pod.png" border="0" alt="" usemap="#group____pod"/>
<map name="group____pod" id="group____pod">
<area shape="rect" id="node1" href="group__nucleus.html" title="Xenomai nucleus." alt="" coords="7,5,132,35"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:pod_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pod_8h.html">pod.h</a></td></tr>
<tr class="memdesc:pod_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real-time pod interface header. <br/></td></tr>
<tr class="memitem:pod_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pod_8c.html">pod.c</a></td></tr>
<tr class="memdesc:pod_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real-time pod services. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnpod.html">xnpod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real-time pod descriptor.  <a href="structxnpod.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga167bb3b4251ac8b8a3e7f358d236908a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#ga167bb3b4251ac8b8a3e7f358d236908a">xnpod_init</a> (void)</td></tr>
<tr class="memdesc:ga167bb3b4251ac8b8a3e7f358d236908a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the core pod.  <a href="#ga167bb3b4251ac8b8a3e7f358d236908a"></a><br/></td></tr>
<tr class="memitem:ga10d3c13efa3ab06ac23017710b13314e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#ga10d3c13efa3ab06ac23017710b13314e">xnpod_enable_timesource</a> (void)</td></tr>
<tr class="memdesc:ga10d3c13efa3ab06ac23017710b13314e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate the core time source.  <a href="#ga10d3c13efa3ab06ac23017710b13314e"></a><br/></td></tr>
<tr class="memitem:ga179f47d6e98446843f059790112dcce3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#ga179f47d6e98446843f059790112dcce3">xnpod_disable_timesource</a> (void)</td></tr>
<tr class="memdesc:ga179f47d6e98446843f059790112dcce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the core time source.  <a href="#ga179f47d6e98446843f059790112dcce3"></a><br/></td></tr>
<tr class="memitem:ga824dc22468666c9f14da1842f0184b84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#ga824dc22468666c9f14da1842f0184b84">xnpod_shutdown</a> (int xtype)</td></tr>
<tr class="memdesc:ga824dc22468666c9f14da1842f0184b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutdown the current pod.  <a href="#ga824dc22468666c9f14da1842f0184b84"></a><br/></td></tr>
<tr class="memitem:gad71ebccc5b7b3d367f65127a8849c036"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#gad71ebccc5b7b3d367f65127a8849c036">xnpod_init_thread</a> (struct xnthread *thread, const struct xnthread_init_attr *attr, struct xnsched_class *sched_class, const union xnsched_policy_param *sched_param)</td></tr>
<tr class="memdesc:gad71ebccc5b7b3d367f65127a8849c036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a new thread.  <a href="#gad71ebccc5b7b3d367f65127a8849c036"></a><br/></td></tr>
<tr class="memitem:gad322f6afd62430705486a9036d0b7d66"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#gad322f6afd62430705486a9036d0b7d66">xnpod_start_thread</a> (xnthread_t *thread, const struct xnthread_start_attr *attr)</td></tr>
<tr class="memdesc:gad322f6afd62430705486a9036d0b7d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initial start of a newly created thread.  <a href="#gad322f6afd62430705486a9036d0b7d66"></a><br/></td></tr>
<tr class="memitem:gad86de7feeb37bbac6f6660916c3fe099"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#gad86de7feeb37bbac6f6660916c3fe099">xnpod_stop_thread</a> (xnthread_t *thread)</td></tr>
<tr class="memdesc:gad86de7feeb37bbac6f6660916c3fe099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop a thread.  <a href="#gad86de7feeb37bbac6f6660916c3fe099"></a><br/></td></tr>
<tr class="memitem:ga61624578d0f1979f1ca6a5e9e49a74a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#ga61624578d0f1979f1ca6a5e9e49a74a3">xnpod_restart_thread</a> (xnthread_t *thread)</td></tr>
<tr class="memdesc:ga61624578d0f1979f1ca6a5e9e49a74a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restart a thread.  <a href="#ga61624578d0f1979f1ca6a5e9e49a74a3"></a><br/></td></tr>
<tr class="memitem:gad2b761fb70cad30339f092edb4a89587"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#gad2b761fb70cad30339f092edb4a89587">xnpod_delete_thread</a> (xnthread_t *thread)</td></tr>
<tr class="memdesc:gad2b761fb70cad30339f092edb4a89587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a thread.  <a href="#gad2b761fb70cad30339f092edb4a89587"></a><br/></td></tr>
<tr class="memitem:ga75278c2ac6f43741eca9cc1d60072eac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#ga75278c2ac6f43741eca9cc1d60072eac">xnpod_abort_thread</a> (xnthread_t *thread)</td></tr>
<tr class="memdesc:ga75278c2ac6f43741eca9cc1d60072eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort a thread.  <a href="#ga75278c2ac6f43741eca9cc1d60072eac"></a><br/></td></tr>
<tr class="memitem:ga629c06b152dabfdb679b6e49bd9f7734"><td class="memItemLeft" align="right" valign="top">xnflags_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#ga629c06b152dabfdb679b6e49bd9f7734">xnpod_set_thread_mode</a> (xnthread_t *thread, xnflags_t clrmask, xnflags_t setmask)</td></tr>
<tr class="memdesc:ga629c06b152dabfdb679b6e49bd9f7734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change a thread's control mode.  <a href="#ga629c06b152dabfdb679b6e49bd9f7734"></a><br/></td></tr>
<tr class="memitem:ga767221cf87c198c5dc071e9f597dcb3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#ga767221cf87c198c5dc071e9f597dcb3a">xnpod_suspend_thread</a> (xnthread_t *thread, xnflags_t mask, xnticks_t timeout, xntmode_t timeout_mode, struct xnsynch *wchan)</td></tr>
<tr class="memdesc:ga767221cf87c198c5dc071e9f597dcb3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend a thread.  <a href="#ga767221cf87c198c5dc071e9f597dcb3a"></a><br/></td></tr>
<tr class="memitem:gac3a7bf9e973782a8cfd6495a1786e812"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#gac3a7bf9e973782a8cfd6495a1786e812">xnpod_resume_thread</a> (xnthread_t *thread, xnflags_t mask)</td></tr>
<tr class="memdesc:gac3a7bf9e973782a8cfd6495a1786e812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume a thread.  <a href="#gac3a7bf9e973782a8cfd6495a1786e812"></a><br/></td></tr>
<tr class="memitem:gae5f0d19e7a499b9b262f68a43ab545dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#gae5f0d19e7a499b9b262f68a43ab545dd">xnpod_unblock_thread</a> (xnthread_t *thread)</td></tr>
<tr class="memdesc:gae5f0d19e7a499b9b262f68a43ab545dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unblock a thread.  <a href="#gae5f0d19e7a499b9b262f68a43ab545dd"></a><br/></td></tr>
<tr class="memitem:ga6d535ef9821e98fd7f257b50a3c8d595"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#ga6d535ef9821e98fd7f257b50a3c8d595">xnpod_set_thread_schedparam</a> (struct xnthread *thread, struct xnsched_class *sched_class, const union xnsched_policy_param *sched_param)</td></tr>
<tr class="memdesc:ga6d535ef9821e98fd7f257b50a3c8d595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the base scheduling parameters of a thread.  <a href="#ga6d535ef9821e98fd7f257b50a3c8d595"></a><br/></td></tr>
<tr class="memitem:ga4d14486d26a32a2660697f5a88d8301d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#ga4d14486d26a32a2660697f5a88d8301d">xnpod_migrate_thread</a> (int cpu)</td></tr>
<tr class="memdesc:ga4d14486d26a32a2660697f5a88d8301d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Migrate the current thread.  <a href="#ga4d14486d26a32a2660697f5a88d8301d"></a><br/></td></tr>
<tr class="memitem:gafd49fb1aa94c5f44f8c23d66a77b5581"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#gafd49fb1aa94c5f44f8c23d66a77b5581">xnpod_dispatch_signals</a> (void)</td></tr>
<tr class="memdesc:gafd49fb1aa94c5f44f8c23d66a77b5581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deliver pending asynchronous signals to the running thread.  <a href="#gafd49fb1aa94c5f44f8c23d66a77b5581"></a><br/></td></tr>
<tr class="memitem:gacf5b53f0405351327b89b0cc4976b962"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#gacf5b53f0405351327b89b0cc4976b962">xnpod_schedule</a> (void)</td></tr>
<tr class="memdesc:gacf5b53f0405351327b89b0cc4976b962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rescheduling procedure entry point.  <a href="#gacf5b53f0405351327b89b0cc4976b962"></a><br/></td></tr>
<tr class="memitem:gaed5776a428e7c59b52b1da76f0d765fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#gaed5776a428e7c59b52b1da76f0d765fa">xnpod_set_thread_periodic</a> (xnthread_t *thread, xnticks_t idate, xnticks_t period)</td></tr>
<tr class="memdesc:gaed5776a428e7c59b52b1da76f0d765fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a thread periodic.  <a href="#gaed5776a428e7c59b52b1da76f0d765fa"></a><br/></td></tr>
<tr class="memitem:gaf836996e4a3378928f2a9f93a4915cfa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#gaf836996e4a3378928f2a9f93a4915cfa">xnpod_wait_thread_period</a> (unsigned long *overruns_r)</td></tr>
<tr class="memdesc:gaf836996e4a3378928f2a9f93a4915cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the next periodic release point.  <a href="#gaf836996e4a3378928f2a9f93a4915cfa"></a><br/></td></tr>
<tr class="memitem:ga4b8647e7a6969962c788669ff8d46d3b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#ga4b8647e7a6969962c788669ff8d46d3b">xnpod_set_thread_tslice</a> (struct xnthread *thread, xnticks_t quantum)</td></tr>
<tr class="memdesc:ga4b8647e7a6969962c788669ff8d46d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set thread time-slicing information.  <a href="#ga4b8647e7a6969962c788669ff8d46d3b"></a><br/></td></tr>
<tr class="memitem:ga96e6b70fb05da3603bebacde76b16f22"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#ga96e6b70fb05da3603bebacde76b16f22">xnpod_add_hook</a> (int type, void(*routine)(xnthread_t *))</td></tr>
<tr class="memdesc:ga96e6b70fb05da3603bebacde76b16f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install a nucleus hook.  <a href="#ga96e6b70fb05da3603bebacde76b16f22"></a><br/></td></tr>
<tr class="memitem:gace800481d23255eebe45f969e9434adf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#gace800481d23255eebe45f969e9434adf">xnpod_remove_hook</a> (int type, void(*routine)(xnthread_t *))</td></tr>
<tr class="memdesc:gace800481d23255eebe45f969e9434adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a nucleus hook.  <a href="#gace800481d23255eebe45f969e9434adf"></a><br/></td></tr>
<tr class="memitem:ga657259b9accb3be41574f9970baef393"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#ga657259b9accb3be41574f9970baef393">xnpod_welcome_thread</a> (xnthread_t *thread, int imask)</td></tr>
<tr class="memdesc:ga657259b9accb3be41574f9970baef393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread prologue.  <a href="#ga657259b9accb3be41574f9970baef393"></a><br/></td></tr>
<tr class="memitem:gaf95cac21ec23e44282461905dd3fc153"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#gaf95cac21ec23e44282461905dd3fc153">xnpod_trap_fault</a> (xnarch_fltinfo_t *fltinfo)</td></tr>
<tr class="memdesc:gaf95cac21ec23e44282461905dd3fc153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default fault handler.  <a href="#gaf95cac21ec23e44282461905dd3fc153"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<p>Real-time pod services. </p>
<h2>Function Documentation</h2>
<a class="anchor" id="ga75278c2ac6f43741eca9cc1d60072eac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnpod_abort_thread </td>
          <td>(</td>
          <td class="paramtype">xnthread_t *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abort a thread. </p>
<p>Unconditionally terminates a thread and releases all the nucleus resources it currently holds, regardless of whether the target thread is currently active in kernel or user-space. <a class="el" href="group__pod.html#ga75278c2ac6f43741eca9cc1d60072eac" title="Abort a thread.">xnpod_abort_thread()</a> should be reserved for use by skin cleanup routines; <a class="el" href="group__pod.html#gad2b761fb70cad30339f092edb4a89587" title="Delete a thread.">xnpod_delete_thread()</a> should be preferred as the common method for removing threads from a running system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The descriptor address of the terminated thread.</td></tr>
  </table>
  </dd>
</dl>
<p>This service forces a call to <a class="el" href="group__pod.html#gad2b761fb70cad30339f092edb4a89587" title="Delete a thread.">xnpod_delete_thread()</a> for the target thread.</p>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: possible if the current thread self-deletes. </p>

<p>References <a class="el" href="group__nucleus__info__flags.html#gab4d67b921f5bff0675e12ea03c4af9e4">XNABORT</a>, <a class="el" href="group__nucleus__state__flags.html#ga5fa9672a03ebd4beaf7ab3caa5699fa6">XNDORMANT</a>, <a class="el" href="group__pod.html#gad2b761fb70cad30339f092edb4a89587">xnpod_delete_thread()</a>, and <a class="el" href="group__pod.html#ga767221cf87c198c5dc071e9f597dcb3a">xnpod_suspend_thread()</a>.</p>

</div>
</div>
<a class="anchor" id="ga96e6b70fb05da3603bebacde76b16f22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnpod_add_hook </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(xnthread_t *)&#160;</td>
          <td class="paramname"><em>routine</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install a nucleus hook. </p>
<p>The nucleus allows to register user-defined routines which get called whenever a specific scheduling event occurs. Multiple hooks can be chained for a single event type, and get called on a FIFO basis.</p>
<p>The scheduling is locked while a hook is executing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Defines the kind of hook to install: <pre class="fragment">   - XNHOOK_THREAD_START: The user-defined routine will be
   called on behalf of the starter thread whenever a new thread
   starts. The descriptor address of the started thread is
   passed to the routine.

   - XNHOOK_THREAD_DELETE: The user-defined routine will be
   called on behalf of the deletor thread whenever a thread is
   deleted. The descriptor address of the deleted thread is
   passed to the routine.

   - XNHOOK_THREAD_SWITCH: The user-defined routine will be
   called on behalf of the resuming thread whenever a context
   switch takes place. The descriptor address of the thread
   which has been switched out is passed to the routine.
</pre></td></tr>
    <tr><td class="paramname">routine</td><td>The address of the user-supplied routine to call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned on success. Otherwise, one of the following error codes indicates the cause of the failure: <pre class="fragment">    - -EINVAL is returned if type is incorrect.

    - -ENOMEM is returned if not enough memory is available
    from the system heap to add the new hook.
</pre></dd></dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: never. </p>

<p>Referenced by <a class="el" href="group__task.html#ga7452f367f9e17bf2fc0b70f717b96dd8">rt_task_add_hook()</a>.</p>

</div>
</div>
<a class="anchor" id="gad2b761fb70cad30339f092edb4a89587"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnpod_delete_thread </td>
          <td>(</td>
          <td class="paramtype">xnthread_t *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a thread. </p>
<p>Terminates a thread and releases all the nucleus resources it currently holds. A thread exists in the system since <a class="el" href="group__pod.html#gad71ebccc5b7b3d367f65127a8849c036" title="Initialize a new thread.">xnpod_init_thread()</a> has been called to create it, so this service must be called in order to destroy it afterwards.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The descriptor address of the terminated thread.</td></tr>
  </table>
  </dd>
</dl>
<p>The target thread's resources may not be immediately removed if this is an active shadow thread running in user-space. In such a case, the mated Linux task is sent a termination signal instead, and the actual deletion is deferred until the task exit event is called.</p>
<p>The DELETE hooks are called on behalf of the calling context (if any). The information stored in the thread control block remains valid until all hooks have been called.</p>
<p>Self-terminating a thread is allowed. In such a case, this service does not return to the caller.</p>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: possible if the current thread self-deletes. </p>

<p>References <a class="el" href="structxnsched.html#afd2e6c15e470a38b385930c613856e7b">xnsched::curr</a>, <a class="el" href="structxnsched.html#a4e9ca82832cb0709308e7d78e7f9d694">xnsched::lflags</a>, <a class="el" href="structxnsched.html#ad700d0003b158a60599221047b2fc52e">xnsched::status</a>, <a class="el" href="group__nucleus__info__flags.html#gab4d67b921f5bff0675e12ea03c4af9e4">XNABORT</a>, <a class="el" href="group__nucleus__info__flags.html#ga544132c42225c5240327d0554cfaeff0">XNCANPND</a>, <a class="el" href="group__nucleus__state__flags.html#ga4a3196a5300e6ec862a18b272d859960">XNDEFCAN</a>, <a class="el" href="group__nucleus__state__flags.html#gae9aeb1b75ad94bca4f56f57481ffc309">XNMIGRATE</a>, <a class="el" href="group__nucleus__state__flags.html#ga153b45ee5ddcc4da154ca8a018ac1871">XNPEND</a>, <a class="el" href="group__pod.html#gacf5b53f0405351327b89b0cc4976b962">xnpod_schedule()</a>, <a class="el" href="group__pod.html#gae5f0d19e7a499b9b262f68a43ab545dd">xnpod_unblock_thread()</a>, <a class="el" href="group__nucleus__state__flags.html#ga93d516291e0645195b35d63fbf0e0433">XNREADY</a>, <a class="el" href="group__nucleus__state__flags.html#ga73d7b1a4f5a25545ff21140a0598075a">XNROOT</a>, <a class="el" href="group__select.html#ga9f4741ca8d6794f1b45478a24b1104de">xnselector_destroy()</a>, <a class="el" href="group__synch.html#ga997e546948920193bb36ab8d120fbab7">xnsynch_forget_sleeper()</a>, <a class="el" href="group__synch.html#ga51146a2d5bd0ec6a10d2fcd685946938">xnsynch_release_all_ownerships()</a>, <a class="el" href="group__timer.html#ga782e10b2cd24a5c303b316375940ca15">xntimer_destroy()</a>, and <a class="el" href="group__nucleus__state__flags.html#gaa5b9ff889ab0bfbfb96a435cbea25d6a">XNZOMBIE</a>.</p>

<p>Referenced by <a class="el" href="group__task.html#ga03387550693c21d0223f739570ccd992">rt_task_create()</a>, <a class="el" href="group__task.html#gab6e0d411830710e8cc82d77b9df19510">rt_task_delete()</a>, <a class="el" href="group__rtdmtask.html#ga44b0701b6c28fa8035711f800fdcd371">rtdm_task_init()</a>, <a class="el" href="group__pod.html#ga75278c2ac6f43741eca9cc1d60072eac">xnpod_abort_thread()</a>, and <a class="el" href="group__pod.html#ga824dc22468666c9f14da1842f0184b84">xnpod_shutdown()</a>.</p>

</div>
</div>
<a class="anchor" id="ga179f47d6e98446843f059790112dcce3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnpod_disable_timesource </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop the core time source. </p>
<p>Releases the hardware timer, and deactivates the master time base.</p>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>User-space task in secondary mode</li>
</ul>
<p>Rescheduling: never. </p>

<p>References <a class="el" href="group__timer.html#ga5cad677279089ef19d3710b1b6452a71">xntimer_freeze()</a>.</p>

<p>Referenced by <a class="el" href="group__pod.html#ga824dc22468666c9f14da1842f0184b84">xnpod_shutdown()</a>.</p>

</div>
</div>
<a class="anchor" id="gafd49fb1aa94c5f44f8c23d66a77b5581"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnpod_dispatch_signals </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deliver pending asynchronous signals to the running thread. </p>
<p>This internal routine checks for the presence of asynchronous signals directed to the running thread, and attempts to start the asynchronous service routine (ASR) if any. Called with nklock locked, interrupts off. </p>

<p>References <a class="el" href="group__nucleus__state__flags.html#gadd8332af5954bcc409e8a1181005cd86">XNASDI</a>.</p>

<p>Referenced by <a class="el" href="group__pod.html#ga657259b9accb3be41574f9970baef393">xnpod_welcome_thread()</a>, and <a class="el" href="group__shadow.html#ga5f631762c7381866d70177afb2ba123b">xnshadow_harden()</a>.</p>

</div>
</div>
<a class="anchor" id="ga10d3c13efa3ab06ac23017710b13314e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnpod_enable_timesource </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Activate the core time source. </p>
<p>Xenomai implements the notion of time base, by which software timers that belong to different skins may be clocked separately according to distinct frequencies, or aperiodically. In the periodic case, delays and timeouts are given in counts of ticks; the duration of a tick is specified by the time base. In the aperiodic case, timings are directly specified in nanoseconds.</p>
<p>Only a single aperiodic (i.e. tick-less) time base may exist in the system, and the nucleus provides for it through the nktbase object. All skins depending on aperiodic timings should bind to the latter, also known as the master time base. Skins depending on periodic timings may create and bind to their own time base. Such a periodic time base is managed as a slave object of the master one. A cascading software timer, which is fired by the master time base according to the appropriate frequency, triggers in turn the update process of the associated slave time base, which eventually fires the elapsed software timers controlled by the latter.</p>
<p>Xenomai always controls the underlying hardware timer in a tick-less fashion, also known as the oneshot mode. The <a class="el" href="group__pod.html#ga10d3c13efa3ab06ac23017710b13314e" title="Activate the core time source.">xnpod_enable_timesource()</a> service configures the timer chip as needed, and activates the master time base.</p>
<dl class="section return"><dt>Returns</dt><dd>0 is returned on success. Otherwise:</dd></dl>
<ul>
<li>-ENODEV is returned if a failure occurred while configuring the hardware timer.</li>
</ul>
<ul>
<li>-ENOSYS is returned if no active pod exists.</li>
</ul>
<p>Side-effect: A host timing service is started in order to relay the canonical periodical tick to the underlying architecture, regardless of the frequency used for Xenomai's system tick. This routine does not call the rescheduling procedure.</p>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>User-space task in secondary mode</li>
</ul>
<p>Rescheduling: never.</p>
<dl class="section note"><dt>Note</dt><dd>Built-in support for periodic timing depends on CONFIG_XENO_OPT_TIMING_PERIODIC. </dd></dl>

<p>References <a class="el" href="structxnsched.html#ae2818d36a93ef25f121c67f2ff34d236">xnsched::htimer</a>, <a class="el" href="group__intr.html#ga6017e33c5871d313b4de053d938dd95b">xnintr_init()</a>, and <a class="el" href="group__timer.html#ga0ad3c70bed7fe1a45b45ee0875f031ab">xntimer_start()</a>.</p>

<p>Referenced by <a class="el" href="group__pod.html#ga167bb3b4251ac8b8a3e7f358d236908a">xnpod_init()</a>.</p>

</div>
</div>
<a class="anchor" id="ga167bb3b4251ac8b8a3e7f358d236908a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnpod_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the core pod. </p>
<p>Initializes the core interface pod which can subsequently be used to start real-time activities. Once the core pod is active, real-time skins can be stacked over. There can only be a single core pod active in the host environment. Such environment can be confined to a process (e.g. simulator), or expand machine-wide (e.g. I-pipe).</p>
<dl class="section return"><dt>Returns</dt><dd>0 is returned on success. Otherwise:</dd></dl>
<ul>
<li>-ENOMEM is returned if the memory manager fails to initialize.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization code </li>
</ul>

<p>References <a class="el" href="structxnpod.html#a26e8700e411f5292fa5372aa2faa28f6">xnpod::refcnt</a>, <a class="el" href="structxnsched.html#a0804d68b819bdf478bb74b8baa3954bb">xnsched::rootcb</a>, <a class="el" href="structxnpod.html#a8f4d9384fc5c6b00d9e403d50c7f5b47">xnpod::sched</a>, <a class="el" href="structxnpod.html#a7b0b15bd11482596b1affb73f4fe54ff">xnpod::status</a>, <a class="el" href="structxnpod.html#a20ab294c2e3b46322f11260ad8b44f4d">xnpod::tdeleteq</a>, <a class="el" href="structxnpod.html#a7937ecf81ab970ab2189dd6208dc3679">xnpod::threadq</a>, <a class="el" href="structxnpod.html#a9a61219dd75a7b26024a79a73bce6540">xnpod::timerlck</a>, <a class="el" href="structxnpod.html#af29706fbb96466d41e15421454bdb53c">xnpod::tsliced</a>, <a class="el" href="structxnpod.html#a86acf95fd43b98008659bfdd38c6af9b">xnpod::tslicer</a>, <a class="el" href="structxnpod.html#a1bb945357ab40191bbd55252dc2218dc">xnpod::tstartq</a>, <a class="el" href="structxnpod.html#afbd1d126d1d74f3d433d164e404a0d2f">xnpod::tswitchq</a>, <a class="el" href="group__heap.html#gaf33cea7788162687767ca7c8c149f6ab">xnheap_destroy()</a>, <a class="el" href="group__heap.html#gad65beaf18754ad1f85c479eaf9219042">xnheap_init()</a>, <a class="el" href="group__heap.html#gabfa339d98cfd2271b5d80d64b20c0e2c">xnheap_set_label()</a>, <a class="el" href="group__pod.html#ga10d3c13efa3ab06ac23017710b13314e">xnpod_enable_timesource()</a>, <a class="el" href="group__pod.html#ga824dc22468666c9f14da1842f0184b84">xnpod_shutdown()</a>, and <a class="el" href="group__timer.html#ga834e46fb4c1ecaab949eea77b9dee284">xntimer_init()</a>.</p>

</div>
</div>
<a class="anchor" id="gad71ebccc5b7b3d367f65127a8849c036"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnpod_init_thread </td>
          <td>(</td>
          <td class="paramtype">struct xnthread *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct xnthread_init_attr *&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct xnsched_class *&#160;</td>
          <td class="paramname"><em>sched_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const union xnsched_policy_param *&#160;</td>
          <td class="paramname"><em>sched_param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a new thread. </p>
<p>Initializes a new thread attached to the active pod. The thread is left in an innocuous state until it is actually started by <a class="el" href="group__pod.html#gad322f6afd62430705486a9036d0b7d66" title="Initial start of a newly created thread.">xnpod_start_thread()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The address of a thread descriptor the nucleus will use to store the thread-specific data. This descriptor must always be valid while the thread is active therefore it must be allocated in permanent memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Some architectures may require the descriptor to be properly aligned in memory; this is an additional reason for descriptors not to be laid in the program stack where alignement constraints might not always be satisfied.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>A pointer to an attribute block describing the initial properties of the new thread. Members of this structure are defined as follows:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>name: An ASCII string standing for the symbolic name of the thread. This name is copied to a safe place into the thread descriptor. This name might be used in various situations by the nucleus for issuing human-readable diagnostic messages, so it is usually a good idea to provide a sensible value here. The simulator even uses this name intensively to identify threads in the debugging GUI it provides. However, passing NULL here is always legal and means "anonymous".</li>
</ul>
<ul>
<li>tbase: The time base descriptor to refer to for all timed operations issued by the new thread. See <a class="el" href="group__timebase.html#gafcb0a76ac26eaaa768db89cb54e3f24a" title="Allocate a time base.">xntbase_alloc()</a> for detailed explanations about time bases.</li>
</ul>
<ul>
<li><p class="startli">flags: A set of creation flags affecting the operation. The following flags can be part of this bitmask, each of them affecting the nucleus behaviour regarding the created thread:</p>
<ul>
<li>XNSUSP creates the thread in a suspended state. In such a case, the thread will have to be explicitly resumed using the <a class="el" href="group__pod.html#gac3a7bf9e973782a8cfd6495a1786e812" title="Resume a thread.">xnpod_resume_thread()</a> service for its execution to actually begin, additionally to issuing <a class="el" href="group__pod.html#gad322f6afd62430705486a9036d0b7d66" title="Initial start of a newly created thread.">xnpod_start_thread()</a> for it. This flag can also be specified when invoking <a class="el" href="group__pod.html#gad322f6afd62430705486a9036d0b7d66" title="Initial start of a newly created thread.">xnpod_start_thread()</a> as a starting mode.</li>
</ul>
<ul>
<li>XNFPU (enable FPU) tells the nucleus that the new thread will use the floating-point unit. In such a case, the nucleus will handle the FPU context save/restore ops upon thread switches at the expense of a few additional cycles per context switch. By default, a thread is not expected to use the FPU. This flag is simply ignored when the nucleus runs on behalf of a userspace-based real-time control layer since the FPU management is always active if present.</li>
</ul>
</li>
</ul>
<ul>
<li>stacksize: The size of the stack (in bytes) for the new thread. If zero is passed, the nucleus will use a reasonable pre-defined size depending on the underlying real-time control layer.</li>
</ul>
<ul>
<li>ops: A pointer to a structure defining the class-level operations available for this thread. Fields from this structure must have been set appropriately by the caller.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sched_class</td><td>The initial scheduling class the new thread should be assigned to.</td></tr>
    <tr><td class="paramname">sched_param</td><td>The initial scheduling parameters to set for the new thread; <em>sched_param</em> must be valid within the context of <em>sched_class</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned on success. Otherwise, one of the following error codes indicates the cause of the failure: <pre class="fragment">    - -EINVAL is returned if @a attr-&gt;flags has invalid bits set.

    - -ENOMEM is returned if not enough memory is available
    from the system heap to create the new thread's stack.
</pre></dd></dl>
<p>Side-effect: This routine does not call the rescheduling procedure.</p>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: never. </p>

<p>References <a class="el" href="group__nucleus__state__flags.html#ga5fa9672a03ebd4beaf7ab3caa5699fa6">XNDORMANT</a>, <a class="el" href="group__nucleus__state__flags.html#ga6b2ca9336a15f94f3a2e0665982ed081">XNFPU</a>, <a class="el" href="group__pod.html#ga767221cf87c198c5dc071e9f597dcb3a">xnpod_suspend_thread()</a>, <a class="el" href="group__nucleus__state__flags.html#gac664c3bae93da4141d2fc8e88a91afd8">XNSHADOW</a>, and <a class="el" href="group__nucleus__state__flags.html#ga6b605ad2bb16ae2386821be8ce8d341b">XNSUSP</a>.</p>

<p>Referenced by <a class="el" href="group__posix__thread.html#gae6e819ed048e4c4a4ee96fa6f426852c">pthread_create()</a>, <a class="el" href="group__task.html#ga03387550693c21d0223f739570ccd992">rt_task_create()</a>, and <a class="el" href="group__rtdmtask.html#ga44b0701b6c28fa8035711f800fdcd371">rtdm_task_init()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4d14486d26a32a2660697f5a88d8301d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnpod_migrate_thread </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cpu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Migrate the current thread. </p>
<p>This call makes the current thread migrate to another CPU if its affinity allows it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu</td><td>The destination CPU.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if the thread could migrate ; </td></tr>
    <tr><td class="paramname">-EPERM</td><td>if the calling context is asynchronous, or the current thread affinity forbids this migration ; </td></tr>
    <tr><td class="paramname">-EBUSY</td><td>if the scheduler is locked. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group__pod.html#gacf5b53f0405351327b89b0cc4976b962">xnpod_schedule()</a>.</p>

</div>
</div>
<a class="anchor" id="gace800481d23255eebe45f969e9434adf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnpod_remove_hook </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(xnthread_t *)&#160;</td>
          <td class="paramname"><em>routine</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a nucleus hook. </p>
<p>This service removes a nucleus hook previously registered using <a class="el" href="group__pod.html#ga96e6b70fb05da3603bebacde76b16f22" title="Install a nucleus hook.">xnpod_add_hook()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Defines the kind of hook to remove among XNHOOK_THREAD_START, XNHOOK_THREAD_DELETE and XNHOOK_THREAD_SWITCH.</td></tr>
    <tr><td class="paramname">routine</td><td>The address of the user-supplied routine to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned on success. Otherwise, -EINVAL is returned if type is incorrect or if the routine has never been registered before.</dd></dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: never. </p>

<p>Referenced by <a class="el" href="group__task.html#ga585bcffb3757845534eed69edd1a27d2">rt_task_remove_hook()</a>.</p>

</div>
</div>
<a class="anchor" id="ga61624578d0f1979f1ca6a5e9e49a74a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnpod_restart_thread </td>
          <td>(</td>
          <td class="paramtype">xnthread_t *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restart a thread. </p>
<p>Restarts a previously started thread. The thread is first terminated then respawned using the same information that prevailed when it was first started, including the mode bits and interrupt mask initially passed to the <a class="el" href="group__pod.html#gad322f6afd62430705486a9036d0b7d66" title="Initial start of a newly created thread.">xnpod_start_thread()</a> service. As a consequence of this call, the thread entry point is rerun.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The descriptor address of the affected thread which must have been previously started by the <a class="el" href="group__pod.html#gad322f6afd62430705486a9036d0b7d66" title="Initial start of a newly created thread.">xnpod_start_thread()</a> service.</td></tr>
  </table>
  </dd>
</dl>
<p>Self-restarting a thread is allowed. However, restarting the root thread is not. Restarting a thread which was never started once leads to a null-effect.</p>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
</ul>
<p>Rescheduling: possible. </p>

<p>References <a class="el" href="group__pod.html#gacf5b53f0405351327b89b0cc4976b962">xnpod_schedule()</a>, <a class="el" href="group__nucleus__state__flags.html#gacc86813fad4e877dcc16b98cdb64ef60">XNRESTART</a>, <a class="el" href="group__nucleus__state__flags.html#ga73d7b1a4f5a25545ff21140a0598075a">XNROOT</a>, <a class="el" href="group__nucleus__state__flags.html#gac664c3bae93da4141d2fc8e88a91afd8">XNSHADOW</a>, and <a class="el" href="group__nucleus__state__flags.html#ga0843357a4c7a592e9d5f9cb1ce84ea8e">XNSTARTED</a>.</p>

</div>
</div>
<a class="anchor" id="gac3a7bf9e973782a8cfd6495a1786e812"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnpod_resume_thread </td>
          <td>(</td>
          <td class="paramtype">xnthread_t *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnflags_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume a thread. </p>
<p>Resumes the execution of a thread previously suspended by one or more calls to <a class="el" href="group__pod.html#ga767221cf87c198c5dc071e9f597dcb3a" title="Suspend a thread.">xnpod_suspend_thread()</a>. This call removes a suspensive condition affecting the target thread. When all suspensive conditions are gone, the thread is left in a READY state at which point it becomes eligible anew for scheduling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The descriptor address of the resumed thread.</td></tr>
    <tr><td class="paramname">mask</td><td>The suspension mask specifying the suspensive condition to remove from the thread's wait mask. Possible values usable by the caller are:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>XNSUSP. This flag removes the explicit suspension condition. This condition might be additive to the XNPEND condition.</li>
</ul>
<ul>
<li>XNDELAY. This flag removes the counted delay wait condition.</li>
</ul>
<ul>
<li>XNPEND. This flag removes the resource wait condition. If a watchdog is armed, it is automatically disarmed by this call. Unlike the two previous conditions, only the current thread can set this condition for itself, i.e. no thread can force another one to pend on a resource.</li>
</ul>
<p>When the thread is eventually resumed by one or more calls to <a class="el" href="group__pod.html#gac3a7bf9e973782a8cfd6495a1786e812" title="Resume a thread.">xnpod_resume_thread()</a>, the caller of <a class="el" href="group__pod.html#ga767221cf87c198c5dc071e9f597dcb3a" title="Suspend a thread.">xnpod_suspend_thread()</a> in the awakened thread that suspended itself should check for the following bits in its own information mask to determine what caused its wake up:</p>
<ul>
<li>XNRMID means that the caller must assume that the pended synchronization object has been destroyed (see <a class="el" href="group__synch.html#ga82beb68147bc5f0306ab02a61a9dc76b" title="Unblock all waiters pending on a resource.">xnsynch_flush()</a>).</li>
</ul>
<ul>
<li>XNTIMEO means that the delay elapsed, or the watchdog went off before the corresponding synchronization object was signaled.</li>
</ul>
<ul>
<li>XNBREAK means that the wait has been forcibly broken by a call to <a class="el" href="group__pod.html#gae5f0d19e7a499b9b262f68a43ab545dd" title="Unblock a thread.">xnpod_unblock_thread()</a>.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: never. </p>

<p>References <a class="el" href="structxnsched.html#afd2e6c15e470a38b385930c613856e7b">xnsched::curr</a>, <a class="el" href="group__nucleus__state__flags.html#gaa31d298d298eb696ccf840473b94912c">XNDELAY</a>, <a class="el" href="group__nucleus__state__flags.html#ga9394cc02e730535e3dd8b0aabb08ea86">XNHELD</a>, <a class="el" href="group__nucleus__state__flags.html#ga153b45ee5ddcc4da154ca8a018ac1871">XNPEND</a>, <a class="el" href="group__nucleus__state__flags.html#ga93d516291e0645195b35d63fbf0e0433">XNREADY</a>, <a class="el" href="group__synch.html#ga997e546948920193bb36ab8d120fbab7">xnsynch_forget_sleeper()</a>, and <a class="el" href="group__timer.html#ga1244411df9784d63d3e2f99016d62643">xntimer_stop()</a>.</p>

<p>Referenced by <a class="el" href="group__posix__signal.html#ga5aafacc071cdfafd0eb992004dee3e62">pthread_kill()</a>, <a class="el" href="group__task.html#ga1fab1aa24ef6f199546fd9669ae711be">rt_task_resume()</a>, <a class="el" href="group__pod.html#gad322f6afd62430705486a9036d0b7d66">xnpod_start_thread()</a>, <a class="el" href="group__pod.html#gae5f0d19e7a499b9b262f68a43ab545dd">xnpod_unblock_thread()</a>, <a class="el" href="group__synch.html#ga82beb68147bc5f0306ab02a61a9dc76b">xnsynch_flush()</a>, <a class="el" href="group__synch.html#gad5992ddbdb81821cb29bae8900eb65ac">xnsynch_wakeup_one_sleeper()</a>, and <a class="el" href="group__synch.html#ga9e530d12df9881251231af489208762e">xnsynch_wakeup_this_sleeper()</a>.</p>

</div>
</div>
<a class="anchor" id="gacf5b53f0405351327b89b0cc4976b962"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xnpod_schedule </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rescheduling procedure entry point. </p>
<p>This is the central rescheduling routine which should be called to validate and apply changes which have previously been made to the nucleus scheduling state, such as suspending, resuming or changing the priority of threads. This call first determines if a thread switch should take place, and performs it as needed. <a class="el" href="group__pod.html#gacf5b53f0405351327b89b0cc4976b962" title="Rescheduling procedure entry point.">xnpod_schedule()</a> schedules out the current thread if:</p>
<ul>
<li>the current thread is now blocked or deleted.</li>
<li>a runnable thread from a higher priority scheduling class is waiting for the CPU.</li>
<li>the current thread does not lead the runnable threads from its own scheduling class (e.g. round-robin in the RT class).</li>
</ul>
<p>The nucleus implements a lazy rescheduling scheme so that most of the services affecting the threads state MUST be followed by a call to the rescheduling procedure for the new scheduling state to be applied. In other words, multiple changes on the scheduler state can be done in a row, waking threads up, blocking others, without being immediately translated into the corresponding context switches, like it would be necessary would it appear that a higher priority thread than the current one became runnable for instance. When all changes have been applied, the rescheduling procedure is then called to consider those changes, and possibly replace the current thread by another one.</p>
<p>As a notable exception to the previous principle however, every action which ends up suspending or deleting the current thread begets an immediate call to the rescheduling procedure on behalf of the service causing the state transition. For instance, self-suspension, self-destruction, or sleeping on a synchronization object automatically leads to a call to the rescheduling procedure, therefore the caller does not need to explicitly issue <a class="el" href="group__pod.html#gacf5b53f0405351327b89b0cc4976b962" title="Rescheduling procedure entry point.">xnpod_schedule()</a> after such operations.</p>
<p>The rescheduling procedure always leads to a null-effect if it is called on behalf of an ISR or callout. Any outstanding scheduler lock held by the outgoing thread will be restored when the thread is scheduled back in.</p>
<p>Calling this procedure with no applicable context switch pending is harmless and simply leads to a null-effect.</p>
<p>Side-effects:</p>
<ul>
<li>If an asynchronous service routine exists, the pending asynchronous signals are delivered to a resuming thread or on behalf of the caller before it returns from the procedure if no context switch has taken place. This behaviour can be disabled by setting the XNASDI flag in the thread's status mask by calling <a class="el" href="group__pod.html#ga629c06b152dabfdb679b6e49bd9f7734" title="Change a thread&#39;s control mode.">xnpod_set_thread_mode()</a>.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine, although this leads to a no-op.</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The switch hooks are called on behalf of the resuming thread. </dd></dl>

<p>References <a class="el" href="structxnsched.html#a4e9ca82832cb0709308e7d78e7f9d694">xnsched::lflags</a>, and <a class="el" href="structxnsched.html#ad700d0003b158a60599221047b2fc52e">xnsched::status</a>.</p>

<p>Referenced by <a class="el" href="group__posix__cancel.html#ga9e77a80c073787bf9a593e9c619dce27">pthread_cancel()</a>, <a class="el" href="group__posix__cond.html#gaabb82be87ab0b0a96fc68d4a83c2f343">pthread_cond_broadcast()</a>, <a class="el" href="group__posix__cond.html#ga691c7dd41acc6a4f25561a13158b0933">pthread_cond_signal()</a>, <a class="el" href="group__posix__thread.html#ga7c275c509c26566b6dd95a2de1668a2f">pthread_detach()</a>, <a class="el" href="group__posix__thread.html#gaa79c99cc7b194918a2def257246f11c6">pthread_join()</a>, <a class="el" href="group__posix__signal.html#ga5aafacc071cdfafd0eb992004dee3e62">pthread_kill()</a>, <a class="el" href="group__posix__mutex.html#gab6fc0b5282dd100530311128e4f5ff19">pthread_mutex_unlock()</a>, <a class="el" href="group__posix__thread.html#ga9dd3db5524fccb05a8868b7c33ccaa79">pthread_set_mode_np()</a>, <a class="el" href="group__posix__sched.html#ga95276f88e1a2cae7a37f792123a99144">pthread_setschedparam()</a>, <a class="el" href="group__posix__sched.html#gad5eceef44b79a09a1a86e7a1950a74e7">pthread_setschedparam_ex()</a>, <a class="el" href="group__posix__signal.html#gac2530d4faf68aaab3605c92ea8e78a03">pthread_sigmask()</a>, <a class="el" href="group__posix__signal.html#ga64f37159dcc60bf98364a8950fd05338">pthread_sigqueue_np()</a>, <a class="el" href="group__alarm.html#gaf00e05b47b1183816480e270d326f9ac">rt_alarm_delete()</a>, <a class="el" href="group__buffer.html#gaf78c43664dda8a17c5c63ad4be2da179">rt_buffer_clear()</a>, <a class="el" href="group__buffer.html#gabd852c3c957d2dd37c15899119a3551e">rt_buffer_delete()</a>, <a class="el" href="group__cond.html#ga37c6424e266f5c1df3439116dd429878">rt_cond_broadcast()</a>, <a class="el" href="group__cond.html#gaba59b188f10b142b4f2500dd719aa35f">rt_cond_delete()</a>, <a class="el" href="group__cond.html#gab7a59ee47db48a78ca45e4655b569dc9">rt_cond_signal()</a>, <a class="el" href="group__event.html#gabccfea1cd018493ef5a28c6fe8e90d7c">rt_event_delete()</a>, <a class="el" href="group__event.html#gafda4c544f2429005c4b15de3a7ffc902">rt_event_signal()</a>, <a class="el" href="group__native__heap.html#ga300ca8c868d02dad99790fe39b443f6f">rt_heap_free()</a>, <a class="el" href="group__interrupt.html#ga6da6ddd4e65b0feb47278dae74cab6c9">rt_intr_delete()</a>, <a class="el" href="group__mutex.html#gad0c2342227f821bd09f580b6a9684179">rt_mutex_delete()</a>, <a class="el" href="group__mutex.html#gac87911b7279f55ef2f5f9aefe36ff070">rt_mutex_release()</a>, <a class="el" href="group__native__queue.html#ga8b1dcb15753bdfce02f25f166e18948d">rt_queue_send()</a>, <a class="el" href="group__semaphore.html#ga4a8963240e68d164a2e5bb148da44fbc">rt_sem_broadcast()</a>, <a class="el" href="group__semaphore.html#gaa14cefc4dae46a7c95859e7fe46df888">rt_sem_delete()</a>, <a class="el" href="group__semaphore.html#gaa5a7927862a511a27741223e08e48270">rt_sem_v()</a>, <a class="el" href="group__task.html#ga8e17be7a49ac32bbeb3085b3cd1a9915">rt_task_catch()</a>, <a class="el" href="group__task.html#ga70e65c2efb499c48c6d15010a1c630a3">rt_task_notify()</a>, <a class="el" href="group__task.html#gacd8a4fb2d11f0548bd053dfbf92f9e9d">rt_task_reply()</a>, <a class="el" href="group__task.html#ga1fab1aa24ef6f199546fd9669ae711be">rt_task_resume()</a>, <a class="el" href="group__task.html#ga915e7edfb0aaddb643794d7abc7093bf">rt_task_set_mode()</a>, <a class="el" href="group__task.html#ga3bed8d001e212a3328a4e7e73f1765e8">rt_task_set_priority()</a>, <a class="el" href="group__task.html#ga770281eeca009c0a08a7c4a9fd849ac1">rt_task_unblock()</a>, <a class="el" href="group__rtdmsync.html#ga1217402b82034b26fe25c26f1e5b32c9">rtdm_event_signal()</a>, <a class="el" href="group__rtdmsync.html#ga829dbd8c5709d798ed06947b27001fed">rtdm_sem_up()</a>, <a class="el" href="group__posix__sem.html#ga3ceb2577b76aaad3be6fd83e959c66e3">sem_post()</a>, <a class="el" href="group__pod.html#gad2b761fb70cad30339f092edb4a89587">xnpod_delete_thread()</a>, <a class="el" href="group__pod.html#ga4d14486d26a32a2660697f5a88d8301d">xnpod_migrate_thread()</a>, <a class="el" href="group__pod.html#ga61624578d0f1979f1ca6a5e9e49a74a3">xnpod_restart_thread()</a>, <a class="el" href="group__pod.html#ga824dc22468666c9f14da1842f0184b84">xnpod_shutdown()</a>, <a class="el" href="group__pod.html#gad322f6afd62430705486a9036d0b7d66">xnpod_start_thread()</a>, <a class="el" href="group__pod.html#gad86de7feeb37bbac6f6660916c3fe099">xnpod_stop_thread()</a>, <a class="el" href="group__pod.html#ga767221cf87c198c5dc071e9f597dcb3a">xnpod_suspend_thread()</a>, <a class="el" href="group__registry.html#ga28aefd9be7367aa495753142005e1d5a">xnregistry_enter()</a>, <a class="el" href="group__registry.html#ga632c1545496b004eecb7ce8d41b3aabd">xnregistry_put()</a>, <a class="el" href="group__select.html#ga8546a4a6f997a8c29451673d5b7f0e86">xnselect_bind()</a>, and <a class="el" href="group__select.html#ga56e4b5bf3e35dd80c23e95cad8fa1614">xnselect_destroy()</a>.</p>

</div>
</div>
<a class="anchor" id="ga629c06b152dabfdb679b6e49bd9f7734"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xnflags_t xnpod_set_thread_mode </td>
          <td>(</td>
          <td class="paramtype">xnthread_t *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnflags_t&#160;</td>
          <td class="paramname"><em>clrmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnflags_t&#160;</td>
          <td class="paramname"><em>setmask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change a thread's control mode. </p>
<p>Change the control mode of a given thread. The control mode affects the behaviour of the nucleus regarding the specified thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The descriptor address of the affected thread.</td></tr>
    <tr><td class="paramname">clrmask</td><td>Clears the corresponding bits from the control field before setmask is applied. The scheduler lock held by the current thread can be forcibly released by passing the XNLOCK bit in this mask. In this case, the lock nesting count is also reset to zero.</td></tr>
    <tr><td class="paramname">setmask</td><td>The new thread mode. The following flags can be part of this bitmask, each of them affecting the nucleus behaviour regarding the thread:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>XNLOCK causes the thread to lock the scheduler. The target thread will have to call the xnpod_unlock_sched() service to unlock the scheduler or clear the XNLOCK bit forcibly using this service. A non-preemptible thread may still block, in which case, the lock is reasserted when the thread is scheduled back in.</li>
</ul>
<ul>
<li>XNASDI disables the asynchronous signal handling for this thread. See <a class="el" href="group__pod.html#gacf5b53f0405351327b89b0cc4976b962" title="Rescheduling procedure entry point.">xnpod_schedule()</a> for more on this.</li>
</ul>
<ul>
<li>XNRPIOFF disables thread priority coupling between Xenomai and Linux schedulers. This bit prevents the root Linux thread from inheriting the priority of the running shadow Xenomai thread. Use CONFIG_XENO_OPT_RPIOFF to globally disable priority coupling.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel-based task</li>
<li>User-space task in primary mode.</li>
</ul>
<p>Rescheduling: never, therefore, the caller should reschedule if XNLOCK has been passed into <em>clrmask</em>. </p>

<p>References <a class="el" href="group__nucleus__state__flags.html#ga2defcfb1f04f077baeac9881cbdda627">XNLOCK</a>.</p>

<p>Referenced by <a class="el" href="group__posix__thread.html#ga9dd3db5524fccb05a8868b7c33ccaa79">pthread_set_mode_np()</a>, and <a class="el" href="group__task.html#ga915e7edfb0aaddb643794d7abc7093bf">rt_task_set_mode()</a>.</p>

</div>
</div>
<a class="anchor" id="gaed5776a428e7c59b52b1da76f0d765fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnpod_set_thread_periodic </td>
          <td>(</td>
          <td class="paramtype">xnthread_t *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnticks_t&#160;</td>
          <td class="paramname"><em>idate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnticks_t&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a thread periodic. </p>
<p>Make a thread periodic by programming its first release point and its period in the processor time line. Subsequent calls to <a class="el" href="group__pod.html#gaf836996e4a3378928f2a9f93a4915cfa" title="Wait for the next periodic release point.">xnpod_wait_thread_period()</a> will delay the thread until the next periodic release point in the processor timeline is reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The descriptor address of the affected thread. This thread is immediately delayed until the first periodic release point is reached.</td></tr>
    <tr><td class="paramname">idate</td><td>The initial (absolute) date of the first release point, expressed in clock ticks (see note). The affected thread will be delayed until this point is reached. If <em>idate</em> is equal to XN_INFINITE, the current system date is used, and no initial delay takes place.</td></tr>
    <tr><td class="paramname">period</td><td>The period of the thread, expressed in clock ticks (see note). As a side-effect, passing XN_INFINITE attempts to stop the thread's periodic timer; in the latter case, the routine always exits succesfully, regardless of the previous state of this timer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-ETIMEDOUT is returned <em>idate</em> is different from XN_INFINITE and represents a date in the past.</li>
</ul>
<ul>
<li>-EWOULDBLOCK is returned if the relevant time base has not been initialized by a call to xnpod_init_timebase().</li>
</ul>
<ul>
<li>-EINVAL is returned if <em>period</em> is different from XN_INFINITE but shorter than the scheduling latency value for the target system, as available from /proc/xenomai/latency.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: possible if the operation affects the current thread and <em>idate</em> has not elapsed yet.</p>
<dl class="section note"><dt>Note</dt><dd>The <em>idate</em> and <em>period</em> values will be interpreted as jiffies if <em>thread</em> is bound to a periodic time base (see xnpod_init_thread), or nanoseconds otherwise. </dd></dl>

<p>References <a class="el" href="group__nucleus__state__flags.html#gaa31d298d298eb696ccf840473b94912c">XNDELAY</a>, <a class="el" href="group__pod.html#ga767221cf87c198c5dc071e9f597dcb3a">xnpod_suspend_thread()</a>, <a class="el" href="group__timer.html#ga0ad3c70bed7fe1a45b45ee0875f031ab">xntimer_start()</a>, and <a class="el" href="group__timer.html#ga1244411df9784d63d3e2f99016d62643">xntimer_stop()</a>.</p>

<p>Referenced by <a class="el" href="group__posix__thread.html#gafe8deaa3c89e0a07e59f0e58f9ec1473">pthread_make_periodic_np()</a>, <a class="el" href="group__task.html#gababee94264156693cd4f5b9b70d3c5a1">rt_task_set_periodic()</a>, and <a class="el" href="group__rtdmtask.html#ga44b0701b6c28fa8035711f800fdcd371">rtdm_task_init()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6d535ef9821e98fd7f257b50a3c8d595"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnpod_set_thread_schedparam </td>
          <td>(</td>
          <td class="paramtype">struct xnthread *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct xnsched_class *&#160;</td>
          <td class="paramname"><em>sched_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const union xnsched_policy_param *&#160;</td>
          <td class="paramname"><em>sched_param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the base scheduling parameters of a thread. </p>
<p>Changes the base scheduling policy and paramaters of a thread. If the thread is currently blocked, waiting in priority-pending mode (XNSYNCH_PRIO) for a synchronization object to be signaled, the nucleus will attempt to reorder the object's wait queue so that it reflects the new sleeper's priority, unless the XNSYNCH_DREORD flag has been set for the pended object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The descriptor address of the affected thread.</td></tr>
    <tr><td class="paramname">sched_class</td><td>The new scheduling class the thread should be assigned to.</td></tr>
    <tr><td class="paramname">sched_param</td><td>The scheduling parameters to set for the thread; <em>sched_param</em> must be valid within the context of <em>sched_class</em>.</td></tr>
  </table>
  </dd>
</dl>
<p>It is absolutely required to use this service to change a thread priority, in order to have all the needed housekeeping chores correctly performed. i.e. Do <em>not</em> call xnsched_set_policy() directly or worse, change the thread.cprio field by hand in any case.</p>
<dl class="section return"><dt>Returns</dt><dd>0 is returned on success. Otherwise, a negative error code indicates the cause of a failure that happened in the scheduling class implementation for <em>sched_class</em>. Invalid parameters passed into <em>sched_param</em> are common causes of error.</dd></dl>
<p>Side-effects:</p>
<ul>
<li>This service does not call the rescheduling procedure but may affect the state of the runnable queue for the previous and new scheduling classes.</li>
</ul>
<ul>
<li>Assigning the same scheduling class and parameters to a running or ready thread moves it to the end of the runnable queue, thus causing a manual round-robin.</li>
</ul>
<ul>
<li>If the thread is a user-space shadow, this call propagates the request to the mated Linux task.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: never. </p>

<p>Referenced by <a class="el" href="group__posix__sched.html#ga95276f88e1a2cae7a37f792123a99144">pthread_setschedparam()</a>, <a class="el" href="group__posix__sched.html#gad5eceef44b79a09a1a86e7a1950a74e7">pthread_setschedparam_ex()</a>, and <a class="el" href="group__task.html#ga3bed8d001e212a3328a4e7e73f1765e8">rt_task_set_priority()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4b8647e7a6969962c788669ff8d46d3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnpod_set_thread_tslice </td>
          <td>(</td>
          <td class="paramtype">struct xnthread *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnticks_t&#160;</td>
          <td class="paramname"><em>quantum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set thread time-slicing information. </p>
<p>Update the time-slicing information for a given thread. This service enables or disables round-robin scheduling for the thread, depending on the value of <em>quantum</em>. By default, times-slicing is disabled for a new thread initialized by a call to <a class="el" href="group__pod.html#gad71ebccc5b7b3d367f65127a8849c036" title="Initialize a new thread.">xnpod_init_thread()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The descriptor address of the affected thread.</td></tr>
    <tr><td class="paramname">quantum</td><td>The time quantum assigned to the thread expressed in time-slicing ticks (see note). If <em>quantum</em> is different from XN_INFINITE, the time-slice for the thread is set to that value and its current time credit is refilled (i.e. the thread is given a full time-slice to run next). Otherwise, if <em>quantum</em> equals XN_INFINITE, time-slicing is stopped for that thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if the base scheduling class of the target thread does not support time-slicing.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: never.</p>
<dl class="section note"><dt>Note</dt><dd>If <em>thread</em> is bound to a periodic timebase, <em>quantum</em> represents the number of periodic ticks in that timebase. Otherwise, if <em>thread</em> is bound to the master time base, a full time-slice will last: <em>quantum</em> * CONFIG_XENO_OPT_TIMING_VIRTICK. </dd></dl>

<p>References <a class="el" href="group__nucleus__state__flags.html#ga6f451131910f816dd01fe1ec1fb50fe9">XNRRB</a>, <a class="el" href="group__timer.html#ga0ad3c70bed7fe1a45b45ee0875f031ab">xntimer_start()</a>, and <a class="el" href="group__timer.html#ga1244411df9784d63d3e2f99016d62643">xntimer_stop()</a>.</p>

<p>Referenced by <a class="el" href="group__posix__thread.html#gae6e819ed048e4c4a4ee96fa6f426852c">pthread_create()</a>, <a class="el" href="group__posix__sched.html#ga95276f88e1a2cae7a37f792123a99144">pthread_setschedparam()</a>, <a class="el" href="group__posix__sched.html#gad5eceef44b79a09a1a86e7a1950a74e7">pthread_setschedparam_ex()</a>, and <a class="el" href="group__task.html#ga9250436d7bd9e49a0320161d2e9373ae">rt_task_slice()</a>.</p>

</div>
</div>
<a class="anchor" id="ga824dc22468666c9f14da1842f0184b84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnpod_shutdown </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shutdown the current pod. </p>
<p>Forcibly shutdowns the active pod. All existing nucleus threads (but the root one) are terminated, and the system heap is freed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xtype</td><td>An exit code passed to the host environment who started the nucleus. Zero is always interpreted as a successful return.</td></tr>
  </table>
  </dd>
</dl>
<p>The nucleus never calls this routine directly. Skins should provide their own shutdown handlers which end up calling <a class="el" href="group__pod.html#ga824dc22468666c9f14da1842f0184b84" title="Shutdown the current pod.">xnpod_shutdown()</a> after their own housekeeping chores have been carried out.</p>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
</ul>
<p>Rescheduling: never. </p>

<p>References <a class="el" href="group__heap.html#gaf33cea7788162687767ca7c8c149f6ab">xnheap_destroy()</a>, <a class="el" href="group__pod.html#gad2b761fb70cad30339f092edb4a89587">xnpod_delete_thread()</a>, <a class="el" href="group__pod.html#ga179f47d6e98446843f059790112dcce3">xnpod_disable_timesource()</a>, <a class="el" href="group__pod.html#gacf5b53f0405351327b89b0cc4976b962">xnpod_schedule()</a>, <a class="el" href="group__nucleus__state__flags.html#ga73d7b1a4f5a25545ff21140a0598075a">XNROOT</a>, and <a class="el" href="group__timer.html#ga782e10b2cd24a5c303b316375940ca15">xntimer_destroy()</a>.</p>

<p>Referenced by <a class="el" href="group__pod.html#ga167bb3b4251ac8b8a3e7f358d236908a">xnpod_init()</a>.</p>

</div>
</div>
<a class="anchor" id="gad322f6afd62430705486a9036d0b7d66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnpod_start_thread </td>
          <td>(</td>
          <td class="paramtype">xnthread_t *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct xnthread_start_attr *&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initial start of a newly created thread. </p>
<p>Starts a (newly) created thread, scheduling it for the first time. This call releases the target thread from the XNDORMANT state. This service also sets the initial mode and interrupt mask for the new thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The descriptor address of the affected thread which must have been previously initialized by the <a class="el" href="group__pod.html#gad71ebccc5b7b3d367f65127a8849c036" title="Initialize a new thread.">xnpod_init_thread()</a> service.</td></tr>
    <tr><td class="paramname">attr</td><td>A pointer to an attribute block describing the execution properties of the new thread. Members of this structure are defined as follows:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li><p class="startli">mode: The initial thread mode. The following flags can be part of this bitmask, each of them affecting the nucleus behaviour regarding the started thread:</p>
<ul>
<li>XNLOCK causes the thread to lock the scheduler when it starts. The target thread will have to call the xnpod_unlock_sched() service to unlock the scheduler. A non-preemptible thread may still block, in which case, the lock is reasserted when the thread is scheduled back in.</li>
</ul>
<ul>
<li>XNASDI disables the asynchronous signal handling for this thread. See <a class="el" href="group__pod.html#gacf5b53f0405351327b89b0cc4976b962" title="Rescheduling procedure entry point.">xnpod_schedule()</a> for more on this.</li>
</ul>
<ul>
<li>XNSUSP makes the thread start in a suspended state. In such a case, the thread will have to be explicitly resumed using the <a class="el" href="group__pod.html#gac3a7bf9e973782a8cfd6495a1786e812" title="Resume a thread.">xnpod_resume_thread()</a> service for its execution to actually begin.</li>
</ul>
</li>
</ul>
<ul>
<li>imask: The interrupt mask that should be asserted when the thread starts. The processor interrupt state will be set to the given value when the thread starts running. The interpretation of this value might be different across real-time layers, but a non-zero value should always mark an interrupt masking in effect (e.g. local_irq_disable()). Conversely, a zero value should always mark a fully preemptible state regarding interrupts (e.g. local_irq_enable()).</li>
</ul>
<ul>
<li>affinity: The processor affinity of this thread. Passing XNPOD_ALL_CPUS or an empty affinity set means "any cpu".</li>
</ul>
<ul>
<li>entry: The address of the thread's body routine. In other words, it is the thread entry point.</li>
</ul>
<ul>
<li>cookie: A user-defined opaque cookie the nucleus will pass to the emerging thread as the sole argument of its entry point.</li>
</ul>
<p>The START hooks are called on behalf of the calling context (if any).</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if <em>thread</em> could be started ;</td></tr>
    <tr><td class="paramname">-EBUSY</td><td>if <em>thread</em> was not dormant or stopped ;</td></tr>
    <tr><td class="paramname">-EINVAL</td><td>if the value of <em>attr-&gt;affinity</em> is invalid.</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: possible. </p>

<p>References <a class="el" href="group__nucleus__state__flags.html#ga5fa9672a03ebd4beaf7ab3caa5699fa6">XNDORMANT</a>, <a class="el" href="group__pod.html#gac3a7bf9e973782a8cfd6495a1786e812">xnpod_resume_thread()</a>, <a class="el" href="group__pod.html#gacf5b53f0405351327b89b0cc4976b962">xnpod_schedule()</a>, <a class="el" href="group__nucleus__state__flags.html#ga93d516291e0645195b35d63fbf0e0433">XNREADY</a>, <a class="el" href="group__nucleus__state__flags.html#gac664c3bae93da4141d2fc8e88a91afd8">XNSHADOW</a>, <a class="el" href="group__nucleus__state__flags.html#ga0843357a4c7a592e9d5f9cb1ce84ea8e">XNSTARTED</a>, and <a class="el" href="group__nucleus__state__flags.html#ga6b605ad2bb16ae2386821be8ce8d341b">XNSUSP</a>.</p>

<p>Referenced by <a class="el" href="group__posix__thread.html#gae6e819ed048e4c4a4ee96fa6f426852c">pthread_create()</a>, <a class="el" href="group__task.html#gac9638918b8310a430088f5c9a04d2bb7">rt_task_start()</a>, <a class="el" href="group__rtdmtask.html#ga44b0701b6c28fa8035711f800fdcd371">rtdm_task_init()</a>, and <a class="el" href="group__shadow.html#ga7204facd253dcde78c214e107e2ceafa">xnshadow_map()</a>.</p>

</div>
</div>
<a class="anchor" id="gad86de7feeb37bbac6f6660916c3fe099"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnpod_stop_thread </td>
          <td>(</td>
          <td class="paramtype">xnthread_t *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop a thread. </p>
<p>Stop a previously started thread. The thread is put back into the dormant state; however, it is not deleted from the system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The descriptor address of the affected thread which must have been previously started by the <a class="el" href="group__pod.html#gad322f6afd62430705486a9036d0b7d66" title="Initial start of a newly created thread.">xnpod_start_thread()</a> service.</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: possible. </p>

<p>References <a class="el" href="group__nucleus__state__flags.html#ga5fa9672a03ebd4beaf7ab3caa5699fa6">XNDORMANT</a>, <a class="el" href="group__pod.html#gacf5b53f0405351327b89b0cc4976b962">xnpod_schedule()</a>, <a class="el" href="group__pod.html#ga767221cf87c198c5dc071e9f597dcb3a">xnpod_suspend_thread()</a>, and <a class="el" href="group__nucleus__state__flags.html#ga73d7b1a4f5a25545ff21140a0598075a">XNROOT</a>.</p>

</div>
</div>
<a class="anchor" id="ga767221cf87c198c5dc071e9f597dcb3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnpod_suspend_thread </td>
          <td>(</td>
          <td class="paramtype">xnthread_t *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnflags_t&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnticks_t&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xntmode_t&#160;</td>
          <td class="paramname"><em>timeout_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct xnsynch *&#160;</td>
          <td class="paramname"><em>wchan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suspend a thread. </p>
<p>Suspends the execution of a thread according to a given suspensive condition. This thread will not be eligible for scheduling until it all the pending suspensive conditions set by this service are removed by one or more calls to <a class="el" href="group__pod.html#gac3a7bf9e973782a8cfd6495a1786e812" title="Resume a thread.">xnpod_resume_thread()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The descriptor address of the suspended thread.</td></tr>
    <tr><td class="paramname">mask</td><td>The suspension mask specifying the suspensive condition to add to the thread's wait mask. Possible values usable by the caller are:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>XNSUSP. This flag forcibly suspends a thread, regardless of any resource to wait for. A reverse call to <a class="el" href="group__pod.html#gac3a7bf9e973782a8cfd6495a1786e812" title="Resume a thread.">xnpod_resume_thread()</a> specifying the XNSUSP bit must be issued to remove this condition, which is cumulative with other suspension bits.<em>wchan</em> should be NULL when using this suspending mode.</li>
</ul>
<ul>
<li>XNDELAY. This flags denotes a counted delay wait (in ticks) which duration is defined by the value of the timeout parameter.</li>
</ul>
<ul>
<li>XNPEND. This flag denotes a wait for a synchronization object to be signaled. The wchan argument must points to this object. A timeout value can be passed to bound the wait. This suspending mode should not be used directly by the client interface, but rather through the <a class="el" href="group__synch.html#ga2747e9834546af461f118e7c90c9613e" title="Sleep on an ownerless synchronization object.">xnsynch_sleep_on()</a> call.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The timeout which may be used to limit the time the thread pends on a resource. This value is a wait time given in ticks (see note). It can either be relative, absolute monotonic, or absolute adjustable depending on <em>timeout_mode</em>. Passing XN_INFINITE <b>and</b> setting <em>timeout_mode</em> to XN_RELATIVE specifies an unbounded wait. All other values are used to initialize a watchdog timer. If the current operation mode of the system timer is oneshot and <em>timeout</em> elapses before <a class="el" href="group__pod.html#ga767221cf87c198c5dc071e9f597dcb3a" title="Suspend a thread.">xnpod_suspend_thread()</a> has completed, then the target thread will not be suspended, and this routine leads to a null effect.</td></tr>
    <tr><td class="paramname">timeout_mode</td><td>The mode of the <em>timeout</em> parameter. It can either be set to XN_RELATIVE, XN_ABSOLUTE, or XN_REALTIME (see also <a class="el" href="group__timer.html#ga0ad3c70bed7fe1a45b45ee0875f031ab" title="Arm a timer.">xntimer_start()</a>).</td></tr>
    <tr><td class="paramname">wchan</td><td>The address of a pended resource. This parameter is used internally by the synchronization object implementation code to specify on which object the suspended thread pends. NULL is a legitimate value when this parameter does not apply to the current suspending mode (e.g. XNSUSP).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the target thread is a shadow which has received a Linux-originated signal, then this service immediately exits without suspending the thread, but raises the XNBREAK condition in its information mask.</dd></dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: possible if the current thread suspends itself.</p>
<dl class="section note"><dt>Note</dt><dd>The <em>timeout</em> value will be interpreted as jiffies if <em>thread</em> is bound to a periodic time base (see xnpod_init_thread), or nanoseconds otherwise. </dd></dl>

<p>References <a class="el" href="structxnsched.html#afd2e6c15e470a38b385930c613856e7b">xnsched::curr</a>, <a class="el" href="structxnsched.html#a4e9ca82832cb0709308e7d78e7f9d694">xnsched::lflags</a>, <a class="el" href="group__nucleus__info__flags.html#ga6aa575e1a99b9c931d3b1feb8bc7a36f">XNBREAK</a>, <a class="el" href="group__nucleus__state__flags.html#gaa31d298d298eb696ccf840473b94912c">XNDELAY</a>, <a class="el" href="group__nucleus__state__flags.html#ga5fa9672a03ebd4beaf7ab3caa5699fa6">XNDORMANT</a>, <a class="el" href="group__nucleus__state__flags.html#ga9394cc02e730535e3dd8b0aabb08ea86">XNHELD</a>, <a class="el" href="group__nucleus__info__flags.html#gab6ee242aa7e0f98235c5099cd345984c">XNKICKED</a>, <a class="el" href="group__pod.html#gacf5b53f0405351327b89b0cc4976b962">xnpod_schedule()</a>, <a class="el" href="group__nucleus__state__flags.html#ga93d516291e0645195b35d63fbf0e0433">XNREADY</a>, <a class="el" href="group__nucleus__state__flags.html#gadf5508cd88c2678ae01dfaf5570c661c">XNRELAX</a>, <a class="el" href="group__nucleus__info__flags.html#gab07d9dea73645dbba353dc2452c15b40">XNRMID</a>, <a class="el" href="group__nucleus__info__flags.html#gad28db508d297929d6a0ec30964639d65">XNROBBED</a>, <a class="el" href="group__nucleus__state__flags.html#ga73d7b1a4f5a25545ff21140a0598075a">XNROOT</a>, <a class="el" href="group__nucleus__state__flags.html#gac664c3bae93da4141d2fc8e88a91afd8">XNSHADOW</a>, <a class="el" href="group__nucleus__state__flags.html#ga6b605ad2bb16ae2386821be8ce8d341b">XNSUSP</a>, <a class="el" href="group__synch.html#ga997e546948920193bb36ab8d120fbab7">xnsynch_forget_sleeper()</a>, <a class="el" href="group__nucleus__info__flags.html#gaa11d7fc754db50d3a1f1e41611d324e9">XNTIMEO</a>, <a class="el" href="group__timer.html#ga0ad3c70bed7fe1a45b45ee0875f031ab">xntimer_start()</a>, and <a class="el" href="group__nucleus__info__flags.html#ga53e49fa49b312e5266b31d66f7465d44">XNWAKEN</a>.</p>

<p>Referenced by <a class="el" href="group__posix__time.html#ga924d51d78cdcd9d7dee2613fb3a33cd1">clock_nanosleep()</a>, <a class="el" href="group__posix__signal.html#ga5aafacc071cdfafd0eb992004dee3e62">pthread_kill()</a>, <a class="el" href="group__task.html#gad5225e5fb8d583fbdfa5299f322b8366">rt_task_sleep()</a>, <a class="el" href="group__task.html#ga0dc2deebe7500c9d21ff05d51d5efaa8">rt_task_sleep_until()</a>, <a class="el" href="group__task.html#ga926a4b10e3631f76c5f38910e6eea24c">rt_task_suspend()</a>, <a class="el" href="group__pod.html#ga75278c2ac6f43741eca9cc1d60072eac">xnpod_abort_thread()</a>, <a class="el" href="group__pod.html#gad71ebccc5b7b3d367f65127a8849c036">xnpod_init_thread()</a>, <a class="el" href="group__pod.html#gaed5776a428e7c59b52b1da76f0d765fa">xnpod_set_thread_periodic()</a>, <a class="el" href="group__pod.html#gad86de7feeb37bbac6f6660916c3fe099">xnpod_stop_thread()</a>, <a class="el" href="group__pod.html#gaf95cac21ec23e44282461905dd3fc153">xnpod_trap_fault()</a>, <a class="el" href="group__pod.html#gaf836996e4a3378928f2a9f93a4915cfa">xnpod_wait_thread_period()</a>, <a class="el" href="group__shadow.html#ga7204facd253dcde78c214e107e2ceafa">xnshadow_map()</a>, <a class="el" href="group__shadow.html#ga8de86a334ac2c5aeeebccf88fcee03ab">xnshadow_relax()</a>, <a class="el" href="group__synch.html#ga6d4ad886901c751a4f3c51b90fc8f91f">xnsynch_acquire()</a>, and <a class="el" href="group__synch.html#ga2747e9834546af461f118e7c90c9613e">xnsynch_sleep_on()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf95cac21ec23e44282461905dd3fc153"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnpod_trap_fault </td>
          <td>(</td>
          <td class="paramtype">xnarch_fltinfo_t *&#160;</td>
          <td class="paramname"><em>fltinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default fault handler. </p>
<p>This is the default handler which is called whenever an uncontrolled exception or fault is caught. If the fault is caught on behalf of a real-time thread, the fault is not propagated to the host system. Otherwise, the fault is unhandled by the nucleus and simply propagated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fltinfo</td><td>An opaque pointer to the arch-specific buffer describing the fault. The actual layout is defined by the xnarch_fltinfo_t type in each arch-dependent layer file. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group__pod.html#ga767221cf87c198c5dc071e9f597dcb3a">xnpod_suspend_thread()</a>, <a class="el" href="group__shadow.html#ga8de86a334ac2c5aeeebccf88fcee03ab">xnshadow_relax()</a>, and <a class="el" href="group__nucleus__state__flags.html#ga6b605ad2bb16ae2386821be8ce8d341b">XNSUSP</a>.</p>

</div>
</div>
<a class="anchor" id="gae5f0d19e7a499b9b262f68a43ab545dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnpod_unblock_thread </td>
          <td>(</td>
          <td class="paramtype">xnthread_t *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unblock a thread. </p>
<p>Breaks the thread out of any wait it is currently in. This call removes the XNDELAY and XNPEND suspensive conditions previously put by <a class="el" href="group__pod.html#ga767221cf87c198c5dc071e9f597dcb3a" title="Suspend a thread.">xnpod_suspend_thread()</a> on the target thread. If all suspensive conditions are gone, the thread is left in a READY state at which point it becomes eligible anew for scheduling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The descriptor address of the unblocked thread.</td></tr>
  </table>
  </dd>
</dl>
<p>This call neither releases the thread from the XNSUSP, XNRELAX, XNDORMANT or XNHELD suspensive conditions.</p>
<p>When the thread resumes execution, the XNBREAK bit is set in the unblocked thread's information mask. Unblocking a non-blocked thread is perfectly harmless.</p>
<dl class="section return"><dt>Returns</dt><dd>non-zero is returned if the thread was actually unblocked from a pending wait state, 0 otherwise.</dd></dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: never. </p>

<p>References <a class="el" href="group__nucleus__info__flags.html#ga6aa575e1a99b9c931d3b1feb8bc7a36f">XNBREAK</a>, <a class="el" href="group__nucleus__state__flags.html#gaa31d298d298eb696ccf840473b94912c">XNDELAY</a>, <a class="el" href="group__nucleus__state__flags.html#ga153b45ee5ddcc4da154ca8a018ac1871">XNPEND</a>, and <a class="el" href="group__pod.html#gac3a7bf9e973782a8cfd6495a1786e812">xnpod_resume_thread()</a>.</p>

<p>Referenced by <a class="el" href="group__posix__cancel.html#ga9e77a80c073787bf9a593e9c619dce27">pthread_cancel()</a>, <a class="el" href="group__posix__signal.html#ga5aafacc071cdfafd0eb992004dee3e62">pthread_kill()</a>, <a class="el" href="group__task.html#gacd8a4fb2d11f0548bd053dfbf92f9e9d">rt_task_reply()</a>, <a class="el" href="group__task.html#ga770281eeca009c0a08a7c4a9fd849ac1">rt_task_unblock()</a>, and <a class="el" href="group__pod.html#gad2b761fb70cad30339f092edb4a89587">xnpod_delete_thread()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf836996e4a3378928f2a9f93a4915cfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnpod_wait_thread_period </td>
          <td>(</td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>overruns_r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for the next periodic release point. </p>
<p>Make the current thread wait for the next periodic release point in the processor time line.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">overruns_r</td><td>If non-NULL, <em>overruns_r</em> must be a pointer to a memory location which will be written with the count of pending overruns. This value is copied only when <a class="el" href="group__pod.html#gaf836996e4a3378928f2a9f93a4915cfa" title="Wait for the next periodic release point.">xnpod_wait_thread_period()</a> returns -ETIMEDOUT or success; the memory location remains unmodified otherwise. If NULL, this count will never be copied back.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned upon success; if <em>overruns_r</em> is valid, zero is copied to the pointed memory location. Otherwise:</dd></dl>
<ul>
<li>-EWOULDBLOCK is returned if <a class="el" href="group__pod.html#gaed5776a428e7c59b52b1da76f0d765fa" title="Make a thread periodic.">xnpod_set_thread_periodic()</a> has not previously been called for the calling thread.</li>
</ul>
<ul>
<li>-EINTR is returned if <a class="el" href="group__pod.html#gae5f0d19e7a499b9b262f68a43ab545dd" title="Unblock a thread.">xnpod_unblock_thread()</a> has been called for the waiting thread before the next periodic release point has been reached. In this case, the overrun counter is reset too.</li>
</ul>
<ul>
<li>-ETIMEDOUT is returned if the timer has overrun, which indicates that one or more previous release points have been missed by the calling thread. If <em>overruns_r</em> is valid, the count of pending overruns is copied to the pointed memory location.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: always, unless the current release point has already been reached. In the latter case, the current thread immediately returns from this service without being delayed. </p>

<p>References <a class="el" href="group__nucleus__info__flags.html#ga6aa575e1a99b9c931d3b1feb8bc7a36f">XNBREAK</a>, <a class="el" href="group__nucleus__state__flags.html#gaa31d298d298eb696ccf840473b94912c">XNDELAY</a>, <a class="el" href="group__pod.html#ga767221cf87c198c5dc071e9f597dcb3a">xnpod_suspend_thread()</a>, and <a class="el" href="group__timer.html#ga5609dd2602efe2c5b04eda28b22b9720">xntimer_get_overruns()</a>.</p>

<p>Referenced by <a class="el" href="group__posix__thread.html#ga1f18e6e7dd5342463ca8546ef3a36c34">pthread_wait_np()</a>, and <a class="el" href="group__task.html#ga1645d3a072ef3cefeed3bcbb27dcf108">rt_task_wait_period()</a>.</p>

</div>
</div>
<a class="anchor" id="ga657259b9accb3be41574f9970baef393"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnpod_welcome_thread </td>
          <td>(</td>
          <td class="paramtype">xnthread_t *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>imask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread prologue. </p>
<p>This internal routine is called on behalf of a (re)starting thread's prologue before the user entry point is invoked. This call is reserved for internal housekeeping chores and cannot be inlined.</p>
<p>Entered with nklock locked, irqs off. </p>

<p>References <a class="el" href="group__nucleus__state__flags.html#ga2defcfb1f04f077baeac9881cbdda627">XNLOCK</a>, <a class="el" href="group__pod.html#gafd49fb1aa94c5f44f8c23d66a77b5581">xnpod_dispatch_signals()</a>, and <a class="el" href="group__nucleus__state__flags.html#gacc86813fad4e877dcc16b98cdb64ef60">XNRESTART</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Oct 4 2013 22:39:08 for Xenomai API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.2 </li>
  </ul>
</div>
</body>
</html>
