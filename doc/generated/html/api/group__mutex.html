<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Xenomai API: Mutex services.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1>Mutex services.<br>
<small>
[<a class="el" href="group__native.html">Native Xenomai API.</a>]</small>
</h1>
<p>
Collaboration diagram for Mutex services.:<center><table><tr><td><img src="group__mutex.png" border="0" alt="" usemap="#group____mutex_map">
<map name="group____mutex_map">
<area href="group__native.html" shape="rect" coords="7,5,164,32" alt="">
</map></td></tr></table></center>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Mutex services.<p>
A mutex is a MUTual EXclusion object, and is useful for protecting shared data structures from concurrent modifications, and implementing critical sections and monitors.<p>
A mutex has two possible states: unlocked (not owned by any task), and locked (owned by one task). A mutex can never be owned by two different tasks simultaneously. A task attempting to lock a mutex that is already locked by another task is blocked until the latter unlocks the mutex first.<p>
Xenomai mutex services enforce a priority inheritance protocol in order to solve priority inversions. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ksrc_2skins_2native_2mutex_8c.html">mutex.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This file is part of the Xenomai project. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#g156abfa5ac259b48fa73fa73ab87fb24">rt_mutex_create</a> (RT_MUTEX *mutex, const char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a mutex.  <a href="#g156abfa5ac259b48fa73fa73ab87fb24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#gbc1fcb089a9473f502877abe0408b640">rt_mutex_delete</a> (RT_MUTEX *mutex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a mutex.  <a href="#gbc1fcb089a9473f502877abe0408b640"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#gd7993436aba975d610783294745ebece">rt_mutex_acquire</a> (RT_MUTEX *mutex, RTIME timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acquire a mutex.  <a href="#gd7993436aba975d610783294745ebece"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#g7a98264b7dbb0ed194131806ecc190ad">rt_mutex_release</a> (RT_MUTEX *mutex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock mutex.  <a href="#g7a98264b7dbb0ed194131806ecc190ad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#g14afff2f0a2f60c610881f12b3a53a2e">rt_mutex_inquire</a> (RT_MUTEX *mutex, RT_MUTEX_INFO *info)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inquire about a mutex.  <a href="#g14afff2f0a2f60c610881f12b3a53a2e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#gc09c0795bab213ca1d02205f14a22cfc">rt_mutex_bind</a> (RT_MUTEX *mutex, const char *name, RTIME timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bind to a mutex.  <a href="#gc09c0795bab213ca1d02205f14a22cfc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#g431b06d28d8d6896dc20653f05ebe8b6">rt_mutex_unbind</a> (RT_MUTEX *mutex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unbind from a mutex.  <a href="#g431b06d28d8d6896dc20653f05ebe8b6"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="gd7993436aba975d610783294745ebece"></a><!-- doxytag: member="mutex.c::rt_mutex_acquire" ref="gd7993436aba975d610783294745ebece" args="(RT_MUTEX *mutex, RTIME timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_mutex_acquire           </td>
          <td>(</td>
          <td class="paramtype">RT_MUTEX *&nbsp;</td>
          <td class="paramname"> <em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Acquire a mutex. 
<p>
Attempt to lock a mutex. The calling task is blocked until the mutex is available, in which case it is locked again before this service returns. Mutexes have an ownership property, which means that their current owner is tracked. Xenomai mutexes are implicitely recursive and implement the priority inheritance protocol.<p>
Since a nested locking count is maintained for the current owner, rt_mutex_lock() and rt_mutex_unlock() must be used in pairs.<p>
Tasks pend on mutexes by priority order.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mutex</em>&nbsp;</td><td>The descriptor address of the mutex to acquire.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The number of clock ticks to wait for the mutex to be available to the calling task (see note). Passing TM_INFINITE causes the caller to block indefinitely until the mutex is available. Passing TM_NONBLOCK causes the service to return immediately without waiting if the mutex is still locked by another task.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>mutex</em> is not a mutex descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>mutex</em> is a deleted mutex descriptor, including if the deletion occurred while the caller was sleeping on it.</li></ul>
<p>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to TM_NONBLOCK and the mutex is not immediately available.</li></ul>
<p>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#g15d0e6e877d2db681dd6dbd17300d465">rt_task_unblock()</a> has been called for the waiting task before the mutex has become available.</li></ul>
<p>
<ul>
<li>-ETIMEDOUT is returned if the mutex cannot be made available to the calling task within the specified amount of time.</li></ul>
<p>
<ul>
<li>-EPERM is returned if this service was called from a context which cannot be given the ownership of the mutex (e.g. interrupt, non-realtime or scheduler locked).</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel-based task</li><li>User-space task (switches to primary mode)</li></ul>
<p>
Rescheduling: always unless the request is immediately satisfied or <em>timeout</em> specifies a non-blocking operation. If the caller is blocked, the current owner's priority might be temporarily raised as a consequence of the priority inheritance protocol.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This service is sensitive to the current operation mode of the system timer, as defined by the CONFIG_XENO_OPT_TIMING_PERIOD parameter. In periodic mode, clock ticks are interpreted as periodic jiffies. In oneshot mode, clock ticks are interpreted as nanoseconds. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc09c0795bab213ca1d02205f14a22cfc"></a><!-- doxytag: member="mutex.h::rt_mutex_bind" ref="gc09c0795bab213ca1d02205f14a22cfc" args="(RT_MUTEX *mutex, const char *name, RTIME timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_mutex_bind           </td>
          <td>(</td>
          <td class="paramtype">RT_MUTEX *&nbsp;</td>
          <td class="paramname"> <em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bind to a mutex. 
<p>
This user-space only service retrieves the uniform descriptor of a given Xenomai mutex identified by its symbolic name. If the mutex does not exist on entry, this service blocks the caller until a mutex of the given name is created.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>A valid NULL-terminated name which identifies the mutex to bind to.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mutex</em>&nbsp;</td><td>The address of a mutex descriptor retrieved by the operation. Contents of this memory is undefined upon failure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The number of clock ticks to wait for the registration to occur (see note). Passing TM_INFINITE causes the caller to block indefinitely until the object is registered. Passing TM_NONBLOCK causes the service to return immediately without waiting if the object is not registered on entry.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EFAULT is returned if <em>mutex</em> or <em>name</em> is referencing invalid memory.</li></ul>
<p>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#g15d0e6e877d2db681dd6dbd17300d465">rt_task_unblock()</a> has been called for the waiting task before the retrieval has completed.</li></ul>
<p>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to TM_NONBLOCK and the searched object is not registered on entry.</li></ul>
<p>
<ul>
<li>-ETIMEDOUT is returned if the object cannot be retrieved within the specified amount of time.</li></ul>
<p>
<ul>
<li>-EPERM is returned if this service should block, but was called from a context which cannot sleep (e.g. interrupt, non-realtime or scheduler locked).</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>User-space task (switches to primary mode)</li></ul>
<p>
Rescheduling: always unless the request is immediately satisfied or <em>timeout</em> specifies a non-blocking operation.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This service is sensitive to the current operation mode of the system timer, as defined by the CONFIG_XENO_OPT_TIMING_PERIOD parameter. In periodic mode, clock ticks are interpreted as periodic jiffies. In oneshot mode, clock ticks are interpreted as nanoseconds. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g156abfa5ac259b48fa73fa73ab87fb24"></a><!-- doxytag: member="mutex.c::rt_mutex_create" ref="g156abfa5ac259b48fa73fa73ab87fb24" args="(RT_MUTEX *mutex, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_mutex_create           </td>
          <td>(</td>
          <td class="paramtype">RT_MUTEX *&nbsp;</td>
          <td class="paramname"> <em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a mutex. 
<p>
Create a mutual exclusion object that allows multiple tasks to synchronize access to a shared resource. A mutex is left in an unlocked state after creation.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mutex</em>&nbsp;</td><td>The address of a mutex descriptor Xenomai will use to store the mutex-related data. This descriptor must always be valid while the mutex is active therefore it must be allocated in permanent memory.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>An ASCII string standing for the symbolic name of the mutex. When non-NULL and non-empty, this string is copied to a safe place into the descriptor, and passed to the registry package if enabled for indexing the created mutex.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-ENOMEM is returned if the system fails to get enough dynamic memory from the global real-time heap in order to register the mutex.</li></ul>
<p>
<ul>
<li>-EEXIST is returned if the <em>name</em> is already in use by some registered object.</li></ul>
<p>
<ul>
<li>-EPERM is returned if this service was called from an asynchronous context.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: possible. 
</div>
</div><p>
<a class="anchor" name="gbc1fcb089a9473f502877abe0408b640"></a><!-- doxytag: member="mutex.c::rt_mutex_delete" ref="gbc1fcb089a9473f502877abe0408b640" args="(RT_MUTEX *mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_mutex_delete           </td>
          <td>(</td>
          <td class="paramtype">RT_MUTEX *&nbsp;</td>
          <td class="paramname"> <em>mutex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete a mutex. 
<p>
Destroy a mutex and release all the tasks currently pending on it. A mutex exists in the system since <a class="el" href="group__mutex.html#g156abfa5ac259b48fa73fa73ab87fb24">rt_mutex_create()</a> has been called to create it, so this service must be called in order to destroy it afterwards.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mutex</em>&nbsp;</td><td>The descriptor address of the affected mutex.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>mutex</em> is not a mutex descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>mutex</em> is a deleted mutex descriptor.</li></ul>
<p>
<ul>
<li>-EPERM is returned if this service was called from an asynchronous context.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: possible. 
</div>
</div><p>
<a class="anchor" name="g14afff2f0a2f60c610881f12b3a53a2e"></a><!-- doxytag: member="mutex.c::rt_mutex_inquire" ref="g14afff2f0a2f60c610881f12b3a53a2e" args="(RT_MUTEX *mutex, RT_MUTEX_INFO *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_mutex_inquire           </td>
          <td>(</td>
          <td class="paramtype">RT_MUTEX *&nbsp;</td>
          <td class="paramname"> <em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RT_MUTEX_INFO *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inquire about a mutex. 
<p>
Return various information about the status of a given mutex.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mutex</em>&nbsp;</td><td>The descriptor address of the inquired mutex.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>The address of a structure the mutex information will be written to.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned and status information is written to the structure pointed at by <em>info</em> upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>mutex</em> is not a mutex descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>mutex</em> is a deleted mutex descriptor.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="g7a98264b7dbb0ed194131806ecc190ad"></a><!-- doxytag: member="mutex.c::rt_mutex_release" ref="g7a98264b7dbb0ed194131806ecc190ad" args="(RT_MUTEX *mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_mutex_release           </td>
          <td>(</td>
          <td class="paramtype">RT_MUTEX *&nbsp;</td>
          <td class="paramname"> <em>mutex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unlock mutex. 
<p>
Release a mutex. If the mutex is pended, the first waiting task (by priority order) is immediately unblocked and transfered the ownership of the mutex; otherwise, the mutex is left in an unlocked state.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mutex</em>&nbsp;</td><td>The descriptor address of the released mutex.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>mutex</em> is not a mutex descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>mutex</em> is a deleted mutex descriptor.</li></ul>
<p>
<ul>
<li>-EPERM is returned if <em>mutex</em> is not owned by the current task, or more generally if this service was called from a context which cannot own any mutex (e.g. interrupt, or non-realtime context).</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel-based task</li><li>User-space task (switches to primary mode)</li></ul>
<p>
Rescheduling: possible. 
</div>
</div><p>
<a class="anchor" name="g431b06d28d8d6896dc20653f05ebe8b6"></a><!-- doxytag: member="mutex.h::rt_mutex_unbind" ref="g431b06d28d8d6896dc20653f05ebe8b6" args="(RT_MUTEX *mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_mutex_unbind           </td>
          <td>(</td>
          <td class="paramtype">RT_MUTEX *&nbsp;</td>
          <td class="paramname"> <em>mutex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unbind from a mutex. 
<p>
This user-space only service unbinds the calling task from the mutex object previously retrieved by a call to <a class="el" href="group__mutex.html#gc09c0795bab213ca1d02205f14a22cfc">rt_mutex_bind()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mutex</em>&nbsp;</td><td>The address of a mutex descriptor to unbind from.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is always returned.</dd></dl>
This service can be called from:<p>
<ul>
<li>User-space task.</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Sun Sep 16 18:34:38 2007 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
