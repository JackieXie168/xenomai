<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Xenomai API: Event flag group services.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Xenomai API"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Xenomai API
   &#160;<span id="projectnumber">2.6.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__event.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Event flag group services.</div>  </div>
<div class="ingroups"><a class="el" href="group__native.html">Native Xenomai API.</a></div></div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Event flag group services.:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__event.png" border="0" alt="" usemap="#group____event"/>
<map name="group____event" id="group____event">
<area shape="rect" id="node1" href="group__native.html" title="Native Xenomai API." alt="" coords="7,5,151,35"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:ksrc_2skins_2native_2event_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ksrc_2skins_2native_2event_8c.html">event.c</a></td></tr>
<tr class="memdesc:ksrc_2skins_2native_2event_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file is part of the Xenomai project. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8b0fbb2b816c62081afe86bf897c503c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event.html#ga8b0fbb2b816c62081afe86bf897c503c">rt_event_create</a> (RT_EVENT *event, const char *name, unsigned long ivalue, int mode)</td></tr>
<tr class="memdesc:ga8b0fbb2b816c62081afe86bf897c503c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an event group.  <a href="#ga8b0fbb2b816c62081afe86bf897c503c"></a><br/></td></tr>
<tr class="memitem:gabccfea1cd018493ef5a28c6fe8e90d7c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event.html#gabccfea1cd018493ef5a28c6fe8e90d7c">rt_event_delete</a> (RT_EVENT *event)</td></tr>
<tr class="memdesc:gabccfea1cd018493ef5a28c6fe8e90d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an event group.  <a href="#gabccfea1cd018493ef5a28c6fe8e90d7c"></a><br/></td></tr>
<tr class="memitem:gafda4c544f2429005c4b15de3a7ffc902"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event.html#gafda4c544f2429005c4b15de3a7ffc902">rt_event_signal</a> (RT_EVENT *event, unsigned long mask)</td></tr>
<tr class="memdesc:gafda4c544f2429005c4b15de3a7ffc902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post an event group.  <a href="#gafda4c544f2429005c4b15de3a7ffc902"></a><br/></td></tr>
<tr class="memitem:ga6e9f775275661d9258f8b1eb02fe4681"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event.html#ga6e9f775275661d9258f8b1eb02fe4681">rt_event_wait</a> (RT_EVENT *event, unsigned long mask, unsigned long *mask_r, int mode, RTIME timeout)</td></tr>
<tr class="memdesc:ga6e9f775275661d9258f8b1eb02fe4681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pend on an event group.  <a href="#ga6e9f775275661d9258f8b1eb02fe4681"></a><br/></td></tr>
<tr class="memitem:ga81e2c7a3346b2364a153a24be291b204"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event.html#ga81e2c7a3346b2364a153a24be291b204">rt_event_wait_until</a> (RT_EVENT *event, unsigned long mask, unsigned long *mask_r, int mode, RTIME timeout)</td></tr>
<tr class="memdesc:ga81e2c7a3346b2364a153a24be291b204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pend on an event group (with absolute timeout date).  <a href="#ga81e2c7a3346b2364a153a24be291b204"></a><br/></td></tr>
<tr class="memitem:ga448889bcfd01ed892d97a0b00fdaf553"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event.html#ga448889bcfd01ed892d97a0b00fdaf553">rt_event_clear</a> (RT_EVENT *event, unsigned long mask, unsigned long *mask_r)</td></tr>
<tr class="memdesc:ga448889bcfd01ed892d97a0b00fdaf553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear an event group.  <a href="#ga448889bcfd01ed892d97a0b00fdaf553"></a><br/></td></tr>
<tr class="memitem:gabecddf3846622df42bf95f94871f8e62"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event.html#gabecddf3846622df42bf95f94871f8e62">rt_event_inquire</a> (RT_EVENT *event, RT_EVENT_INFO *info)</td></tr>
<tr class="memdesc:gabecddf3846622df42bf95f94871f8e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inquire about an event group.  <a href="#gabecddf3846622df42bf95f94871f8e62"></a><br/></td></tr>
<tr class="memitem:ga535edab31526338258479100f3e6997c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event.html#ga535edab31526338258479100f3e6997c">rt_event_bind</a> (RT_EVENT *event, const char *name, RTIME timeout)</td></tr>
<tr class="memdesc:ga535edab31526338258479100f3e6997c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind to an event flag group.  <a href="#ga535edab31526338258479100f3e6997c"></a><br/></td></tr>
<tr class="memitem:gae985bb0e671e2a5e07b575fd793fde22"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event.html#gae985bb0e671e2a5e07b575fd793fde22">rt_event_unbind</a> (RT_EVENT *event)</td></tr>
<tr class="memdesc:gae985bb0e671e2a5e07b575fd793fde22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unbind from an event flag group.  <a href="#gae985bb0e671e2a5e07b575fd793fde22"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<p>An event flag group is a synchronization object represented by a long-word structure; every available bit in such word can be used to map a user-defined event flag. When a flag is set, the associated event is said to have occurred. Xenomai tasks and interrupt handlers can use event flags to signal the occurrence of events to other tasks; those tasks can either wait for the events to occur in a conjunctive manner (all awaited events must have occurred to wake up), or in a disjunctive way (at least one of the awaited events must have occurred to wake up). </p>
<h2>Function Documentation</h2>
<a class="anchor" id="ga535edab31526338258479100f3e6997c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_event_bind </td>
          <td>(</td>
          <td class="paramtype">RT_EVENT *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind to an event flag group. </p>
<p>This user-space only service retrieves the uniform descriptor of a given Xenomai event flag group identified by its symbolic name. If the event flag group does not exist on entry, this service blocks the caller until a event flag group of the given name is created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A valid NULL-terminated name which identifies the event flag group to bind to.</td></tr>
    <tr><td class="paramname">event</td><td>The address of an event flag group descriptor retrieved by the operation. Contents of this memory is undefined upon failure.</td></tr>
    <tr><td class="paramname">timeout</td><td>The number of clock ticks to wait for the registration to occur (see note). Passing TM_INFINITE causes the caller to block indefinitely until the object is registered. Passing TM_NONBLOCK causes the service to return immediately without waiting if the object is not registered on entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EFAULT is returned if <em>event</em> or <em>name</em> is referencing invalid memory.</li>
</ul>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task.">rt_task_unblock()</a> has been called for the waiting task before the retrieval has completed.</li>
</ul>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to TM_NONBLOCK and the searched object is not registered on entry.</li>
</ul>
<ul>
<li>-ETIMEDOUT is returned if the object cannot be retrieved within the specified amount of time.</li>
</ul>
<ul>
<li>-EPERM is returned if this service should block, but was called from a context which cannot sleep (e.g. interrupt, non-realtime context).</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>User-space task (switches to primary mode)</li>
</ul>
<p>Rescheduling: always unless the request is immediately satisfied or <em>timeout</em> specifies a non-blocking operation.</p>
<dl class="section note"><dt>Note</dt><dd>The <em>timeout</em> value will be interpreted as jiffies if the native skin is bound to a periodic time base (see CONFIG_XENO_OPT_NATIVE_PERIOD), or nanoseconds otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga448889bcfd01ed892d97a0b00fdaf553"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_event_clear </td>
          <td>(</td>
          <td class="paramtype">RT_EVENT *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>mask_r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear an event group. </p>
<p>Clears a set of flags from an event mask.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The descriptor address of the affected event.</td></tr>
    <tr><td class="paramname">mask</td><td>The set of events to be cleared.</td></tr>
    <tr><td class="paramname">mask_r</td><td>If non-NULL, <em>mask_r</em> is the address of a memory location which will be written upon success with the previous value of the event group before the flags are cleared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>event</em> is not an event group descriptor.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>event</em> is a deleted event group descriptor.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="ga8b0fbb2b816c62081afe86bf897c503c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_event_create </td>
          <td>(</td>
          <td class="paramtype">RT_EVENT *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ivalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an event group. </p>
<p>Event groups provide for task synchronization by allowing a set of flags (or "events") to be waited for and posted atomically. An event group contains a mask of received events; any set of bits from the event mask can be pended or posted in a single operation.</p>
<p>Tasks can wait for a conjunctive (AND) or disjunctive (OR) set of events to occur. A task pending on an event group in conjunctive mode is woken up as soon as all awaited events are set in the event mask. A task pending on an event group in disjunctive mode is woken up as soon as any awaited event is set in the event mask.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The address of an event group descriptor Xenomai will use to store the event-related data. This descriptor must always be valid while the group is active therefore it must be allocated in permanent memory.</td></tr>
    <tr><td class="paramname">name</td><td>An ASCII string standing for the symbolic name of the group. When non-NULL and non-empty, this string is copied to a safe place into the descriptor, and passed to the registry package if enabled for indexing the created event group.</td></tr>
    <tr><td class="paramname">ivalue</td><td>The initial value of the group's event mask.</td></tr>
    <tr><td class="paramname">mode</td><td>The event group creation mode. The following flags can be OR'ed into this bitmask, each of them affecting the new group:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>EV_FIFO makes tasks pend in FIFO order on the event group.</li>
</ul>
<ul>
<li>EV_PRIO makes tasks pend in priority order on the event group.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EEXIST is returned if the <em>name</em> is already in use by some registered object.</li>
</ul>
<ul>
<li>-EPERM is returned if this service was called from an asynchronous context.</li>
</ul>
<ul>
<li>-ENOMEM is returned if the system fails to get enough dynamic memory from the global real-time heap in order to register the event group.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: possible. </p>

<p>References <a class="el" href="group__event.html#gabccfea1cd018493ef5a28c6fe8e90d7c">rt_event_delete()</a>, <a class="el" href="group__registry.html#ga28aefd9be7367aa495753142005e1d5a">xnregistry_enter()</a>, and <a class="el" href="group__synch.html#ga4c07b8ec87b14cf18ef512f0e0aade51">xnsynch_init()</a>.</p>

</div>
</div>
<a class="anchor" id="gabccfea1cd018493ef5a28c6fe8e90d7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_event_delete </td>
          <td>(</td>
          <td class="paramtype">RT_EVENT *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete an event group. </p>
<p>Destroy an event group and release all the tasks currently pending on it. An event group exists in the system since <a class="el" href="group__event.html#ga8b0fbb2b816c62081afe86bf897c503c" title="Create an event group.">rt_event_create()</a> has been called to create it, so this service must be called in order to destroy it afterwards.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The descriptor address of the affected event group.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>event</em> is not a event group descriptor.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>event</em> is a deleted event group descriptor.</li>
</ul>
<ul>
<li>-EPERM is returned if this service was called from an asynchronous context.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: possible. </p>

<p>References <a class="el" href="group__pod.html#gacf5b53f0405351327b89b0cc4976b962">xnpod_schedule()</a>, and <a class="el" href="group__registry.html#ga477bb20ccb4bcf87c343aca8e58f9ef9">xnregistry_remove()</a>.</p>

<p>Referenced by <a class="el" href="group__event.html#ga8b0fbb2b816c62081afe86bf897c503c">rt_event_create()</a>.</p>

</div>
</div>
<a class="anchor" id="gabecddf3846622df42bf95f94871f8e62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_event_inquire </td>
          <td>(</td>
          <td class="paramtype">RT_EVENT *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RT_EVENT_INFO *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inquire about an event group. </p>
<p>Return various information about the status of a specified event group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The descriptor address of the inquired event group.</td></tr>
    <tr><td class="paramname">info</td><td>The address of a structure the event group information will be written to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned and status information is written to the structure pointed at by <em>info</em> upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>event</em> is not a event group descriptor.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>event</em> is a deleted event group descriptor.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="gafda4c544f2429005c4b15de3a7ffc902"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_event_signal </td>
          <td>(</td>
          <td class="paramtype">RT_EVENT *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post an event group. </p>
<p>Post a set of bits to the event mask. All tasks having their wait request fulfilled by the posted events are resumed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The descriptor address of the affected event.</td></tr>
    <tr><td class="paramname">mask</td><td>The set of events to be posted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>event</em> is not an event group descriptor.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>event</em> is a deleted event group descriptor.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: possible. </p>

<p>References <a class="el" href="group__pod.html#gacf5b53f0405351327b89b0cc4976b962">xnpod_schedule()</a>, and <a class="el" href="group__synch.html#ga9e530d12df9881251231af489208762e">xnsynch_wakeup_this_sleeper()</a>.</p>

</div>
</div>
<a class="anchor" id="gae985bb0e671e2a5e07b575fd793fde22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int rt_event_unbind </td>
          <td>(</td>
          <td class="paramtype">RT_EVENT *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unbind from an event flag group. </p>
<p>This user-space only service unbinds the calling task from the event flag group object previously retrieved by a call to <a class="el" href="group__event.html#ga535edab31526338258479100f3e6997c" title="Bind to an event flag group.">rt_event_bind()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The address of an event flag group descriptor to unbind from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is always returned.</dd></dl>
<p>This service can be called from:</p>
<ul>
<li>User-space task.</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="ga6e9f775275661d9258f8b1eb02fe4681"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_event_wait </td>
          <td>(</td>
          <td class="paramtype">RT_EVENT *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>mask_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pend on an event group. </p>
<p>Waits for one or more events on the specified event group, either in conjunctive or disjunctive mode.</p>
<p>If the specified set of bits is not set, the calling task is blocked. The task is not resumed until the request is fulfilled. The event bits are NOT cleared from the event group when a request is satisfied; <a class="el" href="group__event.html#ga6e9f775275661d9258f8b1eb02fe4681" title="Pend on an event group.">rt_event_wait()</a> will return immediately with success for the same event mask until <a class="el" href="group__event.html#ga448889bcfd01ed892d97a0b00fdaf553" title="Clear an event group.">rt_event_clear()</a> is called to clear those bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The descriptor address of the affected event group.</td></tr>
    <tr><td class="paramname">mask</td><td>The set of bits to wait for. Passing zero causes this service to return immediately with a success value; the current value of the event mask is also copied to <em>mask_r</em>.</td></tr>
    <tr><td class="paramname">mask_r</td><td>The value of the event mask at the time the task was readied.</td></tr>
    <tr><td class="paramname">mode</td><td>The pend mode. The following flags can be OR'ed into this bitmask, each of them affecting the operation:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>EV_ANY makes the task pend in disjunctive mode (i.e. OR); this means that the request is fulfilled when at least one bit set into <em>mask</em> is set in the current event mask.</li>
</ul>
<ul>
<li>EV_ALL makes the task pend in conjunctive mode (i.e. AND); this means that the request is fulfilled when at all bits set into <em>mask</em> are set in the current event mask.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The number of clock ticks to wait for fulfilling the request (see note). Passing TM_INFINITE causes the caller to block indefinitely until the request is fulfilled. Passing TM_NONBLOCK causes the service to return immediately without waiting if the request cannot be satisfied immediately.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>event</em> is not a event group descriptor.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>event</em> is a deleted event group descriptor, including if the deletion occurred while the caller was sleeping on it before the request has been satisfied.</li>
</ul>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to TM_NONBLOCK and the current event mask value does not satisfy the request.</li>
</ul>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task.">rt_task_unblock()</a> has been called for the waiting task before the request has been satisfied.</li>
</ul>
<ul>
<li>-ETIMEDOUT is returned if the request has not been satisfied within the specified amount of time.</li>
</ul>
<ul>
<li>-EPERM is returned if this service should block, but was called from a context which cannot sleep (e.g. interrupt, non-realtime context).</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code or Interrupt service routine only if <em>timeout</em> is equal to TM_NONBLOCK.</li>
<li>Kernel-based task</li>
<li>User-space task (switches to primary mode)</li>
</ul>
<p>Rescheduling: always unless the request is immediately satisfied or <em>timeout</em> specifies a non-blocking operation.</p>
<dl class="section note"><dt>Note</dt><dd>The <em>timeout</em> value will be interpreted as jiffies if the native skin is bound to a periodic time base (see CONFIG_XENO_OPT_NATIVE_PERIOD), or nanoseconds otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga81e2c7a3346b2364a153a24be291b204"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_event_wait_until </td>
          <td>(</td>
          <td class="paramtype">RT_EVENT *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>mask_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pend on an event group (with absolute timeout date). </p>
<p>Waits for one or more events on the specified event group, either in conjunctive or disjunctive mode.</p>
<p>If the specified set of bits is not set, the calling task is blocked. The task is not resumed until the request is fulfilled. The event bits are NOT cleared from the event group when a request is satisfied; <a class="el" href="group__event.html#ga6e9f775275661d9258f8b1eb02fe4681" title="Pend on an event group.">rt_event_wait()</a> will return immediately with success for the same event mask until <a class="el" href="group__event.html#ga448889bcfd01ed892d97a0b00fdaf553" title="Clear an event group.">rt_event_clear()</a> is called to clear those bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The descriptor address of the affected event group.</td></tr>
    <tr><td class="paramname">mask</td><td>The set of bits to wait for. Passing zero causes this service to return immediately with a success value; the current value of the event mask is also copied to <em>mask_r</em>.</td></tr>
    <tr><td class="paramname">mask_r</td><td>The value of the event mask at the time the task was readied.</td></tr>
    <tr><td class="paramname">mode</td><td>The pend mode. The following flags can be OR'ed into this bitmask, each of them affecting the operation:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>EV_ANY makes the task pend in disjunctive mode (i.e. OR); this means that the request is fulfilled when at least one bit set into <em>mask</em> is set in the current event mask.</li>
</ul>
<ul>
<li>EV_ALL makes the task pend in conjunctive mode (i.e. AND); this means that the request is fulfilled when at all bits set into <em>mask</em> are set in the current event mask.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The absolute date specifying a time limit to wait for fulfilling the request (see note). Passing TM_INFINITE causes the caller to block indefinitely until the request is fulfilled. Passing TM_NONBLOCK causes the service to return immediately without waiting if the request cannot be satisfied immediately.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>event</em> is not a event group descriptor.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>event</em> is a deleted event group descriptor, including if the deletion occurred while the caller was sleeping on it before the request has been satisfied.</li>
</ul>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to TM_NONBLOCK and the current event mask value does not satisfy the request.</li>
</ul>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task.">rt_task_unblock()</a> has been called for the waiting task before the request has been satisfied.</li>
</ul>
<ul>
<li>-ETIMEDOUT is returned if the absolute <em>timeout</em> date is reached before the request is satisfied.</li>
</ul>
<ul>
<li>-EPERM is returned if this service should block, but was called from a context which cannot sleep (e.g. interrupt, non-realtime context).</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code or Interrupt service routine only if <em>timeout</em> is equal to TM_NONBLOCK.</li>
<li>Kernel-based task</li>
<li>User-space task (switches to primary mode)</li>
</ul>
<p>Rescheduling: always unless the request is immediately satisfied or <em>timeout</em> specifies a non-blocking operation.</p>
<dl class="section note"><dt>Note</dt><dd>The <em>timeout</em> value will be interpreted as jiffies if the native skin is bound to a periodic time base (see CONFIG_XENO_OPT_NATIVE_PERIOD), or nanoseconds otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Oct 4 2013 22:39:09 for Xenomai API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.2 </li>
  </ul>
</div>
</body>
</html>
